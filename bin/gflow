#!/bin/bash

################################################################################
# Generic Flow v5.1 (May 2023)
################################################################################
#
# Copyright 2011-2023 Gennady Kirpichev (https://github.com/32xlr8/gflow.git)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
################################################################################
# Filename: bin/gflow
# Purpose:  Generic Flow task control tool
################################################################################

##################################################
GF_TITLE="Generic Flow v5.1 (May 2023)"
##################################################

# Generic Flow binary
GF_BIN_FILE="$0"

##################################################
# Colored marks
##################################################

# Marks
GFC0=$'\e[0m'
GFM0=$'\e[90;40m'
GFM1=$'\e[91;41m'
GFM2=$'\e[92;42m'
GFM3=$'\e[93;43m'
GFM4=$'\e[94;44m'
GFM5=$'\e[95;45m'
GFM6=$'\e[96;46m'
GFM7=$'\e[97;47m'

# Message marks
GFME="${GFM1} ${GFC0}"
GFMW="${GFM3} ${GFC0}"
GFMI="${GFM7} ${GFC0}"
GFMO="${GFM6} ${GFC0}"
GFMP="${GFM4} ${GFC0}"

# Foreground colors
GFC0=$'\e[0m'
GFC1=$'\e[31m'
GFC2=$'\e[32m'
GFC3=$'\e[33m'
GFC4=$'\e[34m'
GFC5=$'\e[35m'
GFC6=$'\e[36m'
GFC7=$'\e[37m'

# Highlight colors
GFC0=$'\e[0m'
GFH1=$'\e[91m'
GFH2=$'\e[92m'
GFH3=$'\e[93m'
GFH4=$'\e[94m'
GFH5=$'\e[95m'
GFH6=$'\e[96m'
GFH7=$'\e[97m'

# Message colors
GFCE="${GFC1}"
GFCW="${GFC3}"
GFCH="${GFC7}"
GFCB=$'\e[1m'
GFCU=$'\e[4m'
GFCN=$'\e[7m'

# Clear mark
GFK=$'\e[0J'
GFN=$'\n'
GFR=$'\r'

##################################################
# Public functions
##################################################

# Remove dummy path parts
gf_simplify_path_perl='
    s:/{2,}:/:g;
    if ($_ ne "/") {
        s:^\./::g;
        1 while (s:/\./:/:);
        while (m:[^/]+/\.\.(/|$):) {
            last if (m:^\.\./\.\.:);
            s:[^/]+/\.\.(/|$)::;
        }
        s:/\.$::;
        s:[/\s]+$::;
        s:(/\.)+$::;
    }
'

# Expand path relative to second argument
gf_full_path_perl='
    my $pwd = "";
    my $rel = "";
    while (<STDIN>) {
        s:^\s+::;
        s:\s+$::;
        if ($_ ne "") {
            if ($pwd eq "") {
                $pwd = $_;
            } elsif ($rel eq "") {
                $_ = $pwd."/".$_ if (!m:^/:);
                '"$gf_simplify_path_perl"'
                $rel = $_;
            } else {
                $_ = $rel."/".$_ if (!m:^/:);
                '"$gf_simplify_path_perl"'
                print $_."\n";
            }
        }
    }
'

# Expand path of each argument
function gf_full_path {
    for arg in "$PWD" "$PWD" "$@"; do echo "$arg"; done | perl -e "$gf_full_path_perl"
}

# Expand path of each argument relative to first argument
function gf_full_path_rel {
    for arg in "$PWD" "$@"; do echo "$arg"; done | perl -e "$gf_full_path_perl"
}

# Get path relative to second argument
gf_relative_path_perl='
    my $pwd = "";
    my $rel = ""; my @rel;
    while (<STDIN>) {
        s:^\s+::;
        s:\s+$::;
        if ($_ ne "") {
            if ($pwd eq "") {
                $pwd = $_;
            } elsif ($rel eq "") {
                s:/+$::;
                $_ = $pwd."/".$_ if (!m:^/:);
                '"$gf_simplify_path_perl"'
                $rel = $_;
                s:^/::;
                @rel = split (/\/+/, $_);
            } else {
                $_ = $pwd."/".$_ if (!m:^/:);
                '"$gf_simplify_path_perl"'
                s:^/::; $_ .= "/";
                my @path = split (/\/+/, $_);
                my $diff = 0; $diff++ while (($diff<=$#rel) && ($diff<=$#path) && ($rel[$diff] eq $path[$diff]));
                for (my $i=0; $i<$diff; $i++) { s:^[^/]+/::; }
                for (my $i = $diff; $i<=$#rel; $i++) { $_ = "../".$_; }
                $_ = "./".$_ if (!/^\./);
                s:[/\s]+$::;
                print $_."\n";
            }
        }
    }
'
# Expand path of each argument relative to first argument
function gf_relative_path {
    for arg in "$PWD" "$@"; do echo "$arg"; done | perl -e "$gf_relative_path_perl"
}

# Escape single quotes
function gf_escape_single_quotes {
    echo "$@" | sed -e "s/\\\\/\\\\\\\\/g; s/'/\\\'/g"
}

# Highlight matching file part
gf_highlight_common_path_perl='
    my @file1 = reverse(split(/\/+/, shift));
    my @file2 = reverse(split(/\/+/, shift));
    my @matching;
    while (($file1[0] eq $file2[0]) && ($#file1 >= 0) && ($#file2 >= 0)) {
        push @matching, $file1[0];
        shift @file1;
        shift @file2;
    }
    print join("/", reverse @file1);
    print "/" if (($#file1 >= 0) && ($#matching >= 0));
    print "'${GFCB}'".join("/", reverse @matching)."'${GFC0}'" if ($#matching >= 0);
    print "\n";
'

# Print status once a second
gf_print_status_perl='
    my $status_time = 0;
    sub print_status {
        my $now = time;
        if (($now - $status_time) > 1) {
            $status_time = $now;
            my $status = shift;
            $status =~ s/\s+$//;
            $status =~ s/^(\S)/  $1/;
            my $erase = $status;
            $status =~ s/\\e(\[[0-9\;]+m)/\e$1/g;
            $erase =~ s/\\e(\[[0-9\;]+m)//g;
            $erase =~ s/./\b/g;
            print STDERR "'${GFK}'".$status.$erase if ($status);
        }
    }
'

# Convert pattern to perl regexp
gf_fix_regexp_pattern_perl='
    sub fix_regexp_pattern {
        my $pattern = shift;
        if (!($pattern =~ /[\[\]\(\)\+\^\$\|\\]/)) {
            $pattern =~ s/\./\\./g;
            $pattern =~ s/\*/.*/g;
            $pattern =~ s/\?/./g;
        }
        return $pattern;
    }
'

# Scan directories for files and symlinks
gf_scan_dirs_perl='
    '"$gf_fix_regexp_pattern_perl"'
    my @results; my %results;
    my @links;
    my %types;
    while (<STDIN>) {
        if (/^:::([A-Z]+):::$/) {
            $type = $1;
        } elsif ($type eq "TYPES") {
            tr/a-z/A_Z/;
            $types{$1} = 1 while (s/([DFL])//);
        } elsif (($type eq "FOLLOW") || ($type eq "DEPTH")) {
            s/\s+$//;
            $data{$type} = $_;
        } elsif ($type eq "DIRS") {
            push @{$data{$type}}, $_;
        } elsif ($type eq "EXCLUDE") {
            push @{$data{$type}}, fix_regexp_pattern($1) while (s/(\S+)//);
        }
    }
    my $follow_links = ($data{FOLLOW} || 0);
    my $max_depth = $data{DEPTH}; $max_depth = "" if ($max_depth =~ /[^\d]/);
    '"$gf_print_status_perl"'
    sub scan_directory {
        my $dir = shift;
        my $target = shift;
        my $depth = shift;
        $dir =~ s|/*\s*$||;
        $target =~ s|/*\s*$||;
        my $include = 1; foreach my $pattern (@{$data{EXCLUDE}}) { $include = 0 if ($dir =~ m|$pattern|); }
        if ($include && (!defined $results{$target})) {
            push @results, $dir."/" if (defined $types{D});
            $results{$dir} = 1;
            $results{$target} = 1;
            if (-l $dir) {
                my $link = `readlink -m "$dir"`;
                $results{$link} = 1;
            }
            if (opendir DIR, $target) {
                print_status "$dir/";
                my @files = readdir DIR;
                closedir DIR;
                foreach my $file (@files) {
                    if (($file ne "..") && ($file ne ".")) {
                        my $path = $dir."/".$file;
                        if (!defined $results{$path}) {
                            if (-l $path) {
                                if (-d $path) {
                                    push @links, $path if (($max_depth eq "") || ($depth < $max_depth));
                                }
                                push @results, $path if (defined $types{L});
                            } elsif (-f $path) {
                                push @results, $path if (defined $types{F});
                            } else {
                                scan_directory($path, $target."/".$file, $depth+1) if (($max_depth eq "") || ($depth < $max_depth));
                            }
                            $results{$path} = 1;
                        }
                    }
                }
            } else {
                print STDERR "'${GFK}${GFM1}' '${GFC0}' Cannot read '${GFCB}'".$dir."'${GFC0}' directory\n";
            }
        }
    }
    scan_directory($_, `readlink -m "$_"`, 0) foreach (@{$data{DIRS}});
    if ($follow_links eq "1") { scan_directory($_, `readlink -m "$_"`, 0) foreach (@links); }
    print STDERR "'${GFK}'";
    print STDOUT join("\n", @results)."\n";
'

# Scan directory recursively
function gf_scan_dirs {
    echo ":::DIRS:::"$'\n'"$1"$'\n'":::TYPES:::"$'\n'"$2"$'\n'":::FOLLOW:::"$'\n'"$3"$'\n'":::DEPTH:::"$'\n'"$4"$'\n'":::EXCLUDE:::"$'\n^\s*$\n'"$5" | perl -e "$gf_scan_dirs_perl" 2> /dev/tty
}

# Search and filter files script
gf_search_files_perl='
    '"$gf_fix_regexp_pattern_perl"'
    my $type = "";
    my %data;
    my $is_same = 0;
    while (<STDIN>) {
        if (/^:::([A-Z]+):::$/) {
            $type = $1;
        } elsif (($type eq "FILES") || ($type eq "SEARCH")) {
            s/^\s+//;
            s/\s+$//;
            push @{$data{$type}}, $_ if ($_ ne "");
        } elsif ($type eq "SAME") {
            $is_same = $1 if (/(\S+)/);
        } elsif (($type eq "EXCLUDE") || ($type eq "HIGH") || ($type eq "LOW")) {
            push @{$data{$type}}, fix_regexp_pattern($1) while (s/(\S+)//);
        } elsif ($type eq "REPLACE") {
            while (s/(\S+)//) {
                my $pair = $1;
                push @{$data{$type}}, fix_regexp_pattern($1)."=".$2 if ($pair  =~ /^([^=]+)=(.+)$/);
            }
        }
    }
    my %files;
    foreach (@{$data{FILES}}) {
        my $include = 1;
        foreach my $pattern (@{$data{EXCLUDE}}) { $include = 0 if (m|$pattern|); }
        if ($include) {
            my $file = $_;
            s:/+$::;
            push @{$files{$_}}, $file;
            push @{$files{$_}}, $file while (s|^[^/]*/||);
            $_ = $file;
            foreach my $pattern (@{$data{REPLACE}}) {
                if ($pattern =~ /^([^=]+)=(.+)$/) {
                    my $from = $1;
                    my $to = $2;
                    s|$from|$to|ge;
                }
            }
            if ($file ne $_) {
                push @{$files{$_}}, $file;
                push @{$files{$_}}, $file while (s|^[^/]*/||);
            }
        }
    }
    my %found;
    my @search;
    foreach my $search (@{$data{SEARCH}}) {
        my $include = 1;
        foreach my $file (split /:::/, $search) {
            foreach my $pattern (@{$data{EXCLUDE}}) { $include = 0 if ($file =~ m|$pattern|); }
        }
        if ($include) {
            my $path = "/".$search;
            push @search, $search;
            my $last = 0;
            while ($path =~ s|^[^/]*/+||g) {
                if (defined $files{$path}) {
                    if ($is_same) {
                        foreach my $file (@{$files{$path}}) {
                            push @{$found{$search}}, $file;
                            $last = 1;
                        }
                    } else {
                        foreach my $file (@{$files{$path}}) {
                            my $t1 = $search; $t1 =~ s:^(\./)::g;
                            my $t2 = $file; $t1 =~ s:^(\./)::g;
                            if ($t1 ne $t2) {
                                push @{$found{$search}}, $file;
                                $last = 1;
                            }
                        }
                    }
                    last if ($last);
                }
            }
        }
    }
    foreach my $search (@search) {
        my @filtered;
        my $max_priority = 0;
        foreach my $found (@{$found{$search}}) {
            my $priority = 0;
            foreach my $pattern (@{$data{LOW}}) { $priority-- if ($found =~ m|$pattern|); }
            foreach my $pattern (@{$data{HIGH}}) { $priority++ if ($found =~ m|$pattern|); }
            $max_priority = $priority if ($#filtered < 0);
            if ($priority >= $max_priority) {
                @filtered = () if ($priority > $max_priority);
                push @filtered, $found;
                $max_priority = $priority;
            }
        }
        my %unique; my @unique;
        my %replaced; my @replaced;
        foreach (@filtered) {
            if (!defined $unique{$_}) {
                $unique{$_} = 1;
                push @unique, $_;
            }
            foreach my $pattern (@{$data{REPLACE}}) {
                if ($pattern =~ /^([^=]+)=(.+)$/) {
                    my $from = $1;
                    my $to = $2;
                    s|$from|$to|ge;
                }
            }
            if (!defined $replaced{$_}) {
                $replaced{$_} = 1;
                push @replaced, $_;
            }
        }
        print $search."|||". join(":::", @unique)."|||". join(":::", @replaced)."\n";
    }
'

# Detect files in custom content
gf_detect_files_in_line_perl='
    my @parts;
    push @parts, $1 while (s/(\$env\(\w+\))/"_GFPART".($#parts+1)."TRAPFG_"/e);
    push @parts, $1 while (s/(\$\w+)/"_GFPART".($#parts+1)."TRAPFG_"/e);
    push @parts, $1 while (s/(\$\{[\w\:]+\})/"_GFPART".($#parts+1)."TRAPFG_"/e);
    push @parts, $1 while (s/(\\.)/"_GFPART".($#parts+1)."TRAPFG_"/e);
    my $not_file_chars = '"'"'\{\[\(\s\#\@\%\&\:\,\!\\\"\'"'"'\)\]\}\$'"'"';
    sub detected {
        my $file = shift;
        my $parts = shift;
        my $not_file = "";
        $not_file = $1 if ($file =~ s/(\.+)$//);
        $file =~ s/_GFPART(\d+)TRAPFG_/$$parts[$1]/ge;
        if (defined $files{$file}) {
            return "_GFFILE".$files{$file}."ELIFFG_".$not_file;
        } else {
            my $is_file = 1;
            $is_file = 0 if ($file =~ /\*/);
            $is_file = 0 if ($file =~ /(^|\/)\d+(\.\d+)?$/);
            foreach my $text (keys %exclude_patterns) {
                $is_file = 0 if ($file =~ m|$text|);
            }
            $files[$#files+1]{is_file} = $is_file;
            $files{$file} = $#files;
            if ($replaces{$file} eq "") {
                $files[$#files]{text} = $file;
            } else {
                $files[$#files]{text} = $replaces{$file};
                $count++;
            }
            return "_GFFILE".($#files)."ELIFFG_".$not_file;
        }
    }
    s/([^$not_file_chars]+\/[^$not_file_chars]+)/detected($1, \@parts)/ge;
    s/([^\/$not_file_chars]{2,}\.[a-zA-Z][a-zA-Z0-9]{1,5})([$not_file_chars]|$)/detected($1, \@parts).$2/ge;
'

# Search SEARCH files in FILES list
function gf_search_files {
    echo ":::FILES:::"$'\n'"$1"$'\n'":::SEARCH:::"$'\n'"$2"$'\n'":::EXCLUDE:::"$'\n^\s*$\n'"$3"$'\n'":::HIGH:::"$'\n'"$4"$'\n'":::LOW:::"$'\n'"$5"$'\n'":::REPLACE:::"$'\n'"$6"$'\n'":::SAME:::"$'\n'"$7" | perl -e "$gf_search_files_perl"
}

# Exclude lines matching patterns
gf_exclude_lines_perl='
    '"$gf_fix_regexp_pattern_perl"'
    my $type = "";
    my %data;
    while (<STDIN>) {
        if ($type eq "CONTENT") {
            push @{$data{$type}}, $_;
        } elsif (/^:::([A-Z]+):::$/) {
            $type = $1;
        } elsif (($type eq "INCLUDE") || ($type eq "EXCLUDE")) {
            push @{$data{$type}}, fix_regexp_pattern($1) while (s/(\S+)//);
        }
    }
    my @results;
    foreach (@{$data{CONTENT}}) {
        my $include = 0;
        if ($#{$data{INCLUDE}} >= 0) {
            foreach my $pattern (@{$data{INCLUDE}}) {
                $include = 1 if (m|$pattern|);
            }
        } else {
            $include = 1;
        }
        foreach my $pattern (@{$data{EXCLUDE}}) {
            $include = 0 if (m|$pattern|);
        }
        print if ($include);
    }
'

# Parse bash script and splits content by type
# $results[*]{char|text}: s = single quote string, d - double quote, c - command, e - escaped char, z - default
gf_parse_bash_perl='
    my @quotes;

    my %marks;
    $marks{s} = "\e[0;37;44m";
    $marks{d} = "\e[0;93;42m";
    $marks{c} = "\e[0;93;41m";
    $marks{e} = "\e[0;33;45m";
    $marks{z} = "\e[0m";

    my @chars;
    push @chars, "z";

    my @results;
    sub add_result {
        my $text = shift;
        if ($#results < 0) {
            $results[$#results+1]{char} = $chars[$#chars];
            $results[$#results]{text} = $text;
        } elsif ($results[$#results]{char} eq $chars[$#chars]) {
            $results[$#results]{text} .= $text;
        } else {
            $results[$#results+1]{char} = $chars[$#chars];
            $results[$#results]{text} = $text;
        }
    }

    my $line = 0;
    while (<STDIN>) {
        $line++;
        print STDERR "$line\t";
        while (($_ ne "") && (s/^([^\'"'"'\"\#\\]*?)([\'"'"'\"\#]|\$\(|\)|\\(.|$))//)) {
            my $text = $1;
            my $char = $2;
            my $escape = "";
            $escape = $1 if ($char =~ s/^(\\)//);

            add_result($text);
            print STDERR $text;

            if ($#quotes < 0) {
                if ($escape eq "") {
                    push @quotes, $char;
                    if ($char eq "\'"'"'") {
                        push @chars, "s";
                    } elsif ($char eq "\"") {
                        push @chars, "d";
                    } elsif ($char eq "\$\(") {
                        push @chars, "c";
                    } else {
                        pop @quotes;
                        if ($char eq "\#") {
                            add_result($char);
                            print STDERR $char;
                            last;
                        }
                    }
                    add_result($char);
                    print STDERR $marks{$chars[$#chars]}.$char;
                } else {
                    add_result($escape.$char);
                    print STDERR $marks{e}.$escape.$char.$marks{$chars[$#chars]};
                }

            } elsif ($quotes[$#quotes] eq "\'"'"'") {
                add_result($escape.$char);
                print STDERR $escape.$char;
                if ($char eq "\'"'"'") {
                    pop @quotes;
                    pop @chars;
                    print STDERR $marks{$chars[$#chars]};
                }

            } elsif ($quotes[$#quotes] eq "\"") {
                if ($escape eq "") {
                    if ($char eq "\"") {
                        add_result($char);
                        pop @quotes;
                        pop @chars;
                        print STDERR $char.$marks{$chars[$#chars]};
                    } elsif ($char eq "\$\(") {
                        push @quotes, $char;
                        push @chars, "c";
                        add_result($char);
                        print STDERR $marks{$chars[$#chars]}.$char;
                    } else {
                        add_result($char);
                        print STDERR $char;
                    }
                } else {
                    add_result($escape.$char);
                    print STDERR $marks{e}.$escape.$char.$marks{$chars[$#chars]};
                }

            } elsif ($quotes[$#quotes] eq "\$\(") {
                if ($escape eq "") {
                    if ($char eq "\)") {
                        add_result($char);
                        pop @quotes;
                        pop @chars;
                        print STDERR $char.$marks{$chars[$#chars]};
                    } else {
                        push @quotes, $char;
                        if ($char eq "\'"'"'") {
                            push @chars, "s";
                        } elsif ($char eq "\"") {
                            push @chars, "d";
                        } elsif ($char eq "\$\(") {
                            push @chars, "c";
                        } elsif ($char eq "\\") {
                            push @chars, "e";
                        } else {
                            pop @quotes;
                            if ($char eq "\#") {
                                add_result($char);
                                print STDERR $char;
                                last;
                            }
                        }
                        add_result($char);
                        print STDERR $marks{$chars[$#chars]}.$char;
                    }
                } else {
                    add_result($escape.$char);
                    print STDERR $marks{e}.$escape.$char.$marks{$chars[$#chars]};
                }

            } else {
                add_result($char);
                print STDERR $char;
            }
        }
        if ($quotes[$#quotes] eq "\\") {
            pop @quotes;
            pop @chars;
            print STDERR $marks{$chars[$#chars]};
        }
        if ($_ ne "") {
            add_result($_);
            print STDERR;
        }
    }
'

# Grep file content following directives
# =N=<max number of lines> - mandatory
# =I=./logs/$TASK_NAME.log"$'\n' - mandatory
# =E=<expression>
# =F=<from expr to check log>
# =T=<to expr to check log>
# =X=<expr to exclude lines from the results>
# =B=<lines to print before matching ones>
# =A=<lines to print after matching ones>
gf_grep_file_perl='
    my @filters; my $filters = -1;
    my @files; my %files; my %files_by_filter;
    while (<STDIN>) {
        if (/^=(N)=(\d*)$/) {
            $filters[++$filters]{$1} = ($2 || 100);
        } elsif (/^=([FTEX])=(.*)\n$/) {
            if ($2 ne "") {
                push @{$filters[$filters]{$1}}, $2;
            }
        } elsif (/^=([AB])=[\+\-]?(\d+)\n$/) {
            $filters[$filters]{$1} = $2;
        } elsif (/^=([I])=(.*)\n$/) {
            if ($2 ne "") {
                push @files, $2 if (!defined $files{$2}); $files{$2} = 1;
                $filters[$filters]{$1}{$2} = 1;
            }
        }
    }
    foreach my $file (@files) {
        open FILE, $file or next;
        my @lines; my @active; while (<FILE>) {
            push @lines, $_;
            push @active, 0;
        }
        close FILE;
        my $lines = $#lines;
        next if ($lines < 0);
        my @lines_reverse = reverse @lines;

        foreach my $filter (@filters) {
            next if (!$$filter{I}{$file});

            my @filters_F = @{$$filter{F}}; my $filters_F = $#filters_F;
            my @filters_T = reverse @{$$filter{T}}; my $filters_T = $#filters_T;
            my @filters_E = @{$$filter{E}}; my $filters_E = $#filters_E;
            my @filters_X = @{$$filter{X}};

            my $count_F = ($$filter{B} || 0);
            my $count_T = ($$filter{A} || 0);

            my @matched_F; my @matched_T;

            if ($filters_F >= 0) {
                my $matched = 0;
                my $expr = $filters_F[$matched];
                my $counter=0; foreach (@lines) {
                    while ($matched<=$filters_F) {
                        if ($_ =~ $expr) {
                            if ($matched==$filters_F) {
                                push @matched_F, $counter;
                                push @matched_T, $counter if (($filters_T < 0) && ($filters_E < 0));
                                $expr = $filters_F[$matched=0];
                                last;
                            } else {
                                $expr = $filters_F[++$matched];
                            }
                        } else { last }
                    }
                    $counter++;
                }
                next if ($#matched_F<0);
            }

            if ($filters_T >= 0) {
                my $matched = 0;
                my $expr = $filters_T[$matched];
                my $counter=$lines; foreach (@lines_reverse) {
                    while ($matched<=$filters_T) {
                        if ($_ =~ $expr) {
                            if ($matched==$filters_T) {
                                push @matched_T, $counter;
                                push @matched_F, $counter if (($filters_F < 0) && ($filters_E < 0));
                                $expr = $filters_T[$matched=0];
                                last;
                            } else {
                                $expr = $filters_T[++$matched];
                            }
                        } else { last }
                    }
                    $counter--;
                }
                next if ($#matched_T<0);
            }

            push @matched_F, 0 if ($#matched_F<0); @matched_F = sort {$a<=>$b} @matched_F; push @matched_F, 0;
            push @matched_T, $lines if ($#matched_T<0); @matched_T = sort {$a<=>$b} @matched_T; push @matched_T, 0;

            my @matched_local;
            if ($filters_E < 0) {
                my $next_F_index = 0; my $next_F = $matched_F[$next_F_index];
                my $next_T_index = 0; my $next_T = $matched_T[$next_T_index];
                my $is_range = 0; my $counter=0; foreach (@lines) {
                    if ($counter == $next_F) {
                        $next_F = $matched_F[++$next_F_index];
                        $is_range = 1;
                    }
                    push @matched_local, $counter if ($is_range);
                    if ($counter == $next_T) {
                        $next_T = $matched_T[++$next_T_index];
                        $is_range = 0;
                    }
                    $counter++;
                }
            } else {
                foreach my $expr (@filters_E) {
                    my $next_F_index = 0; my $next_F = $matched_F[$next_F_index];
                    my $next_T_index = 0; my $next_T = $matched_T[$next_T_index];
                    my $is_range = 0; my $counter=0; foreach (@lines) {
                        if ($counter == $next_F) {
                            $next_F = $matched_F[++$next_F_index];
                            $is_range = 1;
                        }
                        push @matched_local, $counter if ($is_range && ($_ =~ $expr));
                        if ($counter == $next_T) {
                            $next_T = $matched_T[++$next_T_index];
                            $is_range = 0;
                        }
                        $counter++;
                    }
                }
            }

            my @active_local; my @active_excluded; my $i;
            my $last_line = -1; my $line; foreach $line (sort {$a<=>$b} @matched_local) {
                $i = $line - $count_F;
                $i = $last_line+1 if ($i <= $last_line);
                $i = 0 if ($i < 0);
                $last_line = $line + $count_T;
                $last_line = $lines if ($last_line > $lines);
                while ($i<=$last_line) {
                    push @active_local, $i++;
                    push @active_excluded, 0;
                }
            }

            foreach my $expr (@filters_X) {
                my $counter=0; my $line; for (@active_local) {
                    $line = $lines[$_];
                    $active_excluded[$counter] = 1 if ($line =~ $expr);
                    $counter++;
                }
            }

            my $counter=0; for (@active_local) {
                $active[$_] = 1 if (!$active_excluded[$counter++]);
            }
        }

        my $counter = 0; foreach (@lines) {
            push @results, $_ if ($active[$counter++]);
        }
    }
'

# Transform task to file script
gf_task_to_file_pattern_perl='
    my $result = "";
    my $task = "";
    my $run = "";
    my $line = 0;
    while (<STDIN>) {
        $line++;
        if ($line == 1) {
            s/\n$//;
            $task = $_; $task =~ s|^.*/tasks/||;
            $run = $_; $run =~ s|/tasks/.*?$||;
        } else {
            s:\$\{(task|task_name)\}:$task:i;
            s:\$(task|task_name)\b:$task:i;
            s:\$\{(run|run_dir)\}:$run:i;
            s:\$(run|run_dir)\b:$run:i;
            print "$_\n";
        }
    }
'

# Exclude files matching EXCLUDE patterns
function gf_exclude_files {
    echo ":::EXCLUDE:::"$'\n^\s*$\n'"$2"$'\n'":::CONTENT:::"$'\n'"$1" | perl -e "$gf_exclude_lines_perl"
}

# Keep only files matching INCLUDE patterns
function gf_filter_files {
    echo ":::EXCLUDE:::"$'\n^\s*$\n'":::INCLUDE:::"$'\n'"$2"$'\n'":::CONTENT:::"$'\n'"$1" | perl -e "$gf_exclude_lines_perl"
}

# Keep only files matching INCLUDE patterns
function gf_filter_lines {
    echo ":::EXCLUDE:::"$'\n^\s*$\n'":::INCLUDE:::"$'\n'"$2"$'\n'":::CONTENT:::"$'\n'"$1" | perl -e "$gf_exclude_lines_perl"
}

# Count non-empty lines
function gf_count_lines {
    for arg in "$@"; do echo -e "$arg"; done | perl -e '
        my $count = 0;
        while (<STDIN>) {
            $count++ if (/\S/);
        }
        print "$count\n";
    '
}

# Count words
function gf_count_words {
    echo -e "$@" | perl -e '
        my $count = 0;
        while (<STDIN>) {
            $count++ while (s/\S+//);
        }
        print "$count\n";
    '
}

# Export script to pack missing and modified files
function gf_export_pack_script {
    local out_file="$1"
    local files="$2"

    local commands=
    function add_file {
        if [ -e "$2" ]; then
            if [ ! -d "$2" ]; then
                commands+="pack_file '$1' $(md5sum "$2" | awk '{print $1;}')"$'\n'
            fi
        else
            commands+="pack_file '$1'"$'\n'
        fi
    }
    gf_echo -ne "${GFM6}#${GFC0} Exporting script to pack modified or missing files ..."
    eval "$(echo "$files" | perl -e '
        while (<STDIN>) {
            s/\s*$//;
            if ($_ ne "") {
                $_ = "add_file '"'"'".$_."'"'"'" if (!s/^'"'"'/add_file '"'"'/);
                print $_."\n";
            }
        }
    ')"
    commands="$(echo "$commands" | awk '!x[$0]++')"
    rm -f "$out_file"
    echo '#!/bin/bash

        # Add existing file to pack list
        files=
        matched=0; modified=0; found=0; lost=0
        function pack_file {
            if [ -e "$1" ]; then

                # Check MD5 sum if it is known
                if [ -n "$2" ]; then
                    if [ "$(md5sum "$1" | awk '"'"'{print $1;}'"'"')" != "$2" ]; then
                        files+="$1"$'"'"'\n'"'"'
                        echo -ne "'${GFM3}' '${GFC0}' "
                        modified=$((modified+1))
                    else
                        echo -ne "'${GFM4}' '${GFC0}' "
                        matched=$((matched+1))
                    fi

                # Pack file if MD5 sum unknown
                else
                    echo -ne "'${GFM2}' '${GFC0}' "
                    files+="$1"$'"'"'\n'"'"'
                    found=$((found+1))
                fi

            # Report not found file
            else
                echo -ne "'${GFM1}' '${GFC0}' "
                lost=$((lost+1))
            fi
            echo "$1"
        }

        echo; echo -e "'${GFM6}' '${GFC0}' Checking files ..."; echo

        # Commands to pack files
        '"$commands"'

        # Print summary
        echo; echo -e "'${GFM6}' '${GFC0}' Summary"; echo
        [[ $matched -gt 0 ]] && echo -e "'${GFM4}' '${GFC0}' $matched matched files skipped"
        [[ $modified -gt 0 ]] && echo -e "'${GFM3}' '${GFC0}' $modified modified files to pack"
        [[ $found -gt 0 ]] && echo -e "'${GFM2}' '${GFC0}' $found new files to pack"
        [[ $lost -gt 0 ]] && echo -e "'${GFM1}' '${GFC0}' $lost files not found"

        # Pack files from the list
        if [ -n "$files" ]; then
            if [ -n "$1" ]; then
                result_archive="$1"
            else
                result_archive="$(basename "$0").tar.gz"
            fi

            echo; echo -e "'${GFM6}' '${GFC0}' Creating '${GFCB}'$result_archive'${GFC0}' ..."; echo
            ok=0; tar -czhvf "$result_archive" $files && ok=1; echo

            if [ $ok == 1 ]; then
                if [ $lost == 0 ]; then
                    echo -e "'${GFM2}' '${GFC0}' All files packed"
                else
                    echo -e "'${GFM3}' '${GFC0}' All except $lost not found files packed"
                fi
            else
                echo -e "'${GFM1}' '${GFC0}' Failed to create archive"
            fi

        elif [ $lost -gt 0 ]; then
            echo; echo -e "'${GFM1}' '${GFC0}' No files to pack"

        else
            echo; echo -e "'${GFM2}' '${GFC0}' All files are up to date"
        fi

        echo
    ' | sed -e 's/^        //' > "$out_file"
    gf_echo "$(gf_count_lines "$commands") files"
    chmod a+x "$out_file"
    gf_result "$(readlink -m "$out_file")"
    gf_spacer
}

# Export script to compare md5sum of the files
function gf_export_compare_script {
    local out_file="$1"
    local files="$2"
    local commands=
    function add_file {
        if [ ! -d "$2" -a -e "$2" ]; then
            if [[ $2 != /dev/* ]]; then
                commands+="compare_file '$2' '$(md5sum "$2" | awk '{print $1;}')'"$'\n'
            fi
        fi
    }
    gf_echo -ne "${GFM6}#${GFC0} Exporting script to compare and identify modified files ... "
    eval "$(echo "$files" | perl -e '
        while (<STDIN>) {
            s/\s*$//;
            if ($_ ne "") {
                $_ = "add_file '"''"' '"'"'".$_."'"'"'" if (!s/^'"'"'/add_file '"'"'/);
                print $_."\n";
            }
        }
    ')"
    commands="$(echo "$commands" | awk '!x[$0]++')"
    rm -f "$out_file"
    echo '#!/bin/bash

        # Add existing file to compare list
        files=
        matched=0; modified=0; lost=0; count=0
        function compare_file {
            if [ -e "$1" ]; then
                if [ "$(md5sum "$1" | awk '"'"'{print $1;}'"'"')" != "$2" ]; then
                    echo -ne "'${GFM3}' '${GFC0}' "
                    modified=$((modified+1))
                else
                    echo -ne "'${GFM2}' '${GFC0}' "
                    matched=$((matched+1))
                fi
            else
                lost=$((lost+1))
                echo -ne "'${GFM1}' '${GFC0}' "
            fi
            count=$((count+1))
            echo "$1"
        }

        echo; echo -e "'${GFM6}' '${GFC0}' Comparing files ..."; echo

        # Commands to compare files
        '"$commands"'

        # Print summary
        if [ $count -gt 0 ]; then
            echo; echo -e "'${GFM6}' '${GFC0}' Summary"; echo
            [[ $matched -gt 0 ]] && echo -e "'${GFM2}' '${GFC0}' $matched files matched"
            [[ $modified -gt 0 ]] && echo -e "'${GFM3}' '${GFC0}' $modified files modified"
            [[ $lost -gt 0 ]] && echo -e "'${GFM1}' '${GFC0}' $lost files not found"
        else
            echo -e "'${GFM1}' '${GFC0}' No files to check"
        fi

        echo
    ' | sed -e 's/^        //' > "$out_file"
    gf_echo "$(gf_count_lines "$commands") files"
    chmod a+x "$out_file"
    gf_result "$(readlink -m "$out_file")"
    gf_spacer
}

# Cursor show and hide
GF_IS_CURSOR_VISIBLE=
function gf_show_cursor {
    if [ "$GF_IS_CURSOR_VISIBLE" == "0" ]; then
        stty echo
        GF_IS_CURSOR_VISIBLE=1
    fi
}
function gf_hide_cursor {
    if [ "$GF_IS_CURSOR_VISIBLE" != "0" ]; then
        stty -echo
        GF_IS_CURSOR_VISIBLE=0
    fi
}

# Read user input including predefined keys
function gf_read {
    local gf_var=""
    local gf_num=0
    local gf_silent=0
    local gf_options=""
    local gf_prompt=""

    # Parse command line
    # GF_NEED_RESTART=
    local gf_need_mother=
    local gf_key=
    while [ $# -gt 0 ]; do
        gf_key="$1"; shift
        case "$gf_key" in
            "-v"|"-var" )
                gf_var="$1"
                shift
            ;;
            "-n"|"-num" )
                if [[ $1 =~ ^[1-9][0-9]*$ ]]; then
                    gf_num="$1";
                    gf_options+=" -n $1";
                elif [ -z "$1" ]; then
                    gf_fatal "Option ${GFH7}$gf_key${GFC0} value is empty."; return
                else
                    gf_fatal "Option ${GFH7}$gf_key${GFC0} value ${GFH1}$1${GFC0} should be a number."; return
                fi
                shift
            ;;
            "-t"|"-time" )
                if [[ $1 =~ ^[0-9]\.?[0-9]*$ ]]; then
                    gf_options+=" -t $1";
                elif [ -z "$1" ]; then
                    gf_fatal "Option ${GFH7}$gf_key${GFC0} value is empty."; return
                else
                    gf_fatal "Option ${GFH7}$gf_key${GFC0} value ${GFH1}$1${GFC0} should be a number."; return
                fi
                shift
            ;;
            "-p"|"-prompt" )
                gf_prompt="$(gf_escape_single_quotes "$1")"
                gf_options+=" -p '$1'";
                shift
            ;;
            "-s" )
                gf_silent=1
                gf_options+=" $gf_key";
            ;;
            -* )
                gf_fatal "Incorrect ${GFH7}$gf_key${GFC0} option."; return
            ;;
            * )
                if [ -z "$gf_var" ]; then
                    gf_var="$gf_key"
                else
                    gf_fatal "Incorrect ${GFH7}$gf_key${GFC0} option."; return
                fi
            ;;
        esac
    done

    if [ -z "$gf_var" ]; then
        gf_fatal "Option ${GFH7}-t${GFC0} value is empty."; return
    fi

    local gf_perl_script='
        my $predefined_keys = '"'$GF_PREDEFINED_CHOICES'"';
        my @predefined_keys = (split "", $predefined_keys);
        pop @predefined_keys if ($#predefined_keys >= 0);
        if ($#predefined_keys < 0) {
            print "read'"$gf_options $gf_var"'\n";
        } else {
            my $gf_num = "'"$gf_num"'";
            my $gf_var = "'"$gf_var"'";
            my $gf_prompt = '"'$gf_prompt'"';
            my $result = "";
            my $new_line = "";
            if ($gf_num < 1) {
                if ($#predefined_keys >= 0) {
                    my $char = "";
                    while (($char ne "\n") && ($#predefined_keys >= 0)) {
                        $result .= $char;
                        $char = (shift @predefined_keys);
                    }
                    $new_line = $char if ($char eq "\n");
                } else {
                    print "read'"$gf_options $gf_var"'\n";
                    exit
                }
            } elsif ($gf_num <= $#predefined_keys+1) {
                while ($gf_num > 0) {
                    my $key = (shift @predefined_keys);
                    $result .= $key;
                    $gf_num--;
                }
            } else {
                print "GF_PREDEFINED_CHOICES=\n";
                print "read'"$gf_options $gf_var"'\n";
                exit
            }
            $result =~ s/\'"'"'/\'"'"'\"\'"'"'\"\'"'"'/gm;
            print "$gf_var='"'"'$result'"'"'\n";
            $predefined_keys = join("", @predefined_keys);
            $predefined_keys =~ s/\'"'"'/\'"'"'\"\'"'"'\"\'"'"'/gm;
            if ($predefined_keys eq "") {
                print "GF_PREDEFINED_CHOICES=\n";
            } else {
                print "GF_PREDEFINED_CHOICES=\"\$(gf_escape_single_quotes '"'"'$predefined_keys='"'"')\"\n";
            }
            print "echo -n '"'"'$gf_prompt'"'"'\n" if ($gf_prompt ne "");
            print "echo -n '"'"'$result$new_line'"'"'\n" if (!"'$gf_silent'");
        }
    '
    eval "$(perl -e "$gf_perl_script")"
    gf_debug gf_perl_script GF_PREDEFINED_CHOICES 2> /dev/null
}

# Ask user to make choice
function gf_choose_bash {

    # Process arguments
    local gf_variable=
    local gf_toggles=
    local gf_keys=
    local gf_default=
    local gf_initial=
    local gf_default_variant=
    local gf_prompt="What is your choice? "
    local gf_header=
    local gf_footer=
    local gf_time=
    local gf_variants=
    local gf_count=10
    local key=
    local gf_keep=
    while [ $# -gt 0 ]; do
        key="$1"; shift
        case "$key" in
            "-var"|"-variable" )
                gf_variable="$1"; shift
            ;;
            "-default" )
                gf_default+="$(echo "$1" | tr /a-z/ /A-Z/)"; shift
            ;;
            "-initial" )
                gf_initial="$1"; shift
            ;;
            "-key"|"-keys" )
                gf_keys+="$(echo "$1" | tr /a-z/ /A-Z/)"; shift
            ;;
            "-variant"|"-variants" )
                gf_variants+="$1"$'\n'; shift
            ;;
            "-toggle"|"-toggles" )
                gf_toggles+="$(echo "$1" | tr /a-z/ /A-Z/)"; shift
            ;;
            "-prompt" )
                gf_prompt="$(echo "$1" | perl -e '
                    my $result = "";
                    while (<STDIN>) {
                        s/\s*$//;
                        $result .= $_." " if ($_ ne "");
                    }
                    print "$result\n";
                ')"
                shift
            ;;
            "-message"|"-header" )
                gf_header="$(echo "$1" | perl -e '
                    my $result = "";
                    while (<STDIN>) {
                        s/^\s+(\S)/  $1/;
                        $result .= $_;
                    }
                    $result =~ s/^\s*\n//g;
                    $result =~ s/\s+$//;
                    print "$result\n";
                ')"
                shift
            ;;
            "-footer" )
                gf_footer="$(echo "$1" | perl -e '
                    my $result = "";
                    $result .= $_ while (<STDIN>);
                    $result =~ s/^\s+(\S)/  $1/gm;
                    $result =~ s/^\s*\n//g;
                    $result =~ s/\s+$//;
                    print "$result\n";
                ')"
                shift
            ;;
            "-time"|"-timeout" )
                if [[ $1 =~ ^[0-9]+$ ]]; then
                    gf_time="$1"
                else
                    gf_fatal "Option ${GFH7}$key${GFC0} value ${GFH1}$1${GFC0} is not a number in seconds."; return
                fi
                shift
            ;;
            "-count" )
                if [[ $1 =~ ^[0-9]+$ ]]; then
                    gf_count="$1"
                else
                    gf_fatal "Option ${GFH7}$key${GFC0} value ${GFH1}$1${GFC0} is not a number of dsplayed variants."; return
                fi
                shift
            ;;
            "-keep" )
                gf_keep=1
            ;;
            * )
                gf_fatal "Incorrect ${GFH7}$key${GFC0} option."; return
            ;;
        esac
    done

    # Check variable name
    if [ -z "$gf_variable" ]; then
        gf_fatal "Argument ${GFH7}-variable${GFC0} cannot be empty."; return
    elif [ -z "$(echo "$gf_variable" | grep -ie '^[a-z0-9_]\+$' || :)" ]; then
        gf_fatal "Incorrect variable name ${GFH7}$gf_variable${GFC0} used."; return
    fi

    # Variants
    gf_variants="$(echo "$gf_variants" | grep -ve '^\s*$' || :)"
    local gf_filtered_variants="$gf_variants"
    local gf_variant_max="$(gf_count_lines "$gf_filtered_variants")"
    local gf_variant_index="$gf_variant_max"

    # Default value
    if [ -n "$gf_initial" ]; then
        local gf_initial_index=$(gf_count_lines "$(echo "$gf_filtered_variants" | grep -B 1000000 -Fx -- "$gf_initial" || :)")
        [[ $gf_initial_index -gt 0 ]] && gf_variant_index=$gf_initial_index
    fi

    # Check restricted option combinations
    if [ -n "$gf_toggles" -a -n "$gf_filtered_variants" ]; then
        gf_fatal "Options ${GFH7}-toggles${GFC0} and ${GFH7}-variants${GFC0} are mutually exclusive."; return
    elif [ -z "$gf_keys" -a -n "$gf_toggles" ]; then
        gf_fatal "Option ${GFH7}-toggles${GFC0} can be used with ${GFH7}-keys${GFC0} only."; return
    fi

    # Read value if required
    if [ -z "$(eval "echo \$$gf_variable")" -o -z "$gf_keep" ]; then

        # Add variants to the prompt
        local gf_message_with_variants=
        if [ -n "$gf_header" ]; then
            gf_message_with_variants="${GFM4} I ${GFC0} $gf_header"$'\n'
            if [ -n "$gf_filtered_variants" -a $gf_count -gt 0 ]; then
                [[ -z "$gf_header" ]] && gf_message_with_variants="${GFM4} I ${GFC0} Available variants:"$'\n'
                if [ $gf_count -lt $(gf_count_lines "$gf_filtered_variants") ]; then
                    local gf_count_more=$(gf_count_lines "$gf_filtered_variants")
                    gf_count_more=$((gf_count_more-$gf_count))
                    gf_message_with_variants+="  ... $gf_count_more more ..."$'\n'
                fi
                gf_message_with_variants+="${GFH4}$(echo "$gf_filtered_variants" | tail -$gf_count | sed -e 's/^\s*/  /' )${GFC0}"$'\n'
            fi
            [[ -n "$gf_footer" ]] && gf_message_with_variants+="$gf_footer"$'\n'
        else
            gf_prompt="${GFM4} I ${GFC0} $gf_prompt"
        fi

        # Show prompt
        gf_add_message "$(echo -e "$gf_message_with_variants$gf_prompt${GF_RAISE_WINDOW}")"

        # Print initial variants
        local gf_erase=
        local gf_selected_variant=
        if [ -n "$gf_variants" ]; then
            gf_selected_variant="$(echo "$gf_variants" | head -$gf_variant_index | tail -1)"
            echo -n "${GFH7}$gf_selected_variant${GFC0}" > /dev/tty
            gf_erase="$(echo "$gf_selected_variant" | sed -e 's/./\\b/g')"
        elif [ -n "$gf_keys" ]; then
            gf_selected_variant=
        else
            gf_fatal "At least one option ${GFH7}-keys${GFC0} or ${GFH7}-variants${GFC0} required."; return
        fi

        # Read user value
        local gf_modified=
        local gf_chosen_toggles=
        local gf_internal_choice=
        while [[ -z "$gf_internal_choice" || "$gf_keys" != *$gf_internal_choice* ]]; do

            # # Wait for user input
            if [ -n "$gf_time" ]; then
                gf_read -n 1 -t $gf_time -s gf_internal_choice || :
                gf_time=
            else
                gf_read -n 1 -s gf_internal_choice || :
            fi
            if [ "$gf_internal_choice" == $'\e' ]; then
                gf_read -n 2 -t 0.001 -s gf_internal_choice || :
                if [ "$gf_internal_choice" == "[1" ]; then
                    gf_read -n 2 -t 0.001 -s gf_internal_choice || :
                    if [ "$gf_internal_choice" == ";2" ]; then
                        gf_read -n 1 -t 0.001 -s gf_internal_choice || :
                        gf_internal_choice="[$gf_internal_choice"
                    fi
                fi
            else
                gf_internal_choice=$(echo "$gf_internal_choice" | tr /a-z/ /A-Z/)
            fi

            # Select variant or default value
            if [ -z "$gf_internal_choice" ]; then
                if [ -n "$gf_selected_variant" ]; then
                    gf_internal_choice="$gf_selected_variant"
                else
                    gf_internal_choice="$gf_default"
                fi
                [[ -n "$gf_internal_choice" ]] && break

            # Global toggle
            elif [[ "$gf_toggles" == *$gf_internal_choice* ]]; then

                # Erase last printed toggles
                echo -ne "$gf_erase\r${GFK}$gf_prompt${GFK}" > /dev/tty

                # Disable/enable toggles
                if [[ "$gf_chosen_toggles" = *$gf_internal_choice* ]]; then
                    gf_chosen_toggles="$(echo "$gf_chosen_toggles" | sed -e "s|$gf_internal_choice||g")"
                else
                    gf_chosen_toggles+="$gf_internal_choice"
                fi

                # Print enabled toggles
                echo -n "${GFH7}$gf_chosen_toggles${GFC0}" > /dev/tty
                gf_erase="$(echo "$gf_chosen_toggles" | sed -e 's/./\\b/g')"

            # Variants choice
            elif [ -n "$gf_variants" ]; then
                gf_modified=1

                # Same meeaning keys
                [[ "$gf_internal_choice" == ">" ]] && gf_internal_choice="[A"
                [[ "$gf_internal_choice" == "<" ]] && gf_internal_choice="[B"
                [[ "$gf_internal_choice" == "P" ]] && gf_internal_choice="[A"
                [[ "$gf_internal_choice" == "N" ]] && gf_internal_choice="[B"
                [[ "$gf_internal_choice" == "U" ]] && gf_internal_choice="[A"
                [[ "$gf_internal_choice" == "D" ]] && gf_internal_choice="[B"

                # Filtering mode
                if [ "$gf_internal_choice" == "/" ]; then

                    # Erase last printed toggles
                    echo -ne "$gf_erase\r${GFK}${GFM4} I ${GFC0} Filter: ${GFH7}${GFK}" > /dev/tty
                    local gf_filter
                    if [ "$GF_IS_CURSOR_VISIBLE" == "0" ]; then
                        gf_show_cursor; gf_read gf_filter; gf_hide_cursor
                    else
                        gf_read gf_filter
                    fi
                    gf_erase="$(echo "$gf_filter" | sed -e 's/./\\b/g')"
                    echo -ne "$gf_erase\b\r${GFC0}${GFK}" > /dev/tty
                    gf_erase=

                    # Disable/enable toggles
                    local gf_last_variants="$gf_filtered_variants"
                    gf_filtered_variants="$(gf_filter_lines "$gf_variants" "$gf_filter")"

                    # Use last variants
                    if [ -z "$gf_filtered_variants" -o "$gf_last_variants" == "$gf_filtered_variants" ]; then
                        gf_filtered_variants="$gf_last_variants"

                    # Update variants
                    else
                        gf_variant_max="$(gf_count_lines "$gf_filtered_variants")"
                        gf_variant_index="$gf_variant_max"
                        local gf_current_index=$(gf_count_lines "$(echo "$gf_filtered_variants" | grep -B 1000000 -Fx -- "$gf_selected_variant" || :)")
                        [[ $gf_current_index -gt 0 ]] && gf_variant_index=$gf_current_index

                        # Show variants
                        if [ -n "$gf_header" ]; then
                            echo -e "\r${GFK}\n${GFM4} I ${GFC0} Filter: ${GFH7}$(echo $gf_filter)${GFC0}" > /dev/tty
                            local gf_message_with_variants=
                            if [ -n "$gf_filtered_variants" -a $gf_count -gt 0 ]; then
                                if [ $gf_count -lt $(gf_count_lines "$gf_filtered_variants") ]; then
                                    local gf_count_more=$(gf_count_lines "$gf_filtered_variants")
                                    gf_count_more=$((gf_count_more-$gf_count))
                                    gf_message_with_variants+="  ... $gf_count_more more ..."$'\n'
                                fi
                                gf_message_with_variants+="${GFH4}$(echo "$gf_filtered_variants" | tail -$gf_count | sed -e 's/^\s*/  /' )${GFC0}"$'\n'
                            fi
                            [[ -n "$gf_footer" ]] && gf_message_with_variants+="$gf_footer"$'\n'
                            echo -ne "$gf_message_with_variants" > /dev/tty
                        fi
                    fi

                # Up key
                elif [ "$gf_internal_choice" == "[A" -a $gf_variant_index -gt 1 ]; then
                    gf_variant_index=$((gf_variant_index-1))

                # Down key
                elif [ "$gf_internal_choice" == "[B" -a $gf_variant_index -lt $gf_variant_max ]; then
                    gf_variant_index=$((gf_variant_index+1))

                # PgUp key
                elif [ "$gf_internal_choice" == "[5" -a $gf_variant_index -gt 1 ]; then
                    gf_variant_index=$((gf_variant_index-10))
                    [[ $gf_variant_index -lt 1 ]] && gf_variant_index=1

                # PgDn key
                elif [ "$gf_internal_choice" == "[6" -a $gf_variant_index -lt $gf_variant_max ]; then
                    gf_variant_index=$((gf_variant_index+10))
                    [[ $gf_variant_index -gt $gf_variant_max ]] && gf_variant_index=$gf_variant_max

                # Home key
                elif [ "$gf_internal_choice" == "[H" -a $gf_variant_index -gt 1 ]; then
                    gf_variant_index=1

                # Down key
                elif [ "$gf_internal_choice" == "[F" -a $gf_variant_index -lt $gf_variant_max ]; then
                    gf_variant_index=$gf_variant_max

                else
                    gf_modified=
                fi

                # Update current choice
                if [ -n "$gf_modified" ]; then
                    echo -ne "$gf_erase\r${GFK}$gf_prompt${GFK}" > /dev/tty
                    gf_selected_variant="$(echo "$gf_filtered_variants" | head -$gf_variant_index | tail -1)"
                    echo -n "${GFH7}$gf_selected_variant${GFC0}" > /dev/tty
                    gf_erase="$(echo "$gf_selected_variant" | sed -e 's/./\\b/g')"
                fi
            fi
        done

        # Display result
        gf_internal_choice="$gf_chosen_toggles$gf_internal_choice"
        echo -ne "$gf_erase\r${GFK}$gf_prompt${GFK}" > /dev/tty
        gf_add_message "$(echo -e "${GFH7}$gf_internal_choice${GFC0}")"$'\n'

        # Return value
        eval "$gf_variable=\"$gf_internal_choice\""
    fi
}

# Ask user for file, directory or task
function gf_choose_file_dir_task_bash {
    local key

    # Process arguments
    local gf_cursor="$GF_IS_CURSOR_VISIBLE"
    local gf_variable=
    local gf_keys=
    local gf_tasks=
    local gf_files=
    local gf_dirs=
    local gf_containing=
    local gf_prompt=
    local gf_count=
    local gf_allow_empty=
    local gf_keep=
    local gf_statuses='submitted|running|done'
    local gf_relative_dir="$GF_WORK_DIR"
    local gf_wait_cmd=
    local gf_task_to_file_pattern=
    # [[ -z "$gf_type" ]] && local gf_type="file or directory"
    local gf_last_key=; while [ $# -gt 0 ]; do
        if [[ "$1" != -* ]]; then key="$gf_last_key"; else key=; fi
        if [ -z "$key" ]; then key="$1"; shift; fi
        gf_last_key=; case "$key" in
            "-v"|"-var"|"-variable" )
                if [[ $1 =~ ^[a-zA-Z0-9_]+$ ]]; then
                    gf_variable="$1"
                else
                    gf_fatal "Argument ${GFCB}$key${GFC0} requires a variable name."; return
                fi
                shift
            ;;
            "-active" )
                gf_statuses='submitted|running'
            ;;
            "-wait" )
                gf_wait_cmd='gf_wait_task'
            ;;
            "-want" )
                gf_wait_cmd='gf_want_task'
            ;;
            "-t"|"-task"|"-tasks" )
                gf_tasks+="$1"$'\n'
                gf_last_key="$key"
                shift
            ;;
            "-task_to_file" )
                gf_task_to_file_pattern="$1"
                gf_last_key="-task"
                shift
            ;;
            "-f"|"-file"|"-files" )
                gf_files+="$1"$'\n'; shift
                gf_last_key="$key"
            ;;
            "-d"|"-dir"|"-dirs"|"-directories" )
                gf_dirs+="$1"$'\n'; shift
                gf_last_key="$key"
            ;;
            "-c"|"-cont"|"-containing" )
                gf_containing+="$1"$'\n'; shift
            ;;
            "-key"|"-keys" )
                gf_keys+="$(echo "$1" | tr /a-z/ /A-Z/)"; shift
            ;;
            "-prompt" )
                gf_prompt="$1"; shift
            ;;
            "-count" )
                if [[ $1 =~ ^[0-9][0-9]*$ ]]; then
                    gf_count="$1"
                else
                    gf_fatal "Argument ${GFCB}$key${GFC0} requires a number."; return
                fi
                shift
            ;;
            "-empty"|"-allow_empty" )
                gf_allow_empty=1
            ;;
            "-hide_variants" )
                gf_count=0
            ;;
            "-keep" )
                gf_keep=1
            ;;
            "-r"|"-rel"|"-relative"|"-relative_dir" )
                if [ -z "$1" ]; then
                    gf_fatal "Argument ${GFCB}$key${GFC0} requires existing directory."; return
                elif [ -d "$1" ]; then
                    gf_relative_dir="$1"
                else
                    gf_fatal "Relative directory ${GFCB}$1${GFC0} does not exist."; return
                fi
                shift
            ;;
            -* )
                gf_fatal "Incorrect option ${GFH7}$key${GFC0} used."; return
            ;;
            * )
                if [ -z "$gf_variable" ]; then
                    if [[ $key =~ ^[a-zA-Z0-9_]+$ ]]; then
                        gf_variable="$key"
                    else
                        gf_fatal "Argument ${GFCB}$key${GFC0} is not a variable name."; return
                    fi
                else
                    gf_options+="$key"$'\n'
                    # [[ "$gf_type" != "file" ]] && gf_dirs+="$key"$'\n'
                    # [[ "$gf_type" != "directory" ]] && gf_files+="$key"$'\n'
                fi
            ;;
        esac
    done

    # Check variable name
    if [ -z "$gf_variable" ]; then
        gf_fatal "Argument ${GFH7}-variable${GFC0} cannot be empty."; return
    fi
    if [ -z "$(echo "$gf_variable" | grep -ie '^[a-z0-9_]\+$' || :)" ]; then
        gf_fatal "Incorrect variable name ${GFH7}$gf_variable${GFC0} used."; return
    fi

    # Check variants count variable
    if [ -z "$gf_count" ]; then
        gf_count=10
    fi
    if [ -z "$(echo "$gf_count" | grep -ie '^[0-9]\+$' || :)" ]; then
        gf_fatal "Incorrect -variants count ${GFH7}$gf_count${GFC0} value."; return
    fi

    # Fix relative dir
    [[ ! -e "$gf_relative_dir" ]] && gf_relative_dir=.

    # Update variable if not defined
    local current_value="$(eval "echo \$$gf_variable")"
    if [ -z "$current_value" -o -z "$gf_keep" ]; then

        # Available files and directories
        local gf_variants=
        local gf_internal_result=

        # Get list of task directories
        local gf_dir_variants=
        if [ -n "$gf_tasks" ]; then
            gf_dir_variants+="$(
                cd "$gf_relative_dir"
                echo "$gf_tasks" | while read pattern; do
                    if [ -n "$pattern" ]; then
                        ls -dtr1 $pattern/ 2> /dev/null | while read dir; do
                            if [ -z "$gf_containing" ]; then
                                echo "$dir"
                            else
                                echo "$gf_containing" | while read containing; do
                                    if [ -n "$containing" ]; then
                                        if [ -n "$(ls -d1 "$dir"$containing 2> /dev/null)" ]; then
                                            echo "$dir"
                                            break
                                        fi
                                    fi
                                done
                            fi
                        done
                    fi
                done
            )"

            # Filter out failed and non-existing tasks
            local gf_internal_result=
            gf_debug gf_dir_variants
            gf_variants+="$(echo "$gf_dir_variants" | sort -u | while read task; do
                local gf_run_dir="$(dirname "$task")"
                local gf_full_dir="$(gf_full_path_rel "$gf_relative_dir" "$gf_run_dir")"
                if [ -e "$gf_full_dir/run.info" ]; then

                    # Filter tasks by pattern
                    local gf_perl_script="$gf_parse_run_info_script"'
                        my @variants; my %variants;
                        foreach my $task (@tasks) {
                            my $base = $tasks{$task}{base};
                            if ($base =~ /^'"$(basename "$task")"'$/) {
                                if ($tasks{$task}{status} =~ /^('"$gf_statuses"')$/) {
                                    push @variants, $task if (!$variants{$task}); $variants{$task} = 1;
                                }
                                # push @variants, $base if (!$variants{$base}); $variants{$base} = 1;
                            }
                        }
                        print "local gf_found_tasks=\"".join("\n", @variants)."\"\n";
                    '
                    eval "$(cat "$gf_full_dir/run.info" | perl -e "$gf_perl_script")"

                    # Check for candidates
                    local gf_task=
                    for gf_task in $gf_found_tasks; do
                        echo "$gf_run_dir/$gf_task"
                    done
                fi
            done)"$'\n'
            gf_debug gf_variants
        fi

        # Choose files
        if [ -n "$gf_files" ]; then
            gf_variants+="$(
                cd "$gf_relative_dir"
                ls -dtr1 $gf_files 2> /dev/null | while read file; do
                    if [ -f "$file" ]; then
                        echo "$file"
                    fi
                done | awk '!x[$0]++'
            )"
            gf_debug gf_variants
        fi

        # Choose directories
        if [ -n "$gf_dirs" ]; then
            gf_variants+="$(
                cd "$gf_relative_dir"
                echo "$gf_dirs" | while read pattern; do
                    if [ -n "$pattern" ]; then
                        ls -dtr1 $pattern/ 2> /dev/null | while read dir; do
                            if [ -z "$gf_containing" ]; then
                                echo "$dir"
                            else
                                echo "$gf_containing" | while read containing; do
                                    if [ -n "$containing" ]; then
                                        if [ -n "$(ls -d1 "$dir"$containing 2> /dev/null)" ]; then
                                            echo "$dir"
                                            break
                                        fi
                                    fi
                                done
                            fi
                        done
                    fi
                done
            )"
            gf_debug gf_variants
        fi

        # Allow printing entered characters
        [[ "$gf_cursor" == "0" ]] && gf_show_cursor

        # Select object in interactive mode
        if [ -n "$gf_variants" ]; then

            # Sort and remove duplicates
            gf_variants="$(cd "$gf_relative_dir"; ls -dtr1 $gf_variants 2> /dev/null | sed -e 's|/$||' | awk '!x[$0]++')"

            if [ -z "$gf_prompt" ]; then
                # local gf_local_prompt="Please ${GFC7}choose${GFC0} $gf_type:"
                local gf_local_prompt="Please ${GFC7}choose${GFC0}:"
            else
                local gf_local_prompt="$gf_prompt"
            fi
            if [ "$gf_allow_empty" == "1" ]; then
                gf_variants+=$'\n'"-"$'\n'
            fi
            gf_choose_bash -variable gf_internal_result -keys "E$gf_keys" -variants "$gf_variants" -message "$gf_local_prompt" -footer "${GFH2}[Up] [Down]${GFC0} choose ${GFH2}[/]${GFC0} filter ${GFH3}[E]${GFC0} enter manually"
        fi

        # Enter value manually
        if [ -z "$gf_internal_result" -o "$gf_internal_result" == "E" ]; then
            if [ -n "$gf_variants" ]; then
                gf_add_message "$(echo -e "${GFM4} I ${GFC0} Enter manually: ${GFH7}")"
            else
                if [ -z "$gf_prompt" ]; then
                    gf_add_message "$(echo -e "${GFM4} I ${GFC0} Please ${GFC7}enter${GFC0} $gf_type: ${GFH7}")"
                else
                    gf_add_message "$(echo -e "${GFM4} I ${GFC0} $gf_prompt ${GFH7}")"
                fi
            fi
            gf_read gf_internal_result
        elif [ "$gf_internal_result" == "-" ]; then
            gf_internal_result=
        fi
        gf_add_message "${GFC0}"

        # Do not print entered characters
        [[ "$gf_cursor" == "0" ]] && gf_hide_cursor

        # Update result variable
        gf_debug gf_internal_result
        if [ -z "$gf_keys" ]; then
            gf_internal_result="$(gf_full_path_rel "$gf_relative_dir" "$gf_internal_result")"
        elif [ -z "$(echo "$gf_internal_result" | grep -ie "^[$gf_keys]$" || :)" ]; then
            gf_internal_result="$(gf_full_path_rel "$gf_relative_dir" "$gf_internal_result")"
        fi
        gf_debug gf_internal_result

        # Chosen variables
        GF_CHOSEN_VARS+="$gf_variable=$gf_internal_result"$'\n'
        
        # Task chosen
        if [ -e "$gf_internal_result/run" ]; then

            # Wait/want for active task
            if [ -n "$gf_wait_cmd" ]; then
                $gf_wait_cmd -exact "$gf_internal_result"
            fi

            # Transform task to file based on the pattern
            if [ -n "$gf_task_to_file_pattern" ]; then
                gf_internal_result="$(echo "$gf_internal_result"$'\n'"$gf_task_to_file_pattern" | perl -e "$gf_task_to_file_pattern_perl")"
            fi
        fi

        # Set internal variable
        eval "$gf_variable='$gf_internal_result'"
    
    # Wait/want for active task chosen earlier
    elif [ -n "$gf_keep" ]; then
    
        # Interactively chosen earlier task
        local last_value="$(echo "$GF_CHOSEN_VARS" | sed -ne "s|^$gf_variable=||p" | tail -1)"
        if [ -n "$last_value" -a -n "$gf_wait_cmd" -a -e "$last_value/run" ]; then
            $gf_wait_cmd -exact "$last_value"
        
        # User-specified path to the task
        elif [ -z "$last_value" -a -n "$current_value" -a -e "$current_value/run" -a -n "$gf_task_to_file_pattern" ]; then
            GF_CHOSEN_VARS+="$gf_variable=$current_value"$'\n'
            $gf_wait_cmd -exact "$current_value"

            # Set internal variable
            eval "$gf_variable='$(echo "$current_value"$'\n'"$gf_task_to_file_pattern" | perl -e "$gf_task_to_file_pattern_perl")'"
        fi
    fi
    GF_IS_SPACE=0
}

# Ask user for tool binary
function gf_choose_tool_binary_bash {
    local key

    # Process arguments
    local gf_variable=
    local gf_tool=
    local gf_dirs=

    local gf_last_key=; while [ $# -gt 0 ]; do
        if [[ "$1" != -* ]]; then key="$gf_last_key"; else key=; fi
        if [ -z "$key" ]; then key="$1"; shift; fi
        gf_last_key=; case "$key" in
            "-v"|"-var"|"-variable" )
                if [[ $1 =~ ^[a-zA-Z0-9_]+$ ]]; then
                    gf_variable="$1"
                else
                    gf_fatal "Argument ${GFCB}$key${GFC0} requires a variable name."; return
                fi
                shift
            ;;
            "-t"|"-tool" )
                if [ -z "$1" ]; then
                    gf_fatal "Argument ${GFCB}$key${GFC0} requires tool name."; return
                else
                    gf_tool="$(basename "$1")"
                fi
                shift
            ;;
            "-d"|"-dir"|"-dirs"|"-directories" )
                gf_dirs+="$1"$'\n'; shift
                gf_last_key="$key"
            ;;
            -* )
                gf_fatal "Incorrect option ${GFH7}$key${GFC0} used."; return
            ;;
            * )
                if [ -z "$gf_variable" ]; then
                    if [[ $key =~ ^[a-zA-Z0-9_]+$ ]]; then
                        gf_variable="$key"
                    else
                        gf_fatal "Argument ${GFCB}$key${GFC0} is not a variable name."; return
                    fi
                elif [ -z "$gf_tool" ]; then
                    gf_tool="$(basename "$key")"
                else
                    gf_dirs+="$key"$'\n'
                fi
            ;;
        esac
    done

    # Check variable name
    if [ -z "$gf_variable" ]; then
        gf_fatal "Argument ${GFH7}-variable${GFC0} cannot be empty."; return
    fi
    if [ -z "$(echo "$gf_variable" | grep -ie '^[a-z0-9_]\+$' || :)" ]; then
        gf_fatal "Incorrect variable name ${GFH7}$gf_variable${GFC0} used."; return
    fi

    # Check tool name
    if [ -z "$gf_tool" ]; then
        gf_fatal "Argument ${GFH7}-tool${GFC0} cannot be empty."; return
    fi

    # Ask for tool version
    local gf_internal_result=

    # Check path environment
    gf_internal_result="$(which $gf_tool 2> /dev/null)"
    if [ -z "$gf_dirs" ]; then
        [[ -z "$gf_internal_result" ]] && gf_internal_result="$(which cds_root 2> /dev/null)"
        if [ -n "$gf_internal_result" ]; then
            if [[ "$(basename "$(readlink -m "$gf_internal_result/../..")")" == tools* ]]; then
                gf_dirs+="$(readlink -m "$gf_internal_result/../../../../..")"$'\n'
            elif [ "$(basename "$(readlink -m "$gf_internal_result/..")")" == bin ]; then
                gf_dirs+="$(readlink -m "$gf_internal_result/../../../..")"$'\n'
            fi
        fi
    fi

    # Scan directories for files
    gf_dirs="$(echo "$gf_dirs" | awk '!x[$0]++')"
    if [ -n "$gf_dirs" ]; then
        local variants=
        local root_dir=
        local gf_test=
        for root_dir in $gf_dirs; do
            [[ "$root_dir" == "/" ]] && root_dir=
            gf_set_progress "Checking $root_dir/bin/$gf_tool binaries ..."
            gf_test="$(2> /dev/null ls -1d "$root_dir"/bin/$gf_tool || :)"
            [[ -n "$gf_test" ]] && variants+="$gf_test"$'\n'
            gf_set_progress "Checking $root_dir/*/bin/$gf_tool binaries ..."
            gf_test="$(2> /dev/null ls -1d "$root_dir"/*/bin/$gf_tool || :)"
            [[ -n "$gf_test" ]] && variants+="$gf_test"$'\n'
        done
        if [ -z "$variants" ]; then
            for root_dir in $gf_dirs; do
                [[ "$root_dir" == "/" ]] && root_dir=
                gf_set_progress "Checking $root_dir/*/*/bin/$gf_tool binaries ..."
                gf_test="$(2> /dev/null ls -1d "$root_dir"/*/*/bin/$gf_tool || :)"
                [[ -n "$gf_test" ]] && variants+="$gf_test"$'\n'
            done
        fi
        if [ -z "$variants" ]; then
            for root_dir in $gf_dirs; do
                [[ "$root_dir" == "/" ]] && root_dir=
                gf_set_progress "Checking $root_dir/*/*/*/bin/$gf_tool binaries ..."
                gf_test="$(2> /dev/null ls -1d "$root_dir"/*/*/*/bin/$gf_tool || :)"
                [[ -n "$gf_test" ]] && variants+="$gf_test"$'\n'
            done
        fi
        gf_reset_progress

        # Choose tool binary
        variants="$(echo "$variants" | awk '!x[$0]++')"
        if [ -n "$variants" ]; then
            # gf_choose -var gf_internal_result -header "Please select ${GFH6}$gf_tool${GFC0} binary:" -footer "${GFH2}[Up] [Down]${GFC0} choose ${GFH3}[/]${GFC0} filter" -variants "$variants"
            gf_choose_file -var gf_internal_result -prompt "Please select ${GFH6}$gf_tool${GFC0} binary:" -files "$variants"
        else
            gf_internal_result=
        fi
    fi

    [[ -z "$gf_internal_result" ]] && gf_error "No ${GFCB}$gf_tool${GFC0} binary found."
    eval "$gf_variable='$gf_internal_result'"
}

# Temporary message
function gf_set_progress {
    echo "$1" | perl -e '
        while (<STDIN>) {
            s/\s+$//;
            s/^([^\s\\\e])/  $1/;
            my $erase = $_;
            s/[\e\\e](\[[0-9\;]+m)/\e$1/g;
            $erase =~ s/[\e\\e](\[[0-9\;]+m)//g;
            $erase =~ s/./\b/g;
            print "'${GFK}'".$_.$erase if ($_);
        }
    ' > /dev/tty
}

# Clear temporary message
function gf_reset_progress {
    echo -n $GFK > /dev/tty
}

# Window title
function gf_set_window_title {
    if [ -n "$1" ]; then
        if [ -z "$2" ]; then
            echo -ne "\e]1;$1\a"
        else
            echo -ne "\e]1;$2\a"
        fi
        echo -ne "\e]2;$1\a"
    fi
}

# Add empty line once
GF_IS_SPACE=0
function gf_spacer {
    if [ $GF_IS_SPACE == 0 ]; then
        GF_IS_SPACE=1
        >&2 echo
    fi
}

##################################################
# Source mode functions
##################################################

# Debug function to be defined in debug mode
function gf_debug { return 0; }

# Generic flow binary is bash source script in execute mode
if [ "$BASH_SOURCE" != "$GF_BIN_FILE" ]; then

    # Full path to binary
    GF_BIN="$(gf_full_path "$BASH_SOURCE")"

    # Generic flow root directory
    GF_ROOT="$(gf_full_path "$GF_BIN/../..")"

    # Parse graphic command line arguments
    for gf_arg in "$@"; do
        case "$gf_arg" in
            "-fatal_exit" )
                export GF_FATAL_EXIT=1
            ;;
        esac
    done

    ##################################################
    # Main message functions
    ##################################################

    function gf_add_message {
        echo -n "$1"
    }

    # Write out text
    function gf_echo {
        >&2 echo "$@"
        GF_IS_SPACE=0
    }

    GF_MESSAGES=
    function gf_message {
        local mark="77 "
        local message="$2"

        # <MARK> MESSAGE SUMMARY
        if [ -n "$3" ]; then
            mark="$1 "
            GF_MESSAGES+="$mark $3"$'\n'
        elif [ -n "$2" ]; then
            mark="$1 "
        elif [ -n "$1" ]; then
            message="$1"
        else
            gf_spacer
            mark="66 "
            message="Usage: gf_message [<style>] <text> [<category>]\n\n  <category> is a text to report messages in gf_message_summary\n  <style> is a 3-symbol string:\n    1. foreground color (1=red, 2=green, 3=yellow, 4=blue, 5=magenta, 6=cyan, 7=white)\n    2. backgroud color (1=red, 2=green, 3=yellow, 4=blue, 5=magenta, 6=cyan, 7=white)\n    3. displayed symbol\n\n  Example:\n    gf_message \"31I\" \"This is a text with yellow on red mark\"\n    gf_message \"22 \" \"This is a text\" \"green marks\"\n    gf_message_summary\n"
        fi

        gf_echo -e "\e[9${mark:0:1};4${mark:1:1}m${mark:2:1}${GFC0} $message"
    }

    # Print summary of all messages in the session
    function gf_message_summary {
        if [ -n "$GF_MESSAGES" ]; then
            gf_spacer
            if [ -n "$1" ]; then
                gf_message "66 " "$1"
                gf_spacer
            fi
            echo "$GF_MESSAGES" | >&2 perl -e '
                my %count;
                my @types;
                while (<STDIN>) {
                    push @types, $_ if (!defined $count{$_});
                    $count{$_}++;
                }
                foreach (@types) {
                    if (/^(.)(.)(.)\s+(.*)$/) {
                        print "\e[9${1};4${2}m${3}'${GFC0}' ".$count{$_}." $4\n";
                    }
                }
            '
            GF_IS_SPACE=0
            gf_spacer
        fi
    }

    ##################################################
    # Other message functions
    ##################################################

    function gf_echo_spaced {
        gf_spacer
        >&2 echo "$@"
        gf_spacer
    }

    function gf_message_spaced {
        gf_spacer
        gf_message "$1" "$2" "$3"
        gf_spacer
    }

    function gf_error {
        gf_message "11 " "$1" "$2"
    }

    function gf_fatal {
        gf_spacer
        gf_error "$1"
        gf_spacer
        GF_YES_WAIT_KEY=1
        GF_WAIT_KEY=
        [[ -n "$GF_FATAL_EXIT" ]] && exit $GF_FATAL_EXIT
    }

    function gf_warning {
        gf_message "33 " "$1" "$2"
    }

    function gf_info {
        gf_message "77 " "$1" "$2"
    }

    function gf_operation {
        gf_message "66 " "$1" "$2"
    }

    function gf_result {
        gf_message "44 " "$1" "$2"
    }

    ##################################################
    # Interactive functions
    ##################################################

    # Ask user to make choice
    function gf_choose { gf_choose_bash "$@"; }

    # Ask user to make choice
    function gf_choose_file_dir_task { gf_choose_file_dir_task_bash "$@"; }
    function gf_choose_tool_binary { gf_choose_tool_binary_bash "$@"; }

    # Ask user to make choice
    function gf_help {
        if [ -z "$@" ]; then
            gf_error "Usage: gf_help <command_or_filter>"
        else
            gflow -help "$@"
        fi
    }

    return 0
fi

##################################################
# Messaging functions
##################################################

# Add help section
function gf_help_section {
    GF_TOOL_USAGE+="gf_help_section=>$@"$'\n'
}

# Add command description
function gf_help_command {
    GF_TOOL_USAGE+="gf_help_command=>$@"$'\n'
}

# Title save and restore
function gf_save_title {
    echo -ne "\e[22;0t"
}
function gf_restore_title {
    echo -ne "\e[23;0t"
}

# Log output to file
GF_OUTPUT_LOGGING=
function gf_disable_logging {
    if [ -n "$GF_OUTPUT_LOGGING" ]; then
        exec 1>&3 2>&4
        GF_OUTPUT_LOGGING=
    fi
}
function gf_enable_logging {
    gf_disable_logging
    exec 3>&1 4>&2 1> >(trap '' SIGINT; tee -a "$1") 2>&1
    GF_OUTPUT_LOGGING="$1"
}

# Wait for Q press to close
function gf_wait_before_close {
    gf_disable_logging
    trap -- EXIT
    trap -- SIGINT
    trap -- SIGQUIT
    trap -- SIGTERM
    trap -- SIGHUP
    gf_debug GF_NO_WAIT_KEY GF_NO_WIN GF_WAIT_KEY GF_PREPARE_PHASE
    if [ -n "$DISPLAY" -a -z "$GF_NO_WIN" ]; then
        if [ -n "$GF_YES_WAIT_KEY" -o -z "$GF_NO_WAIT_KEY$GF_WAIT_KEY" ]; then
            GF_YES_WAIT_KEY=
            GF_NO_WAIT_KEY=1
            GF_WAIT_KEY=
            sleep 0.25
            echo -e "\nAll done in this session. Press ${GFH4}[Q]${GFC0} to finish$GF_RAISE_WINDOW"
            while [ -z "$(echo $GF_WAIT_KEY | grep -i 'Q')" ]; do
                read -n 1 -s WAIT_KEY_NEW
                if [ -z "$GF_WAIT_KEY" ]; then
                    GF_WAIT_KEY=$WAIT_KEY_NEW
                else
                    GF_WAIT_KEY=Q
                fi
            done
        fi
    fi
    gf_restore_title
    gf_show_cursor
    echo
    sleep 0.25
}

# Set traps
function gf_set_termination_traps {
    local stage="$1"
    local short="$2"
    local full="$3"

    local gf_term_trap='
        echo -e "\e]1;X - '"$short"'\a\e]2;Terminated - '"$full"'\a"
        echo -e "'${GFM3}' W '${GFC0}' '"$stage"' terminated by external signal'${GFC0}'"
        GF_NO_WAIT_KEY=1
        sleep 0.25
        exit 2
    '
    trap "$gf_term_trap" SIGQUIT SIGTERM SIGHUP

    gf_int_trap='
        echo -e "\e]1;X - '"$short"'\a\e]2;Interrupted - '"$full"'\a"
        echo -e "'${GFM3}' W '${GFC0}' '"$stage"' interrupted by user'${GFC0}'"
        GF_NO_WAIT_KEY=
        exit 2
    '
    trap "$gf_int_trap" SIGINT

    # gf_debug gf_term_trap gf_int_trap
}

# Add message to variable
function gf_add_message {
    echo -n "$1"
    GF_MESSAGES+="$1"
}

# Info message
function gf_info {
    echo -e "\e[90;40m I ${GFC0} $GF_FUNC_NAME${GFC0} - $@"
}
function gf_info_message {
    local message="$(echo -e "\e[90;40m I ${GFC0} $GF_FUNC_NAME${GFC0} - $@")"
    echo "$message"
    GF_MESSAGES+="$message"$'\n'
}

# Warning message
function gf_warning {
    echo -e "${GFM3} W ${GFC0} $GF_FUNC_NAME${GFC0} - $@"
}
function gf_warning_message {
    local message="$(echo -e "${GFM3} W \e[0;33m $GF_FUNC_NAME${GFC0} - $@")"
    echo "$message"
    GF_MESSAGES+="$message"$'\n'
}

# Error message
GF_ERRORS_OCCURED=
function gf_error {
    GF_ERRORS_OCCURED=1
    echo -e "${GFM1} E ${GFC0} $GF_FUNC_NAME${GFC0} - $@"
}
function gf_error_message {
    GF_ERRORS_OCCURED=1
    local message="$(echo -e "${GFM1} E \e[0;31m $GF_FUNC_NAME${GFC0} - $@")"
    echo "$message"
    GF_MESSAGES+="$message"$'\n'
}

# Error message and exit
function gf_fatal {
    GF_YES_WAIT_KEY=1
    echo -ne "\e]1;X - $GF_RUN_NAME - $GF_WORK_DIR\a\e]2;Fatal - $GF_RUN_NAME - $GF_WORK_DIR\a"
    echo -e "${GFM1} E ${GFC0} $GF_FUNC_NAME${GFC0} - $@"
    exit 1
}

# Update/revert current function
function gf_update_function {
    echo 'local gf_parent_func_name="$GF_FUNC_NAME";'
    echo 'GF_FUNC_NAME="${FUNCNAME[0]}";'
    for synonym in $@; do
        if [ "$synonym" == "${FUNCNAME[2]}" ]; then
            echo "GF_FUNC_NAME='$synonym';"
        fi
    done
}
function gf_revert_function {
    echo 'GF_FUNC_NAME="$gf_parent_func_name"'
}

# Get path relative to gflow
gf_get_short_path_replaces=""
function gf_get_short_path {
    local gf_perl_script='
        my %replaces;
        my @replaces;
        my $file = "";
        while (<STDIN>) {
            s/^\s+//;
            s/\s+$//;
            if (s/^=//) {
                $file = $_;
            } elsif (m|^([^=]+)=(.+)|) {
                if ($2 ne "/") {
                    push @replaces, $1;
                    $replaces{$1} = $2;
                }
            }
        }
        foreach my $replace (@replaces) {
            $file =~ s|^$replaces{$replace}/|$replace/|;
        }
        $file =~ s|/$||;
        print "$file\n";
    '
    echo "
        =$(gf_full_path "$1")/
        $gf_get_short_path_replaces
    " | perl -e "$gf_perl_script"
}

# Update paths replace expressions
function gf_update_path_replaces {
    gf_get_short_path_replaces="
        \$GF_RUN_DIR=$GF_I_RUN_DIR
        \$GF_RUN_DIR=$GF_RUN_DIR
        \$GF_RUN_DIR=$(gf_full_path "$GF_I_RUN_DIR")
        \$GF_RUN_DIR=$(gf_full_path "$GF_RUN_DIR")

        .=$PWD
        .=$(gf_full_path "$PWD")

        \$GF_SCRIPT_DIR=$GF_SCRIPT_DIR
        \$GF_SCRIPT_DIR=$(gf_full_path "$GF_SCRIPT_DIR")

        \$GF_WORK_DIR=$GF_I_WORK_DIR
        \$GF_WORK_DIR=$GF_WORK_DIR
        \$GF_WORK_DIR=$(gf_full_path "$GF_I_WORK_DIR")
        \$GF_WORK_DIR=$(gf_full_path "$GF_WORK_DIR")

        ..=$(gf_full_path "$PWD/..")
        \$GF_SCRIPT_DIR/..=$(gf_full_path "$GF_SCRIPT_DIR/..")
        \$GF_WORK_DIR/..=$(gf_full_path "$GF_I_WORK_DIR/..")
        \$GF_WORK_DIR/..=$(gf_full_path "$GF_WORK_DIR/..")

        ../..=$(gf_full_path "$PWD/../..")
        \$GF_SCRIPT_DIR/../..=$(gf_full_path "$GF_SCRIPT_DIR/../..")
        \$GF_WORK_DIR/../..=$(gf_full_path "$GF_I_WORK_DIR/../..")
        \$GF_WORK_DIR/../..=$(gf_full_path "$GF_WORK_DIR/../..")

        ../../..=$(gf_full_path "$PWD/../../..")
        \$GF_SCRIPT_DIR/../../..=$(gf_full_path "$GF_SCRIPT_DIR/../../..")
        \$GF_WORK_DIR/../../..=$(gf_full_path "$GF_I_WORK_DIR/../../..")
        \$GF_WORK_DIR/../../..=$(gf_full_path "$GF_WORK_DIR/../../..")

        ../../../..=$(gf_full_path "$PWD/../../../..")
        \$GF_SCRIPT_DIR/../../../..=$(gf_full_path "$GF_SCRIPT_DIR/../../../..")

        ../../../../..=$(gf_full_path "$PWD/../../../../..")
        \$GF_SCRIPT_DIR/../../../../..=$(gf_full_path "$GF_SCRIPT_DIR/../../../../..")

        \$GF_ROOT=$GF_ROOT
    "
    # gf_debug gf_get_short_path_replaces
}

##################################################
# Run info internal functions
##################################################

# Perl commands to read run.info
gf_parse_run_info_script='

    # Task statuses: submitted running interrupted failed done
    # Session statuses: generate ready started interrupted terminated finished

    # Run info structure fields
    my @task_fields = ("type", "task", "session", "base", "status", "pid", "host", "user", "time");
    my @session_fields = ("type","session", "status", "pid", "host", "user", "time");

    # Fields indexes
    my %task_fields_index; for (my $i=0; $i <= $#task_fields; $i++) {$task_fields_index{$task_fields[$i]} = $i}
    my %session_fields_index; for (my $i=0; $i <= $#session_fields; $i++) {$session_fields_index{$session_fields[$i]} = $i}

    # Store run info in %tasks/%sessions
    my %tasks; my @tasks;
    my %bases; my @bases;
    my %sessions; my %sessions;
    my $session = 0;
    while (<STDIN>) {
        my @record = split /\s+/, $_;
        if ($record[0] eq "session") {
            if ($#record == $#session_fields) {
                $session = $record[1];
                push @sessions, $session if (!defined $sessions{$session});
                my $i = 0; $sessions{$session}{$_} = $record[$i++] foreach (@session_fields);
            }
        } elsif ($record[0] eq "task") {
            if ($#record == $#task_fields) {
                my $task = $record[1];
                my $base = $record[3];
                push @tasks, $task if (!defined $tasks{$task});
                push @bases, $base if (!defined $bases{$base});
                my $i = 0; foreach (@task_fields) {
                    $tasks{$task}{$_} = $record[$i];
                    $bases{$base}{$_} = $record[$i];
                    $sessions{$record[2]}{tasks}{$task}{$_} = $record[$i];
                    $i++;
                }
            }
        }
    }
'

# Perl commands to parse current session task statuses
gf_parse_task_statuses_script='
    my @task_fields = ("task", "base", "status");

    # Store statuses in %tasks
    my %tasks; my @tasks;
    my %bases; my @bases;
    while (<STDIN>) {
        my @record = split /\s+/, $_;
        if ($#record == $#task_fields) {
            my $task = $record[0];
            my $base = $record[1];
            push @tasks, $task if (!defined $tasks{$task});
            push @bases, $base if (!defined $bases{$base});
            my $i = 0; foreach (@task_fields) {
                $tasks{$task}{$_} = $record[$i];
                $bases{$base}{$_} = $record[$i];
                $i++;
            }
        }
    }
'

# Perl commands to parse chosen tasks structure
gf_parse_chosen_tasks_script='
    my @task_fields = ("task", "base", "run");

    # Store statuses in %tasks
    my %chosen_tasks; my @chosen_tasks;
    my %chosen_bases;
    while (<STDIN>) {
        if (/^(\S+) (\S+) (.+)$/) {
            my $task = $1;
            my $base = $2;
            my $run = $3;
            my @record = ($task, $base, $run);
            push @chosen_tasks, \%{$chosen_tasks{$run}{$task}};
            my $i = 0; foreach (@task_fields) {
                $chosen_tasks{$run}{$task}{$_} = $record[$i];
                $chosen_bases{$run}{$base}{$_} = $record[$i];
                $i++;
            }
        }
    }
'

# Select specific task from selected candidates
function gf_choose_task_candidate {
    local gf_task_name_variable="$1"
    local gf_task_status_variable="$2"
    local gf_task_basename="$3"
    local gf_run_info_file="$(gf_full_path "$4")"
    local gf_candidate_type="$5"; [[ -z "$gf_candidate_type" ]] && gf_candidate_type="task"

    # Variables to store local values
    local gf_task_name=

    # Check if choice already made
    local gf_perl_script="$gf_parse_chosen_tasks_script"'
        my $run = "'"$gf_run_info_file"'";
        my $base = "'"$gf_task_basename"'";
        my $task = $chosen_bases{$run}{$base}{task};
        $task = $chosen_tasks{$run}{$base}{task} if ($task eq "");
        print "gf_task_name=$task\n";
    '
    eval "$(echo "$GF_CHOSEN_TASKS" | perl -e "$gf_perl_script")"
    # gf_debug gf_perl_script
    gf_debug GF_CHOSEN_TASKS gf_task_name

    # Already chosen
    if [ -n "$gf_task_name" ]; then
        eval "$gf_task_name_variable=\"$gf_task_name\""
        eval "$gf_task_status_variable=\"chosen\""
        gf_debug $gf_task_name_variable $gf_task_status_variable

    # Check run.info file
    else

        # Update task variants from run.info file
        local gf_perl_script="$gf_parse_run_info_script"'
            my %variants; my @variants;
            foreach my $task (@tasks) {
                if ($tasks{$task}{base} eq "'"$gf_task_basename"'") {
                    if ($tasks{$task}{status} =~ /^(submitted|running|done)$/) {
                        push @variants, $task if (!$variants{$task}); $variants{$task} = 1;
                    }
                }
            }
            print "local gf_task_variants=\"".join("\n", @variants)."\"\n";
        '
        eval "$(cat "$gf_run_info_file" | perl -e "$gf_perl_script")"
        # gf_debug gf_perl_script
        gf_debug gf_run_info_file gf_task_variants

        # Select from several tasks
        if [ $(gf_count_words $gf_task_variants) -gt 1 ]; then
            gf_choose -variable gf_task_name -variants "$gf_task_variants" -count 10 \
                -message "Press ${GFH2}[Up]${GFC0} or ${GFH2}[Down]${GFC0} to choose ${GFC7}$gf_candidate_type${GFC0} candidate$gf_dir_info:"

        # Use exact task name
        elif [ -n "$gf_task_variants" ]; then
            gf_task_name=$(echo $gf_task_variants)
        fi

        # Directory information
        local gf_perl_script='
            my $checked = "";
            my $current = "";
            while (<STDIN>) {
                s|/[^/]+/[^/]+\s*$||;
                s|\'"'"'|\\'"'"'|g;
                if ($checked eq "") {
                    $checked = $_;
                } else {
                    $current = $_;
                }
            }
            if ($current eq $checked) {
                print "local gf_dir_info=\n";
            } elsif ($checked =~ m|^(.+)/([^/]+)$|) {
                my $dir = $1;
                my $run = $2;
                $current =~ s|/[^/]+$||;
                if ($dir eq $current) {
                    print "local gf_dir_info='"'"' of run '${GFC7}'$run'${GFC0}''"'"' run\n";
                } else {
                    print "local gf_dir_info='"'"' of '${GFC7}'$checked'${GFC0}''"'"' run\n";
                }
            }
        ';
        eval "$(echo "$gf_run_info_file"$'\n'"$GF_I_RUN_DIR/tasks/run.info" | perl -e "$gf_perl_script")"
        # gf_debug gf_perl_script
        gf_debug gf_run_info_file gf_dir_info

        # Update task name and status
        if [ -n "$gf_task_name" ]; then

            eval "$gf_task_name_variable=\"$gf_task_name\""
            eval "$gf_task_status_variable=\"chosen\""

            # Update chosen status in current run
            if [ -z "$gf_dir_info" ]; then
                GF_TASK_STATUSES+="$gf_task_name $gf_task_basename chosen"$'\n'
            fi

            # Remember selected candidate for current session
            GF_CHOSEN_TASKS+="$gf_task_name $gf_task_basename $gf_run_info_file"$'\n'

            gf_debug GF_TASK_STATUSES GF_CHOSEN_TASKS
        fi
    fi
}

##################################################
# Script create functions
##################################################

# Auto-tab commands
function gf_auto_tab_commands {
    echo "$1" | perl -e '
        my @commands;
        my $tab = "";
        while (<STDIN>) {
            s/\t/    /g;
            push @commands, $_ if (/\S/ || ($#commands >= 0));
            $tab = $_;
        }
        my $spaces_count = "'"$2"'";
        if (!($spaces_count =~ /^\d+$/)) {
            $tab =~ s/\n//m;
            if ($tab =~ s/^(\s*)\S.*$//) {
                $spaces_count = length($1);
            } else {
                $spaces_count = (length($tab) + 4);
            }
        }
        my $commands = "";
        foreach (@commands) {
            s/^[^\S\n]{0,$spaces_count}//;
            $commands .= $_;
        }
        $commands =~ s/^[\s\n]*\n//;
        $commands =~ s/\s+$//;
        print "$commands\n" if ($commands);
    '
}

# Print out command statistic
function gf_print_commands_info {
    local count relative_file

    # Commands list should not be empty
    count=$(gf_count_lines "$1")
    if [ $count -gt 0 ]; then

        # File name exists
        if [ -n "$2" -a -n "$GF_RUN_DIR" ]; then
            relative_file=" to ${GFC7}$(echo "$2" | sed -e "s|^$GF_RUN_DIR/|./|")${GFC0}"
        else
            relative_file=
        fi

        # Print info
        if [ "$count" -eq 1 ]; then
            gf_info "$count line added$relative_file."
        else
            gf_info "$count lines added$relative_file."
        fi
    fi
}

# Create run script
function gf_create_run_script {
    echo -n '#!/bin/bash

        # Open tool in new xterm window if not opened
        if [ -z "$GF_NO_XTERM" -a -z "'$GF_NO_WIN'" -a -z "$GF_NO_WIN" ]; then
            export GF_NO_XTERM=1

            # Open xterm if possible
            if [ -n "$DISPLAY" -a -z "'$GF_SILENT'" ]; then
                xterm '"$GF_XTERM_RES"' -xrm "'"$GF_XTERM_HOTKEYS"'" -geometry '"$GF_XTERM_SIZE"' -e "$BASH_SOURCE" & disown
                exit 0
            fi
        fi

        gf_parse_run_info_script='"'$gf_parse_run_info_script'"'

        # Get full directory path
        function gf_full_path {
            for arg in "$PWD" "$PWD" "$@"; do echo "$arg"; done | perl -e '"'$gf_full_path_perl'"'
        }

        # Go to script directory
        cd "$(dirname "$(gf_full_path "$BASH_SOURCE")")"

        GF_RUN_NAME="$(basename "$(dirname "$PWD")")"
        GF_WORK_DIR="$(dirname "$(dirname "$PWD")")"

        # Title save and restore
        function gf_save_title {
            echo -ne "\e[22;0t"
        }
        function gf_restore_title {
            echo -ne "\e[23;0t"
        }

        # Log output to file
        GF_OUTPUT_LOGGING=
        function gf_disable_logging {
            if [ -n "$GF_OUTPUT_LOGGING" ]; then
                exec 1>&3 2>&4
                GF_OUTPUT_LOGGING=
            fi
        }
        function gf_enable_logging {
            gf_disable_logging
            exec 3>&1 4>&2 1> >(trap '"''"' SIGINT; tee -a "$1") 2>&1
            GF_OUTPUT_LOGGING="$1"
        }

        # Wait for Q press to close
        GF_WAIT_KEY=
        GF_NO_WAIT_KEY="'$GF_NO_WAIT_KEY'"
        function gf_wait_before_close {
            gf_disable_logging
            trap -- EXIT
            trap -- SIGINT
            trap -- SIGQUIT
            trap -- SIGTERM
            trap -- SIGHUP
            if [ -n "$DISPLAY" -a -z "'$GF_NO_WIN'" -a -z "$GF_NO_WIN" -a -z "$GF_WAIT_KEY" -a -z "$GF_NO_WAIT_KEY" -a -z "$GF_BACKGROUND_MODE" -a -z "'$GF_NO_WAIT_KEY'" ]; then
                GF_NO_WAIT_KEY=1
                GF_WAIT_KEY=
                sleep 0.25
                echo -e "\nAll done in this session. Press '${GFH4}'[Q]'${GFC0}' to finish'"$GF_RAISE_WINDOW"'"
                while [ -z "$(echo $GF_WAIT_KEY | grep -i Q)" ]; do
                    read -n 1 -s WAIT_KEY_NEW
                    if [ -z "$GF_WAIT_KEY" ]; then
                        GF_WAIT_KEY=$WAIT_KEY_NEW
                    else
                        GF_WAIT_KEY=Q
                    fi
                done
            fi
            gf_restore_title
            echo
            sleep 0.1
        }
        trap gf_wait_before_close EXIT

        # Save current title
        gf_save_title

        # Save start time
        GF_START_TIME=$(date +%s)

        # Session log name
        GF_RUN_INDEX="'$GF_RUN_INDEX'"

        # Check if run already started
        if [ -n "$(grep -e "\]2;Running " "../logs/run.$GF_RUN_INDEX.log")" ]; then
            echo -ne "\e]1;X - $GF_RUN_NAME\a\e]2;Cancelled - $GF_RUN_NAME - $GF_WORK_DIR\a"
            grep -v -e '"'"'^bash -e '"'"' "../logs/run.$GF_RUN_INDEX.log"
            echo -e "\n'${GFM3}' W '${GFC0}' This run has been already started before. See log above."
            GF_WAIT_KEY=
            exit 1

        # Check if log is writable
        elif [ ! -w "../logs/run.$GF_RUN_INDEX.log" ]; then
            echo -ne "\e]1;X - $GF_RUN_NAME\a\e]2;Cancelled - $GF_RUN_NAME - $GF_WORK_DIR\a"
            echo -e "'${GFM1}' E '${GFC0}' Log file is not writable."
            GF_WAIT_KEY=
            exit 1

        # Redirect log
        else
            chmod a-w "../logs/run.$GF_RUN_INDEX.log"
            chmod u+w "../logs/run.$GF_RUN_INDEX.log"
            gf_enable_logging "../logs/run.$GF_RUN_INDEX.log"
        fi

        if [ -z "$GF_INTEGRATED_RUN" ]; then
            gf_status=$(cat "../logs/run.$GF_RUN_INDEX.log")
            echo "$gf_status" | grep -v -e '"'"'^bash -e '"'"'
            echo

        elif [ -z "$GF_NO_TITLE" ]; then
            echo -e "'"$GF_TITLE"'"
        fi

        # Task run status
        echo "session $GF_RUN_INDEX started $$ $HOSTNAME $USER $(date +%s)" >> ./run.info

        # Status message
        echo -ne "\e]1;R - $GF_RUN_NAME\a\e]2;Running - $GF_RUN_NAME - $GF_WORK_DIR\a"
        echo -e "'${GFM2}' I '${GFC0}' Running tasks in '${GFH7}'./logs/run.$GF_RUN_INDEX.log'${GFC0}' ...\n"

        echo -e "#####################################################################" >> ./run.log
        echo -e "# Process ID: $$" >> ./run.log
        echo -e "# User name: $USER" >> ./run.log
        echo -e "# Host name: $HOSTNAME" >> ./run.log
        echo -e "#####################################################################" >> ./run.log
        echo -e "\n# Run dir:\n$(dirname "$PWD")" >> ./run.log

        # Disable echo before job control
        [[ -z "$GF_BACKGROUND_MODE" ]] && stty -echo

        # Job control
        set -m

        # Exit status support
        GF_RUN_STATUS=finished
        function gf_exit_func {
            echo "session $GF_RUN_INDEX $GF_RUN_STATUS $$ $HOSTNAME $USER $(date +%s)" >> ./run.info
            set +m
            [[ -z "$GF_BACKGROUND_MODE" ]] && stty echo
            gf_wait_before_close
        }
        trap gf_exit_func EXIT

        # Kill pids and wait for its termination
        function gf_kill_pids {
            gf_counter=0
            while ps -p $@ &> /dev/null; do
                if [ $gf_counter -eq 40 ]; then
                    kill -SIGKILL $@ &> /dev/null
                elif [ $gf_counter -eq 20 ]; then
                    kill -SIGTERM $@ &> /dev/null
                elif [ $gf_counter -eq 0 ]; then
                    kill -SIGINT $@ &> /dev/null
                fi
                gf_counter=$((gf_counter+1))
                sleep 0.5
            done
        }

        # Interrupt by external signal
        function gf_term_func {
            echo -e "\n'${GFM3}' W '${GFC0}' Terminating by external signal ...\n\e]1;T - $GF_RUN_NAME\a\e]2;Terminating - $GF_RUN_NAME - $GF_WORK_DIR\a"
            GF_RUN_STATUS=terminated
            gf_kill_pids $(echo $(jobs -p))
            GF_WAIT_KEY=Q
            exit 2
        }
        trap gf_term_func SIGQUIT
        trap gf_term_func SIGTERM

        # Interrupt by user request support
        function gf_int_func {
            if [ -z "$GF_BACKGROUND_MODE" ]; then
                trap "" SIGINT
                trap "" SIGHUP
                gf_pids=$(echo $(jobs -p)); [[ -n "$gf_pids" ]] && kill -SIGTSTP $gf_pids 2> /dev/null
                echo -ne "'${GFH7}'Ctrl+C'${GFC0}' pressed ...
                  '${GFH6}'[W]'${GFC0}' Show session warnings and continue
                  '${GFH2}'[C]'${GFC0}' Show task statuses and continue
                  '${GFH3}'[I]'${GFC0}' Interrupt not started tasks and continue
                  '${GFH1}'[Q]'${GFC0}' Interrupt all tasks and quit
                What is your choice? " | sed -e "s/^\s\{8\}//"
                sleep 0.05
                read -t 5 -n 1 -s gf_key
                gf_pids=$(echo $(jobs -p)); [[ -n "$gf_pids" ]] && kill -SIGCONT $gf_pids 2> /dev/null
            else
                gf_key=Q
            fi

            if [ "$gf_key" == "q" -o "$gf_key" == "Q" ]; then
                echo -e "'${GFH7}'Q'${GFC0}'\n\n'${GFM3}' W '${GFC0}' Please wait while interrupting tasks ...\n\e]1;T - $GF_RUN_NAME\a\e]2;Interrupting - $GF_RUN_NAME - $GF_WORK_DIR\a"
                GF_RUN_STATUS=interrupted
                gf_kill_pids $(echo $(jobs -p))
                sleep 0.25
            else
                if [ "$gf_key" == "i" -o "$gf_key" == "I" -o "$gf_key" == "c" -o "$gf_key" == "C" ]; then
                    if [ "$gf_key" == "c" -o "$gf_key" == "C" ]; then
                        echo -e "'${GFH7}'C'${GFC0}'\n"
                    elif [ "$gf_key" == "i" -o "$gf_key" == "I" ]; then
                        echo -e "'${GFH7}'I'${GFC0}'\n"
                        gf_kill_pids=$(cat ./run.info | perl -e "$gf_parse_run_info_script"'"'"'
                            my $session = '"'\"\$GF_RUN_INDEX\"'"';
                            foreach my $task (@tasks) {
                                print $sessions{$session}{tasks}{$task}{pid}."\n" if ($sessions{$session}{tasks}{$task}{status} eq "submitted");
                            }
                        '"'"')
                        if [ -n "$gf_kill_pids" ]; then
                            gf_kill_pids $gf_kill_pids
                        fi
                    fi

                    cat "../logs/run.$GF_RUN_INDEX.log" | perl -e '"'"'
                        my %statuses;
                        while (<STDIN>) {
                            $statuses{$1} = "=> ".$_ if (/^\[\e\[94m(\d+)/);
                        }
                        foreach my $pid (split /\s+/, "'"'"'"$(echo $(jobs -p))"'"'"'") {
                            print $statuses{$pid};
                        }
                    '"'"'

                elif [ "$gf_key" == "w" -o "$gf_key" == "W" ]; then
                    echo -e "'${GFH7}'W'${GFC0}'\n"
                    gf_messages=$(cat "../logs/run.$GF_RUN_INDEX.log" | perl -e '"'"'
                        my $is_generation = 1;
                        while (<STDIN>) {
                            $is_generation = 0 if (/2;Running.*\a/);
                            print "=> ".$_ if ($is_generation && /^\e\[(91;41m|93;43m).*\e\[0m /);
                        }
                    '"'"')
                    if [ -n "$gf_messages" ]; then
                        echo "$gf_messages"
                    else
                        echo "No warnings found"
                    fi

                elif [ "$gf_key" == "m"  -o "$gf_key" == "M" ]; then
                    local X=$((RANDOM % 1000))
                    local Y=$((RANDOM % 1000))
                    echo -e "'${GFH7}'M'${GFC0}' - Window moved to random position\e[3;${X};${Y}t\e[1t\e[5t"

                elif [ -n "$gf_key" ]; then
                    echo -e "Incorrect choice. Run continued"

                else
                    echo -e "Run continued after '${GFC7}'5'${GFC0}' seconds delay"
                fi
                echo

                sleep 0.25
                trap gf_int_func SIGINT
                trap gf_int_func SIGHUP
            fi
        }
        trap gf_int_func SIGINT
        trap gf_int_func SIGHUP

        # Process id storage
        GF_PIDS=
    ' | sed -e 's/^\s\{4,8\}//'
}

# Finalize run script
function gf_done_run_script {

    # Task count should be > 0
    if [ "$GF_TASK_COUNT" -gt 0 ]; then
        echo -n '

            # Wait tasks to complete
            gf_wait=$(ps -o pid= -p $GF_PIDS)
            gf_total_count=$(echo $gf_wait | wc -w)
            while [ -n "$gf_wait" ]; do
                wait $GF_PIDS
                gf_wait=$(ps -o pid= -p $GF_PIDS)
                sleep 0.5
            done

            # Update task statuses
            gf_runtime=
            gf_status_message=
            gf_tasks_all=0
            gf_tasks_done=0
            gf_tasks_failed=0
            eval "$(cat ./run.info | perl -e "$gf_parse_run_info_script"'"'"'
                my $session = '"'\"\$GF_RUN_INDEX\"'"';
                my %count; my $count = 0;
                $count{"done"} = 0;
                $count{"failed"} = 0;
                $count{"interrupted"} = 0;
                $count{"aborted"} = 0;
                foreach my $task (@tasks) {
                    my $status = $sessions{$session}{tasks}{$task}{status};
                    if ($status) {
                        $count{$status}++;
                        $count++;
                    }
                }
                print "gf_status_message=\"";
                print ", '${GFH2}'".$count{"done"}."'${GFC0}' done" if ($count{"done"});
                print ", '${GFH1}'".$count{"failed"}."'${GFC0}' failed" if ($count{"failed"});
                print ", '${GFH1}'".$count{"interrupted"}."'${GFC0}' interrupted" if ($count{"interrupted"});
                print ", '${GFH1}'".$count{"aborted"}."'${GFC0}' aborted" if ($count{"aborted"});
                print "\"\n";
                print "gf_tasks_all=\"".$count."\"\n";
                print "gf_tasks_done=\"".($count{"done"})."\"\n";
                print "gf_tasks_failed=\"".($count - $count{"done"})."\"\n";
                print "gf_runtime=\"in ";
                my $seconds = ('"'"'"$(date +%s)-$GF_START_TIME"'"'"');
                my $days = int($seconds / 60 / 60 / 24);
                my $hours = int($seconds / 60 / 60);
                my $minutes = int($seconds / 60);
                if ($days > 1) {
                    $minutes = $minutes - $hours * 60;
                    $hours = $hours - $days * 24;
                    print "'${GFH7}'$days'${GFC0}' days '${GFH7}'$hours'${GFC0}' hours '${GFH7}'$minutes'${GFC0}' minutes";
                } elsif ($hours > 1) {
                    $seconds = $seconds - $minutes * 60;
                    $minutes = $minutes - $hours * 60;
                    print "'${GFH7}'$hours'${GFC0}' hours '${GFH7}'$minutes'${GFC0}' minutes '${GFH7}'$seconds'${GFC0}' seconds";
                } elsif ($minutes > 1) {
                    $seconds = $seconds - $minutes * 60;
                    print "'${GFH7}'$minutes'${GFC0}' minutes '${GFH7}'$seconds'${GFC0}' seconds";
                } elsif ($seconds == 1) {
                    print "'${GFH7}'$seconds'${GFC0}' second";
                } else {
                    print "'${GFH7}'$seconds'${GFC0}' seconds";
                }
                print "\"\n";
            '"'"' 2> /dev/null)"

            # Status message
            if [ "$GF_RUN_STATUS" == "finished" ]; then
                if [ "$gf_tasks_failed" == "0" ]; then
                    echo -e "\e]1;V - $GF_RUN_NAME\a\e]2;Finished - $GF_RUN_NAME - $GF_WORK_DIR\a"
                    echo -en "'${GFM2}' I '${GFC0}' Run finished. "
                else
                    echo -e "\e]1;X - $GF_RUN_NAME\a\e]2;Finished - $GF_RUN_NAME - $GF_WORK_DIR\a"
                    echo -en "'${GFM3}' W '${GFC0}' Run finished. "
                fi
            else
                echo -e "\e]1;X - $GF_RUN_NAME\a\e]2;Interrupted - $GF_RUN_NAME - $GF_WORK_DIR\a"
                echo -en "'${GFM3}' W '${GFC0}' Run stopped. "
            fi

            if [ "$gf_tasks_failed" == "0" ]; then
                if [ "$gf_tasks_done" == "1" ]; then
                    echo -e "'${GFH2}'1'${GFC0}' task done $gf_runtime."
                else
                    echo -e "'${GFH2}'$gf_total_count'${GFC0}' tasks done $gf_runtime."
                fi
            else
                if [ "$gf_tasks_all" == "1" ]; then
                    echo -e "'${GFH6}'$gf_total_count'${GFC0}' task submitted$gf_status_message $gf_runtime."
                else
                    echo -e "'${GFH6}'$gf_total_count'${GFC0}' tasks submitted$gf_status_message $gf_runtime."
                fi
            fi

            chmod a-w "../logs/run.$GF_RUN_INDEX.log"
            gf_disable_logging
        ' | sed -e 's/^\s\{8,12\}//'

    # Task count is 0
    else
        echo -n '
            # Status message
            echo -en "'${GFM1}' E '${GFC0}' No tasks to run'${GFC0}'\e]1;X - $GF_RUN_NAME\a\e]2;No tasks to run - $GF_RUN_NAME - $GF_WORK_DIR\a"
            gf_disable_logging
        ' | sed -e 's/^\s\{8,12\}//'
    fi
}

# Write task submit script
function gf_create_submit_script {
    local gf_silent_mode="$1"
    local gf_abort_task="$1"

    # Script header
    echo -n '#!/bin/bash

        # Flow variables
        export TASK_NAME="'"$TASK_NAME"'"
        export MOTHER_TASK_NAME="'"$MOTHER_TASK_NAME"'"
        export GF_ROOT="'"$GF_ROOT"'"
        export GF_SCRIPT="'"$GF_SCRIPT"'"
        export GF_SCRIPT_DIR="'"$GF_SCRIPT_DIR"'"

        # Internal script directory
        cd "$(dirname "$0")"
        export GF_I_WORK_DIR="$(readlink -m ../..)"
        export GF_I_RUN_DIR="$(readlink -m ..)"

        # External task directory
        cd '$TASK_NAME'
        export GF_WORK_DIR="$(readlink -m ../../..)"
        export GF_RUN_DIR="$(readlink -m ../..)"
        export GF_RUN_NAME="$(basename "$(readlink -m ../..)")"
        export GF_RUN_INDEX="'"$GF_RUN_INDEX"'"

        # Save start time
        GF_START_TIME=$(date +%s)

        # Input files md5sum
        rm -f ./in/'$TASK_NAME'.md5sum

        # Print status on exit
        gf_current_task_status=interrupted
        function gf_exit_func {
            duration="$(perl -e '"'"'my $seconds = ('"'"'"$(date +%s)-$GF_START_TIME"'"'"');
                my $days = int($seconds / 60 / 60 / 24);
                my $hours = int($seconds / 60 / 60);
                my $minutes = int($seconds / 60);
                if ($days > 1) {
                    $minutes = $minutes - $hours * 60;
                    $hours = $hours - $days * 24;
                    print "'${GFH7}'$days'${GFC0}' days '${GFH7}'$hours'${GFC0}' hours '${GFH7}'$minutes'${GFC0}' minutes";
                } elsif ($hours > 1) {
                    $seconds = $seconds - $minutes * 60;
                    $minutes = $minutes - $hours * 60;
                    print "'${GFH7}'$hours'${GFC0}' hours '${GFH7}'$minutes'${GFC0}' minutes '${GFH7}'$seconds'${GFC0}' seconds";
                } elsif ($minutes > 1) {
                    $seconds = $seconds - $minutes * 60;
                    print "'${GFH7}'$minutes'${GFC0}' minutes '${GFH7}'$seconds'${GFC0}' seconds";
                } elsif ($seconds == 1) {
                    print "'${GFH7}'$seconds'${GFC0}' second";
                } else {
                    print "'${GFH7}'$seconds'${GFC0}' seconds";
                }
            '"'"')"
            echo "task '"$TASK_NAME $GF_RUN_INDEX $GF_TASK_BASE"' $gf_current_task_status $$ $HOSTNAME $USER $(date +%s)" >> "$GF_I_RUN_DIR/tasks/run.info"
            if [ "$gf_current_task_status" == "done" ]; then
                echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH2}''$TASK_NAME''${GFC0}' done in $duration"
            elif [ "$gf_current_task_status" == "failed" ]; then
                if [ -e "./logs/'$TASK_NAME'.log" ]; then
                    echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH1}''$TASK_NAME''${GFC0}' failed. See '${GFC7}'./logs/'$TASK_NAME'.log'${GFC0}'"
                else
                    echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH1}''$TASK_NAME''${GFC0}' failed in $duration"
                fi
                if [ -n "'$GF_VERBOSE_MODE'" -o -n "$GF_VERBOSE_MODE" ]; then
                    local gf_result=$(grep -ve "^ *\$" "./logs/'$TASK_NAME'.log" | tail -'$GF_VERBOSE_LINES' | sed -e "s/"$'"'"'\e'"'"'"\[0m/"$'"'"'\e'"'"'"\[0;35m/g"2> /dev/null)
                    [[ -n "$gf_result" ]] && echo -e "'${GFC5}'$gf_result'${GFC0}'"
                fi
                exit 4
            else
                echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH1}''$TASK_NAME''${GFC0}' $gf_current_task_status"
                exit 3
            fi 2> /dev/null
        }
        trap gf_exit_func EXIT

        # Submit task and enable logging
        echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH6}''$TASK_NAME''${GFC0}' submitted"
        echo "task '"$TASK_NAME $GF_RUN_INDEX $GF_TASK_BASE"' submitted $$ $HOSTNAME $USER $(date +%s)" >> "$GF_I_RUN_DIR/tasks/run.info"

        # Terminate childs function
        function gf_int_func {
            kill -SIGINT 0 2> /dev/null
            kill -SIGTERM 0 2> /dev/null
            exit 1
        }
        trap gf_int_func SIGINT

        sleep 1
    ' | sed -e 's/^\s\{4,8\}//'

    # Waited and wanted tasks
    local gf_wait_tasks=$(echo "$GF_WAIT_TASKS" | sed -ne 's/^WA[IN]T=\([^=]\+\)=.*$/\1/p')
    if [ -n "$GF_WAIT_TASKS" ]; then
        echo -n '
            # Wait for required tasks
            gf_wait_tasks="'"$GF_WAIT_TASKS"'"

            # Internal status variables
            gf_new_status=
            gf_last_status=$'"'"'\n'"'"'
            gf_wait_commands=$'"'"'\n'"'"'

            # Wait while there are tasks to wait
            gf_abort_task=
            gf_seconds=1
            while [ -n "$gf_wait_tasks" ]; do

                # Monitor file updates
                if [ "$gf_new_status" == "$gf_last_status" ]; then
                    sleep $gf_seconds
                    if [ $gf_seconds -lt 5 ]; then gf_seconds=$((gf_seconds+1)); fi
                    gf_new_status=$(eval "$gf_wait_commands")

                # Update task status when any file updated
                else
                    sleep 1
                    gf_seconds=1
                    # Update commands to check files
                    gf_perl_script=$(echo "$gf_last_status"$'"'"'\n'"'"'"UPDATE"$'"'"'\n'"'"'"$gf_new_status"$'"'"'\n'"'"'"$gf_wait_tasks" | perl -e '"'"'
                        my %files;
                        my @task_actions;
                        my @updated_files;
                        my $need_status = 1;
                        my $is_update = 0;
                        while (<STDIN>) {
                            if (/^UPDATE$/) {
                                $is_update = 1;

                            # Detect updated files
                            } elsif (/^\s*(FILE)=(\S+?)=(.+)$/) {
                                my $file = $3;
                                my $stat = $2;

                                push @updated_files, $file if ($is_update && ($files{$file}{stat} ne $stat));
                                $files{$file}{stat} = $stat;
                                $need_status = 0;

                            # Load task list to check
                            } elsif (/^\s*(WAIT|WANT)=(\S+?)=(.+)$/) {
                                my $action = $1;
                                my $pattern = $2;
                                my $file = $3;

                                push @task_actions, "$action=$pattern=$file";
                                push @updated_files, $file if (!defined $files{$file}{stat} && (-e $file));
                                $files{$file}{patterns}{$pattern} = $action;

                                if ($file eq "'"'"'"$GF_I_RUN_DIR/tasks/run.info"'"'"'") {
                                    $files{$file}{dir} = "";
                                    $files{$file}{run} = "";
                                } else {
                                    my $run = $file;
                                    $run =~ s|/[^/]+/run.info$||;
                                    $run =~ s|^\.\./\.\./||;
                                    $files{$file}{dir} = $run;
                                    $run =~ s|^.+/||g;
                                    $files{$file}{run} = $run;
                                }

                            }
                        }

                        my %delete_files;
                        foreach my $file (@updated_files) {
                            open FILE, $file;
                            '"$(echo "$gf_parse_run_info_script" | sed -e 's/<STDIN>/<FILE>/')"'
                            close FILE;

                            # Check task statuses
                            foreach my $pattern (keys %{$files{$file}{patterns}}) {
                                my $pattern_expr = $pattern;
                                $pattern_expr =~ s/\*/.*/g;
                                $pattern_expr =~ s/\?/./g;

                                my $processed = 0;
                                my $deleted = 0;
                                foreach my $task (@tasks) {
                                    if ($task =~ /^$pattern_expr$/) {
                                        $processed++;
                                        if (($tasks{$task}{status} ne "running") && ($tasks{$task}{status} ne "submitted")) {
                                            $deleted++;
                                            if (($files{$file}{patterns}{$pattern} eq "WANT") && ($tasks{$task}{status} ne "done")) {
                                                my $message = "";
                                                $message .= ", run '${GFC7}'$files{$file}{dir}'${GFC0}'" if ($files{$file}{dir} ne "");
                                                $message .= ", user '${GFC7}'$tasks{$task}{user}'${GFC0}'" if ($tasks{$task}{user} ne "'"'"'$USER'"'"'");
                                                $message .= ", host '${GFC7}'$tasks{$task}{host}'${GFC0}'" if ($tasks{$task}{host} ne "'"'"'$HOSTNAME'"'"'");
                                                print "echo -e \"['${GFH4}'\$\$'${GFC0}'] \$(date +\%d-\%H:\%M:\%S) '${GFH4}''$TASK_NAME''${GFC0}' wanted '${GFC4}'$task'${GFC0}' task '${GFC1}'$tasks{$task}{status}'${GFC0}'$message\"\n";
                                                print "gf_wait_commands=\"\"\n";
                                                print "gf_abort_task=1\n";
                                                exit;
                                            }
                                        }
                                    }
                                }
                                $delete_files{$file}{$pattern} = 1 if ($deleted && ($deleted == $processed));
                            }
                        }

                        # Update task list
                        my %left_files;
                        my @left_tasks;
                        my $gf_wait_tasks = "";
                        my $is_pattern = 0;
                        foreach (@task_actions) {
                            if (/^(WAIT|WANT)=(\S+?)=(.+)$/) {
                                my $pattern = $2;
                                my $file = $3;
                                if ($delete_files{$file}{$pattern}) {
                                    $need_status = 1;
                                } else {
                                    $is_pattern = 1 if ($pattern =~ /[\*\?]/);
                                    $left_files{$file} = 1;
                                    $gf_wait_tasks .= "$_\n";
                                    if ($files{$file}{run} eq "") {
                                        push @left_tasks, $pattern;
                                    } else {
                                        push @left_tasks, "'${GFC7}'".$files{$file}{run}.":'${GFC4}'$pattern";
                                    }
                                }
                            }
                        }

                        # Update wait commands
                        my $gf_wait_commands = "";
                        foreach (keys %left_files) {
                            $gf_wait_commands .= "[ -e \"$_\" ] && echo \"FILE=\$\(stat -c \%Z \"$_\"\)=$_\"\n";
                        }

                        # Print current status
                        if ($need_status && ($#left_tasks >= 0)) {
                            print "echo -e \"['${GFH4}'\$\$'${GFC0}'] \$(date +\%d-\%H:\%M:\%S) '${GFH4}''$TASK_NAME''${GFC0}' waits for '${GFC4}'".join("'${GFC0}', '${GFC4}'", @left_tasks)."'${GFC0}'";
                            if ($is_pattern || ($#left_tasks > 0)) {
                                print " tasks ...\"\n";
                            } else {
                                print " task ...\"\n";
                            }
                        }

                        # Update shell variables
                        print "gf_wait_tasks='"'\"'\"'"'$gf_wait_tasks'"'\"'\"'"'\n";
                        print "gf_wait_commands='"'\"'\"'"'$gf_wait_commands'"'\"'\"'"'\n";
                    '"'"')

                    # Update shell variables
                    eval "$gf_perl_script"
                    if [ -z "$gf_wait_commands" ]; then
                        break
                    else
                        # Update last status
                        gf_last_status="$gf_new_status"
                        gf_new_status=$(eval "$gf_wait_commands")
                    fi
                fi
            done

            # Abort if wanted task failed
            if [ -n "$gf_abort_task" ]; then
                gf_current_task_status=aborted; exit 2
            fi

        ' | sed -e 's/^\s\{8,12\}//'
    fi

    echo -n '
# Update start time
GF_START_TIME=$(date +%s)
    '

    # Init commands
    if [ -n "$GF_TASK_INIT_SCRIPT" ]; then
        echo
        echo "$GF_TASK_INIT_SCRIPT"
    fi

    # Perl script to replace CPU/MEM arguments
    local gf_substitute_options='
        while (<STDIN>) {
            s|\$(GF_)?(TASK_)?CPU\b|'"$GF_TASK_CPU"'|g;
            s|\$(GF_)?(TASK_)?MEM\b|'"$GF_TASK_MEM"'|g;
            s|\$\{(GF_)?(TASK_)?CPU\}|'"$GF_TASK_CPU"'|g;
            s|\$\{(GF_)?(TASK_)?MEM\}|'"$GF_TASK_MEM"'|g;
            print;
        }
    '

    # Command to run task in xterm
    local gf_xterm_command="xterm $GF_XTERM_RES -xrm '$GF_XTERM_HOTKEYS' -geometry 150x30 -T '$TASK_NAME - $(basename "$GF_RUN_DIR") - $(dirname "$GF_RUN_DIR")' -n '$TASK_NAME - $GF_RUN_NAME' -e ./start.sh"
    local gf_silent_command="./start.sh"
    local gf_grid_command=

    # Set up SGE mode
    local gf_grid_mode="$(echo "$GF_TASK_OPTIONS$GF_TASK_OPTIONS_LOCAL" | perl -e "$gf_get_task_option_perl" "$GF_TASK_BASE" '-grid')"
    if [ "$gf_grid_mode" == "sge" ]; then
        gf_grid_command="qsub -sync y -b n -o \"\$GF_I_RUN_DIR/tasks/run.log\" -e \"\$GF_I_RUN_DIR/tasks/run.log\" -v DISPLAY -v WINDOWID -v PATH -N ${TASK_NAME}"

        # Add CPU/MEM and user options
        gf_grid_command+=" $(echo "$GF_TASK_OPTIONS$GF_TASK_OPTIONS_LOCAL" | perl -e "$gf_get_task_option_perl" "$GF_TASK_BASE" '-sge_options' | perl -e "$gf_substitute_options")"

        # Run in current directory
        gf_grid_command+=" -cwd"

    # Set up LSF mode
    elif [ "$gf_grid_mode" == "lsf" ]; then

        # Use current terminal for execution
        gf_grid_command="bsub -K -J ${TASK_NAME}"

        # Add CPU/MEM and user options
        gf_grid_command+=" $(echo "$GF_TASK_OPTIONS$GF_TASK_OPTIONS_LOCAL" | perl -e "$gf_get_task_option_perl" "$GF_TASK_BASE" '-lsf_options' | perl -e "$gf_substitute_options")"

        # Run in current directory
        gf_grid_command+=" --cwd"
    fi
    gf_debug GF_TASK_BASE gf_grid_mode gf_grid_command

    # Modify xterm command
    if [ -n "$gf_grid_mode" ]; then
        gf_xterm_command="echo '$(echo "$gf_xterm_command" | sed -e "s/'/'\"'\"'/g")' | $gf_grid_command"
        gf_silent_command="echo '$gf_silent_command' | $gf_grid_command"
    fi

    # Run commands
    echo -n '
        # Dump command to execute to log
        echo -e "\n# Command:\n'"$(echo "$gf_silent_command" | sed -e "s/\"/\\\\\"/g")"'" >> "$GF_I_RUN_DIR/tasks/run.log"

        # Clear flags to allow run gflow tasks hierarchically
        export GF_NO_WIN=
        export GF_NO_XTERM=
        export GF_INTEGRATED_RUN=

        # Run task in new terminal window
        if [ -n "$DISPLAY" -a -z "'$gf_silent_mode'" ]; then
            '"$gf_xterm_command"' >> "$GF_I_RUN_DIR/tasks/run.log" 2>&1 &
            echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH3}''$TASK_NAME''${GFC0}' is running ..."

        # Run task without terminal window
        else
            echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH3}''$TASK_NAME''${GFC0}' is running silently in '${GFC7}'./logs/'$TASK_NAME'.log'${GFC0}' ..."
            '"$gf_silent_command"' 2>> "$GF_I_RUN_DIR/tasks/run.log" > /dev/null &
        fi

        # Mark task as running
        echo "task '"$TASK_NAME $GF_RUN_INDEX $GF_TASK_BASE"' running $$ $HOSTNAME $USER $(date +%s)" >> "$GF_I_RUN_DIR/tasks/run.info"

        # Wait tasks to complete
        gf_wait=1
        while [ -n "$gf_wait" ]; do
            wait
            gf_pids=$(echo $(jobs -p))
            if [ -z "$gf_pids" ]; then
                gf_wait=
            else
                gf_wait=$(ps -o pid= -p $gf_pids)
            fi
        done

        # Give 10 seconds for network file synchronization
        for i in 1 2 3 4 5; do
            if [ -e "./logs/'$TASK_NAME'.log" ]; then
                break
            else
                sleep 2
            fi
        done

    ' | sed -e 's/^\s\{4,8\}//'

    echo -n "
# Script to filter log
gf_grep_file_perl='$gf_grep_file_perl'
    "

    # Look for info mark
    if [ -n "$GF_TASK_INFO_MARKS" ]; then
        echo -en '
            # Info mark
            gf_info="$(echo '"'$GF_TASK_INFO_MARKS'"' | perl -e "$gf_grep_file_perl"'"'"'
                foreach (@results) {
                    s/\e\[0m/\e\[0;35m/g;
                    s/\\e\[0m/\e\[0;35m/g;
                    print "\e\[35;45m \e\[0;35m $_";
                }
            '"'"')"
            if [ -n "$gf_info" ]; then
                echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' status is\\n'${GFC5}'$(echo "$gf_info")'${GFC0}'"
            fi
        ' | sed -e 's/^\s\{8,12\}//'
    fi

    # Look for success mark
    if [ -n "$GF_TASK_DONE_MARKS" ]; then
        echo -en '
            # Successful mark
            if [ -e "./logs/'$TASK_NAME'.log" ]; then
                gf_current_task_status=failed
                for mark in'$GF_TASK_DONE_MARKS'; do
                    if [ -n "$(grep -e "$mark" ./logs/'$TASK_NAME'.log)" ]; then
                        echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' mark '${GFC2}'$mark'${GFC0}' found"
                        gf_current_task_status=done
                    fi
                done
                if [ "$gf_current_task_status" != "done" ]; then
                    echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' has '${GFC1}'no'${GFC0}' success marks"
                fi
            fi
        ' | sed -e 's/^\s\{8,12\}//'
    fi

    # Look for error mark
    if [ -n "$GF_TASK_FAIL_MARKS" ]; then
        echo -en '
            # Error mark
            if [ -e "./logs/'$TASK_NAME'.log" ]; then
                gf_found=
                for mark in'$GF_TASK_FAIL_MARKS'; do
                    if [ -n "$(grep -e "$mark" ./logs/'$TASK_NAME'.log)" ]; then
                        echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' mark '${GFC1}'$mark'${GFC0}' found"
                        gf_current_task_status=failed
                        gf_found=1
                    fi
                done
                if [ -z "$gf_found" ]; then
                    echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' has '${GFC2}'no'${GFC0}' failed marks"
                fi
            fi
        ' | sed -e 's/^\s\{8,12\}//'
    fi

    # Log file should exist
    echo -n '
        # Check log file
        if [ ! -e "./logs/'$TASK_NAME'.log" ]; then
            echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' log file '${GFC1}'not found'${GFC0}'. See '${GFC7}'./tasks/run.log'${GFC0}'"

            if [ -n "'$GF_VERBOSE_MODE'" -o -n "$GF_VERBOSE_MODE" ]; then
                echo -e "'${GFC5}'$(tail -'$GF_VERBOSE_LINES' "$GF_I_RUN_DIR/tasks/run.log" 2> /dev/null)'${GFC0}'"
            fi
            gf_current_task_status=failed
        fi
    ' | sed -e 's/^\s\{4,8\}//'

    # Status check commands
    echo -n '
        # Check interrupt status
        if [ "$gf_current_task_status" == "failed" ]; then
            if [ -n "'$GF_VERBOSE_MODE'" -o -n "$GF_VERBOSE_MODE" ]; then
                [[ -e "./logs/'$TASK_NAME'.log" ]] && echo -e "'${GFC5}'$(tail -'$GF_VERBOSE_LINES' "./logs/'$TASK_NAME'.log" 2> /dev/null)'${GFC0}'"
            fi
        else
            gf_current_task_status=done
        fi
    ' | sed -e 's/^\s\{4,8\}//'

    # Done commands
    if [ -n "$GF_TASK_DONE_SCRIPT" ]; then
        echo
        echo "$GF_TASK_DONE_SCRIPT"
    fi
}

# Write task start script
function gf_create_start_script {

    # Fix task filter disabled flag
    [[ "$GF_TASK_LOG_FILTER_DISABLE" == "0" ]] && GF_TASK_LOG_FILTER_DISABLE=

    # Task logging commands
    if [ -n "$GF_TASK_LOG_FILTER" -a -z "$GF_TASK_LOG_FILTER_DISABLE" ]; then
        echo -n '#!/bin/bash
            set +m

            # Enable input echo
            stty echo

            echo "INFO: This is a filtered version of log
            => Full log file:  ./logs/'$TASK_NAME'.log
            => Filter command: grep'$GF_TASK_LOG_FILTER'
            " > ./logs/'$TASK_NAME'.filtered.log

            echo "INFO: This log has filtered version
            => Filtered log file: ./logs/'$TASK_NAME'.filtered.log
            " > ./logs/'$TASK_NAME'.log

            echo "INFO: Current log is being filtered
            => Full log file:     ./logs/'$TASK_NAME'.log
            => Filtered log file: ./logs/'$TASK_NAME'.filtered.log
            => Filter command:     grep'$GF_TASK_LOG_FILTER'
            "

            sleep 0.25

            # Redirect log with filtering
            function gf_log_output {
                while IFS= read line; do
                    echo "$line" | grep'$GF_TASK_LOG_FILTER'
                    echo "$line" >> ./logs/'$TASK_NAME'.log
                    echo "$line" | grep'$GF_TASK_LOG_FILTER' >> ./logs/'$TASK_NAME'.filtered.log
                done
            }
            exec &> >(gf_log_output)

            # Run task in native shell
            time ./run
        ' | sed -e 's/^\s\{8,12\}//'

    # Command file without filtering
    else
        echo -n '#!/bin/bash
            set +m

            # Enable input echo
            stty echo

            # Redirect log
            echo -n > ./logs/'$TASK_NAME'.log
            exec &> >(trap '"''"' SIGINT; tee -a ./logs/'$TASK_NAME'.log)

            # Run task in native shell
            time ./run
        ' | sed -e 's/^\s\{8,12\}//'
    fi
}

# Write task run script
function gf_create_task_script {
    echo -e "#!$GF_TASK_SHELL\n"

    if [ -n "$GF_TASK_INIT" ]; then
        echo "# Initialization commands: gf_add_shell_commands -init"
        echo "$GF_TASK_INIT"
    fi

    echo "# Main commands"
    echo "$GF_TASK_CMD $(echo $(echo -e $GF_TASK_ARGS))"
    echo

    if [ -n "$GF_TASK_DONE" ]; then
        echo "# Post-processing commands: gf_add_shell_commands -post"
        echo "$GF_TASK_DONE"
    fi

    echo "sleep 0.5"
}

##################################################
# Task internal functions
##################################################

# Check task name
function gf_check_task_name {
    if [ -z "$TASK_NAME" ]; then
        gf_fatal "Task is not created."
    fi
}

# Check task if it is running
function gf_check_task_running_or_done {

    # Task has already started
    local gf_task_status=
    local gf_perl_script="$gf_parse_run_info_script"'
        my %variants; my @variants;
        my $name = "";
        my $status = "";
        my $pid = "";
        my $host = "";
        my $user = "";
        foreach my $task (@tasks) {
            if ($tasks{$task}{base} eq "'"$GF_TASK_BASE"'") {
                if ($tasks{$task}{status} =~ /^(submitted|running|done)$/) {
                    push @variants, $task if (!$variants{$task}); $variants{$task} = 1;
                    $name = $task;
                    $status = $tasks{$task}{status};
                    $pid = $tasks{$task}{pid};
                    $host = $tasks{$task}{host};
                    $user = $tasks{$task}{user};
                }
            }
        }
        if ($name ne "") {
            print "TASK_NAME=\"$name\"\n";
            print "gf_task_status=\"$status\"\n";
            print "local gf_task_pid=\"$pid\"\n";
            print "local gf_task_host=\"$host\"\n";
            print "local gf_task_user=\"$user\"\n";
            print "local gf_task_variants=\"".join("\n", @variants)."\"\n";
        }
    '
    eval "$(cat "$GF_I_RUN_DIR/tasks/run.info" | perl -e "$gf_perl_script")"
    # gf_debug gf_perl_script
    gf_debug TASK_NAME gf_task_status gf_task_pid gf_task_host gf_task_user gf_task_variants

    # Interactive choice for each task
    if [ -n "$GF_NEED_ASK_GLOBAL" ]; then
        local gf_need_start="$GF_NEED_ASK_GLOBAL"

        # Ask if no global choice
        if [ "$gf_need_start" == "A" ]; then
            gf_choose -variable gf_need_start -toggles A -keys ED -time 300 -default AE -message "Please ${GFC7}confirm${GFC0} task start
              ${GFH2}[E]${GFC0} Enable task (default after 5 minutes)
              ${GFH3}[D]${GFC0} Disable task
              ${GFH4}[A]${GFC0} Apply to all tasks
            "
        fi

        # Remember global choice
        [[ $gf_need_start = *A* ]] && GF_NEED_ASK_GLOBAL=$gf_need_start

        # Skip task
        if [[ $gf_need_start = *E* ]]; then
            GF_SKIP_TASK=
        else
            gf_task_status=skipped
            TASK_NAME="$GF_TASK_BASE"
            GF_SKIP_TASK=disabled
        fi
    fi

    # Task is running
    if [ "$gf_task_status" == "submitted" -o "$gf_task_status" == "running" -o "$gf_task_status" == "done" ]; then
        if [ "$gf_task_status" == "done" ]; then
            local gf_message="has been ${GFC7}already done${GFC0} before."
        else
            local gf_message="${GFC7}is running${GFC0} in other session."
        fi

        # # Use global mode if selected
        # [[ -z "$GF_NEED_RESTART" ]] && GF_NEED_RESTART=$GF_NEED_RESTART_GLOBAL

        # Ask user if required
        local gf_is_global=
        local gf_task_tag="$GF_TAG"
        if [ -n "$(echo "$gf_task_variants" | grep -Fx -- "$GF_TASK_BASE$gf_task_tag")" ]; then
            gf_task_tag="$gf_task_tag.$GF_RUN_INDEX"
        fi
        if [ -z "$GF_NEED_RESTART" -a -z "$GF_SKIP_TASK" ]; then
            gf_choose -variable GF_NEED_RESTART -toggles A -keys ISR -time 300 -default AS -message "Task $gf_message
              ${GFH2}[I]${GFC0} Run incremental ${GFC7}$GF_TASK_BASE$gf_task_tag${GFC0} task
              ${GFH3}[S]${GFC0} Skip (default after 5 minutes)
              ${GFH1}[R]${GFC0} Restart
              ${GFH4}[A]${GFC0} Apply to all tasks
            "
        fi

        # Remember global choice
        [[ $GF_NEED_RESTART = *A* ]] && GF_TASK_OPTIONS+="gf_set_task_option>0>*>-restart_mode"$'\n$GF_NEED_RESTART\n'
        # [[ $GF_NEED_RESTART = *A* ]] && GF_NEED_RESTART_GLOBAL=$GF_NEED_RESTART
        gf_debug GF_NEED_RESTART

        # Task to be restarted
        if [ -z "$GF_SKIP_TASK" ]; then
            if [[ $GF_NEED_RESTART = *R* ]]; then

                # Select from several tasks
                if [ $(gf_count_words $gf_task_variants) -gt 1 ]; then
                    gf_choose -variable TASK_NAME -variants "$gf_task_variants" -count 10 \
                        -message "Which task ${GFH7}to restart${GFC0}?" \
                        -prompt "Press ${GFH2}[Up]${GFC0} or ${GFH2}[Down]${GFC0} to choose:"

                    # Get restarting task status
                    local gf_perl_script="$gf_parse_run_info_script"'
                        my $task = "'"$TASK_NAME"'";
                        print "gf_task_status=\"".$tasks{$task}{status}."\"\n";
                        print "gf_task_host=\"".$tasks{$task}{host}."\"\n";
                        print "gf_task_user=\"".$tasks{$task}{user}."\"\n";
                        print "gf_task_pid=\"".$tasks{$task}{pid}."\"\n";
                    '
                    eval "$(cat "$GF_I_RUN_DIR/tasks/run.info" | perl -e "$gf_perl_script")"
                    # gf_debug gf_perl_script
                    gf_debug gf_task_status gf_task_host gf_task_user gf_task_pid
                fi

                # Update task status
                if [ "$gf_task_status" == "done" ]; then
                    gf_info "Task ${GFH1}$TASK_NAME${GFC0} will be restarted."

                # Kill task if possible
                elif [ "$gf_task_status" == "submitted" -o "$gf_task_status" == "running" ]; then

                    # Check if host is the same
                    if [ -n "$gf_task_host" -a "$gf_task_host" != "$HOSTNAME" ]; then
                        gf_fatal "Cannot terminate ${GFH7}$TASK_NAME${GFC0} task at different ${GFH1}$gf_task_host${GFC0} host."
                    fi

                    # Check if user is the same
                    if [ -n "$gf_task_user" -a "$gf_task_user" != "$USER" ]; then
                        gf_fatal "Cannot terminate ${GFH7}$TASK_NAME${GFC0} task of different ${GFH1}$gf_task_user${GFC0} user."
                    fi

                    # Kill task and update status
                    if [ -n "$gf_task_pid" ]; then
                        ps -p $gf_task_pid &> /dev/null && kill -SIGINT $gf_task_pid > /dev/null
                        while ps -p $gf_task_pid > /dev/null; do sleep 1; done
                        gf_info "Task ${GFH1}$TASK_NAME${GFC0} terminated in other run session."
                    fi
                fi

            # Update task name
            elif [[ $GF_NEED_RESTART = *I* ]]; then
                TASK_NAME="$GF_TASK_BASE$gf_task_tag"
                gf_info "Task name is ${GFH6}$TASK_NAME${GFC0} now."

            # Task to be skipped
            else
                TASK_NAME="$GF_TASK_BASE"

                # Skip done task
                if [ "$gf_task_status" == "done" ]; then
                    gf_info "Already done task ${GFH3}$TASK_NAME${GFC0} skipped.\n"
                    GF_SKIP_TASK=done

                # Remember running task status to use PID
                else
                    gf_info "Currently running task ${GFH3}$TASK_NAME${GFC0} skipped.\n"
                    GF_SKIP_TASK=running
                fi
            fi

        # Show skipped status
        else
            TASK_NAME="$GF_TASK_BASE"

            if [ "$gf_task_status" == "done" ]; then
                gf_info "Task ${GFH2}$TASK_NAME${GFC0} already done."
            else
                gf_info "Task ${GFH3}$TASK_NAME${GFC0} already running."
            fi
        fi
    fi
}

# Reset task values
function gf_reset_task {
    MOTHER_TASK_NAME=
    TASK_NAME=
    GF_TASK_BASE=
    GF_TASK_INIT=
    GF_TASK_DONE=
    GF_TASK_INIT_SCRIPT=
    GF_TASK_DONE_SCRIPT=
    GF_TASK_CMD=
    GF_TASK_ARGS=
    GF_TASK_SCRIPTS=
    GF_TASK_LOG_FILTER=
    GF_TASK_LOG_FILTER_DISABLE=
    GF_TASK_INFO_MARKS=
    GF_TASK_FAIL_MARKS=
    GF_TASK_DONE_MARKS=
    GF_TASK_SCRIPT=
    GF_TASK_ARG=
    GF_TOOL_SCRIPT=
    GF_TOOL_ARG=
    GF_TOOL_COMMENT=
    GF_WAIT_TASKS=
    GF_TASK_SHELL=$SHELL
    GF_TASK_OPTIONS_LOCAL=
    # GF_GRID_MODE=$GF_GRID_MODE_GLOBAL
}

##################################################
gf_help_section "Main GF script commands"
##################################################

gf_help_command '
    {gf_create_task} [-name] <name> [-command <command>] [-cpu <cpu>] [-mem <mem>] [-local|-sge|-lsf]
         [-mother <mother_task>] [-mother_last] [-restart|-skip|-incr] [-group <group> [-parallel <count>]
    Create new task with specified {name} to run {command}.
    Command can be defined later with {gf_set_task_command} function or {gf_use_*} preset.
    CPU and MEM usage can be set with {-cpu} and {-mem} options.
    Task-specific grid engine can be selected with one of {-local}, {-sge} or {-lsf} options.
    Task will optionally wait for {mother_task} to complete successfully before start.
    Option -restart can be used to automatically restart the task if it is running or done.
    Option -skip can be used to automatically skip the task if it is running or done.
    Option -incr can be used to automatically start the task in incremental mode.
    Options -group and -parallel can be used to limit tasks of the same running at the same time.
'
function gf_create_task {
    eval "$(gf_update_function)"
    local key

    # Save previous task name
    GF_PREV_TASK_NAME=$TASK_NAME

    # Reset previous task data
    gf_reset_task

    # Current task variables
    # GF_TASK_CPU=1
    # GF_TASK_MEM=1
    GF_TASK_MSG=
    GF_TASK_COMMENT=

    # Task group parallel start
    local gf_task_group=
    local gf_parallel_count=

    # Parse command line
    # GF_NEED_RESTART=
    local gf_need_mother=
    local gf_info_message=
    local gf_fatal_message=
    while [ $# -gt 0 ]; do
        key="$1"; shift
        case "$key" in
            "-mother" )
                MOTHER_TASK_NAME="$1"; shift
            ;;
            "-mother_last" )
                gf_need_mother=1

                # Mother can be linked to current run if last task is not empty
                if [ -n "$LAST_TASK_NAME" ]; then
                    MOTHER_TASK_NAME="$LAST_TASK_NAME"

                # Browse for the tasks from previous runs if it is empty
                elif [ -e "$GF_I_RUN_DIR/tasks/run.info" ]; then
                    local gf_perl_script="$gf_parse_run_info_script"'
                        print "$bases[$#bases]\n";
                    '
                    MOTHER_TASK_NAME=$(cat "$GF_I_RUN_DIR/tasks/run.info" | perl -e "$gf_perl_script")
                    # gf_debug gf_perl_script
                    gf_debug MOTHER_TASK_NAME
                fi
            ;;
            "-name" )
                if [[ $1 =~ ^[a-zA-Z0-9_]+$ ]]; then
                    TASK_NAME="$1"
                else
                    gf_fatal "Task name ${GFH7}$1${GFC0} contains non-alphanumeric characters."
                fi
                shift
            ;;
            "-cpu" )
                if [[ $1 =~ ^[1-9][0-9]*$ ]]; then
                    GF_TASK_OPTIONS_LOCAL+="gf_set_task_option>2>*>-cpu"$'\n'"$1"$'\n'
                    # GF_TASK_CPU="$1"
                    # GF_TASK_MSG+="$(gf_info "CPU usage is ${GFC7}${GF_TASK_CPU}${GFC0}.")\n"
                    shift
                elif [ -z "$1" ]; then
                    gf_fatal "Option ${GFH7}$key${GFC0} value is empty."
                else
                    gf_fatal "Option ${GFH7}$key${GFC0} value ${GFH1}$1${GFC0} should be a number."
                fi
            ;;
            "-mem" )
                if [[ $1 =~ ^[1-9][0-9]*$ ]]; then
                    GF_TASK_OPTIONS_LOCAL+="gf_set_task_option>2>*>-mem"$'\n'"$1"$'\n'
                    # GF_TASK_MEM="$1"
                    # GF_TASK_MSG+="$(gf_info "MEM usage is ${GFC7}${GF_TASK_MEM}G${GFC0}.")\n"
                    shift
                elif [ -z "$1" ]; then
                    gf_fatal "Option ${GFH7}$key${GFC0} value is empty."
                else
                    gf_fatal "Option ${GFH7}$key${GFC0} value ${GFH1}$1${GFC0} should be a number."
                fi
            ;;
            "-local" )
                GF_TASK_OPTIONS_LOCAL+="gf_set_task_option>2>*>-grid"$'\n'""$'\n'
                # GF_GRID_MODE=
                gf_info_message="Task will be executed at local host"
            ;;
            "-sge" )
                if [ -z "$(which qsub 2> /dev/null)" ]; then
                    gf_fatal_message="SGE mode cannot be activated. No path to ${GFH7}qsub${GFC0} command."
                else
                    GF_TASK_OPTIONS_LOCAL+="gf_set_task_option>2>*>-grid"$'\n'"sge"$'\n'
                    # GF_GRID_MODE=SGE
                    gf_info_message="Task will be executed in SGE"
                fi
            ;;
            "-lsf" )
                if [ -z "$(which bsub 2> /dev/null)" ]; then
                    gf_fatal_message="LSF mode cannot be activated. No path to ${GFH7}bsub${GFC0} command."
                else
                    GF_TASK_OPTIONS_LOCAL+="gf_set_task_option>2>*>-grid"$'\n'"lsf"$'\n'
                    # GF_GRID_MODE=LSF
                    gf_info_message="Task will be executed in LSF"
                fi
            ;;
            "-command" )
                GF_TASK_CMD=$(gf_auto_tab_commands "$1"); shift
                if [ $(echo "$GF_TASK_CMD" | wc -l) -gt 1 ]; then
                    GF_TASK_MSG+="$(gf_info "Commands are "$'\n'"${GFC7}${GF_TASK_CMD}${GFC0}")"$'\n'
                else
                    GF_TASK_MSG+="$(gf_info "Command is ${GFC7}${GF_TASK_CMD}${GFC0}")"$'\n'
                fi
            ;;
            "-group" )
                if [[ $1 =~ ^[a-zA-Z0-9_]+$ ]]; then
                    gf_task_group="$1"
                else
                    gf_fatal "Option ${GFH7}$key${GFC0} value ${GFH1}$1${GFC0} contains non-alphanumeric characters."
                fi
                shift
            ;;
            "-parallel" )
                if [[ $1 =~ ^[0-9]+$ ]]; then
                    gf_parallel_count="$1"
                else
                    gf_fatal "Option ${GFH7}$key${GFC0} value ${GFH1}$1${GFC0} should be a positive number."
                fi
                shift
            ;;
            "-restart" )
                GF_TASK_OPTIONS_LOCAL+="gf_set_task_option>2>*>-restart_mode"$'\n'"R"$'\n'
                # if [ -z "$GF_NEED_RESTART_GLOBAL" ]; then
                    # GF_NEED_RESTART=R
                # fi
            ;;
            "-incr" )
                GF_TASK_OPTIONS_LOCAL+="gf_set_task_option>2>*>-restart_mode"$'\n'"I"$'\n'
                # if [ -z "$GF_NEED_RESTART_GLOBAL" ]; then
                    # GF_NEED_RESTART=I
                # fi
            ;;
            "-skip" )
                GF_TASK_OPTIONS_LOCAL+="gf_set_task_option>2>*>-restart_mode"$'\n'"S"$'\n'
                # if [ -z "$GF_NEED_RESTART_GLOBAL" ]; then
                    # GF_NEED_RESTART=S
                # fi
            ;;
            -* )
                gf_fatal "Incorrect ${GFH7}$key${GFC0} option."
            ;;
            * )
                if [ -z "$TASK_NAME" ]; then
                    if [[ $key =~ ^[a-zA-Z0-9_]+$ ]]; then
                        TASK_NAME="$key"
                    else
                        gf_fatal "Task name ${GFH7}$key${GFC0} contains non-alphanumeric characters."
                    fi
                else
                    gf_fatal "Incorrect ${GFH7}$key${GFC0} option."
                fi
            ;;
        esac
    done

    # Task base name
    GF_TASK_BASE="$TASK_NAME"

    # Task name should not be empty
    if [ -z "$TASK_NAME" ]; then
        gf_fatal "Task name is empty."

    # Previous created task name should be run before the next
    elif [ -n "$GF_PREV_TASK_NAME" ]; then
        gf_fatal "${GFH7}$GF_PREV_TASK_NAME${GFC0} has been created but not submitted."
    fi

    # Active task
    gf_info "New task ${GFH6}$TASK_NAME${GFC0} ..."

    # Messages
    [[ -n "$gf_fatal_message" ]] && gf_fatal "$gf_fatal_message"
    [[ -n "$gf_info_message" ]] && gf_info "$gf_info_message"

    # Check if task disabled
    if [ "$(echo "$GF_TASK_OPTIONS$GF_TASK_OPTIONS_LOCAL" | perl -e "$gf_get_task_option_perl" "$GF_TASK_BASE" '-enable')" == "0" ]; then
        GF_SKIP_TASK=disabled
    else
        GF_SKIP_TASK=
    fi
    gf_debug GF_TASK_OPTIONS GF_TASK_BASE GF_SKIP_TASK
    # GF_SKIP_TASK=$(echo "$GF_CONTROL_TASKS $GF_CONTROL_TASKS_CMD_LINE" | perl -e '
        # my $task = '"'$TASK_NAME'"';
        # my @controls; my $first = "";
        # while (<STDIN>) {
            # s|^\s+||;
            # s|\s+$||;
            # foreach my $expr (split /\s+/, $_) {
                # if ($expr =~ /^(\w+)=(\S+)$/) {
                    # my $enable = ($1 eq "EN");
                    # my $pattern = $2;
                    # $pattern =~ s|\?|.|g;
                    # $pattern =~ s|\*|.*|g;
                    # $controls[$#controls+1]{pattern} = $pattern;
                    # $controls[$#controls]{enable} = $enable;
                    # $first = ($enable || 0) if ($first eq "");
                # }
            # }
        # }
        # my $enabled = 1; $enabled = 0 if ($first);
        # for (my $i = 0; $i <= $#controls; $i++) {
            # my $pattern = $controls[$i]{pattern};
            # $enabled = $controls[$i]{enable} if ($task =~ m|^$pattern$|);
        # }
        # print "disabled" if (!$enabled);
    # ')
    # gf_debug GF_CONTROL_TASKS GF_CONTROL_TASKS_CMD_LINE GF_SKIP_TASK

    # Task restart mode
    GF_NEED_RESTART="$(echo "$GF_TASK_OPTIONS$GF_TASK_OPTIONS_LOCAL" | perl -e "$gf_get_task_option_perl" "$GF_TASK_BASE" '-restart_mode')"

    # Check if task is running or done
    gf_check_task_running_or_done

    # Task is still active
    if [ -z "$GF_SKIP_TASK" ]; then

        # Task resources
        GF_TASK_CPU="$(echo "$GF_TASK_OPTIONS$GF_TASK_OPTIONS_LOCAL" | perl -e "$gf_get_task_option_perl" "$GF_TASK_BASE" '-cpu')"
        if [ -z "$GF_TASK_CPU" ]; then
            GF_TASK_CPU=1
        else
            gf_info "CPU usage is ${GFC7}${GF_TASK_CPU}${GFC0}."
        fi

        GF_TASK_MEM="$(echo "$GF_TASK_OPTIONS$GF_TASK_OPTIONS_LOCAL" | perl -e "$gf_get_task_option_perl" "$GF_TASK_BASE" '-mem')"
        if [ -z "$GF_TASK_MEM" ]; then
            GF_TASK_MEM=1
        else
            gf_info "MEM usage is ${GFC7}${GF_TASK_MEM}G${GFC0}."
        fi

        # Print task info messages
        echo -n "$GF_TASK_MSG"; GF_TASK_MSG=

        # Wait tasks with parallel count
        if [ -n "$gf_parallel_count" ]; then
            local gf_perl_script='
                my $count = "'"$gf_parallel_count"'";
                my @tasks;
                while (<STDIN>) {
                    push @tasks, $1 if (/^(\S+)='"$gf_task_group"'$/);
                }
                print $tasks[$#tasks-$count+1]."\n" if ($#tasks-$count+1 >= 0);
            '
            local gf_wait_task="$(echo -e "$GF_TASK_GROUPS" | perl -e "$gf_perl_script")"
            # gf_debug gf_perl_script
            gf_debug gf_wait_task

            if [ -n "$gf_wait_task" ]; then
                if [ -z "$gf_task_group" ]; then
                    gf_info "Task will wait for ${GFC4}$gf_wait_task${GFC0} (parallel limit ${GFC7}$gf_parallel_count${GFC0})."
                else
                    gf_info "Task will wait for ${GFC4}$gf_wait_task${GFC0} (parallel limit ${GFC7}$gf_parallel_count${GFC0} in ${GFC7}$gf_task_group${GFC0} group)."
                fi
                GF_WAIT_TASKS+="WAIT=$(echo $gf_wait_task)=\$GF_I_RUN_DIR/tasks/run.info"$'\n'
            fi
        fi

        # Mother task should be correct
        if [ -n "$MOTHER_TASK_NAME" ]; then

            # Select task in current session if possible
            local gf_perl_script="$gf_parse_task_statuses_script"'
                my $base = "'"$MOTHER_TASK_NAME"'";
                my $task = $bases{$base}{task};
                $task = $tasks{$base}{task} if ($task eq "");
                if ($task ne "") {
                    print "MOTHER_TASK_NAME=$task\n";
                    print "local gf_mother_task_status=$tasks{$task}{status}\n";
                }
            '
            eval "$(echo "$GF_TASK_STATUSES" | perl -e "$gf_perl_script")"
            # gf_debug gf_perl_script
            gf_debug GF_TASK_STATUSES MOTHER_TASK_NAME gf_mother_task_status

            # Select task in previous sessions
            if [ "$gf_mother_task_status" != "new" ]; then
                gf_choose_task_candidate MOTHER_TASK_NAME gf_mother_task_status "$MOTHER_TASK_NAME" "$GF_I_RUN_DIR/tasks/run.info" "mother task"
            fi
            gf_debug MOTHER_TASK_NAME gf_mother_task_status

            # Disable task if mother skipped or disabled
            if [ "$gf_mother_task_status" == "disabled" -o "$gf_mother_task_status" == "skipped" ]; then
                gf_warning "Task ${GFH3}$TASK_NAME${GFC0} skipped because it's mother ${GFC4}$MOTHER_TASK_NAME${GFC0} $gf_mother_task_status.\n"
                GF_SKIP_TASK=skipped

            # Wait for mother task to complete successfully
            elif [ -n "$gf_mother_task_status" ]; then
                GF_WAIT_TASKS+="WANT=$MOTHER_TASK_NAME=\$GF_I_RUN_DIR/tasks/run.info"$'\n'
                if [ "$gf_mother_task_status" == "chosen" ]; then
                    gf_info "Task will wait mother ${GFC4}$MOTHER_TASK_NAME${GFC0} to complete successfully in other session."
                else
                    gf_info "Task will wait for mother ${GFC4}$MOTHER_TASK_NAME${GFC0} to complete successfully."
                fi

            # No mother found
            else
                gf_fatal "Task mother ${GFH4}$MOTHER_TASK_NAME${GFC0} is not defined."
            fi

        # No last mother found for second and next tasks
        elif [ -n "$gf_need_mother" -a "$GF_SKIP_TASK" != "disabled" ]; then
            if [ -z "$GF_TASK_STATUSES" ]; then
                gf_info "Option ${GFH7}-mother_last${GFC0} ignored for the first task."
            else
                gf_fatal "Task mother specified as ${GFH1}-mother_last${GFC0} is not defined."
            fi
        fi

    # Task have been disabled
    elif [ "$GF_SKIP_TASK" == "disabled" ]; then
        gf_info "Task ${GFH3}$TASK_NAME${GFC0} disabled.\n"
        GF_TASK_STATUSES+="$TASK_NAME $GF_TASK_BASE disabled"$'\n'

    # Task have been skipped
    else
        GF_TASK_STATUSES+="$TASK_NAME $GF_TASK_BASE skipped"$'\n'
    fi

    # Add task to group
    if [ -z "$GF_SKIP_TASK" -o "$GF_SKIP_TASK" == "running" ]; then
        GF_TASK_GROUPS+="$TASK_NAME=$gf_task_group\n"
    fi

    eval "$(gf_revert_function)"
}

gf_help_command '
    {gf_set_task_command} <command>
    Define task {command} to execute.
    Multi-line command sequence in quotes allowed as an argument
    Synonyms: gf_set_task_cmd, gf_set_task_command
'
function gf_set_task_cmd { gf_set_task_command "$@"; }
function gf_set_task_command {
    GF_TASK_CMD="$@"
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function gf_set_task_cmd)"

    gf_check_task_name

    if [ $(echo "$GF_TASK_CMD" | wc -l) -gt 1 ]; then
        gf_info "Commands are "$'\n'"${GFC7}$GF_TASK_CMD${GFC0}"
    else
        gf_info "Command is ${GFC7}$GF_TASK_CMD${GFC0}"
    fi

    eval "$(gf_revert_function)"
}

gf_help_command '
    {gf_submit_task} [-silent] [-wait <waited_task> ...] [-want <wanted_task> ...]
        [-wait_last] [-wait_all] [-want_last] [-want_all]
    Submit current task. Task will be started without terminal if {-silent} option used.
    Will wait until corresponding tasks to complete successfully if {wanted_tasks} arguments used.
    Will wait until corresponding tasks to finish with any result if {waited_tasks} arguments used.
    Will wait last task ({-wait_last}, {-want_last}) or all previous ({-wait_all}, {-want_all}) tasks.
    Synonyms: gf_run_task, gf_submit_task
'
function gf_run_task { gf_submit_task "$@"; }
function gf_submit_task {
    eval "$(gf_update_function gf_run_task)"

    local key

    # Parse command line
    local gf_silent_mode=$GF_SILENT
    local gf_mode=
    while [ $# -gt 0 ]; do
        key="$1"; shift
        case "$key" in
            "-silent" )
                gf_silent_mode=1
                gf_mode=
            ;;
            "-wait" )
                gf_mode=wait
            ;;
            "-want" )
                gf_mode=want
            ;;
            "-wait_last" )
                gf_wait_tasks -wait $LAST_TASK_NAME
            ;;
            "-want_last" )
                gf_wait_tasks -want $LAST_TASK_NAME
            ;;
            "-wait_all" )
                gf_wait_tasks -wait $GF_ACTIVE_TASKS
                GF_ACTIVE_TASKS=""
            ;;
            "-want_all" )
                gf_wait_tasks -want $GF_ACTIVE_TASKS
                GF_ACTIVE_TASKS=""
            ;;
            -* )
                gf_fatal "Incorrect ${GFH7}$key${GFC0} option."
            ;;
            * )
                if [ -n "$gf_mode" ]; then
                    gf_wait_tasks -$gf_mode "$key"
                else
                    gf_fatal "Incorrect ${GFH7}$key${GFC0} argument."
                fi
            ;;
        esac
    done

    # Task should be created before start
    if [ -z "$TASK_NAME" ]; then
        gf_fatal "Task should be created before run."

    # Task name should be unique and not skipped
    elif [ -z "$GF_SKIP_TASK" ]; then
        local gf_perl_script="$gf_parse_task_statuses_script"'
            my $task = "'"$TASK_NAME"'";
            print "local gf_current_task_status=\"$tasks{$task}{status}\"\n";
        '
        eval "$(echo "$GF_TASK_STATUSES" | perl -e "$gf_perl_script")"
        # gf_debug gf_perl_script
        gf_debug GF_TASK_STATUSES gf_current_task_status

        # Already defined task name
        if [ "$gf_current_task_status" == "new" ]; then
            gf_fatal "Task name ${GFH7}$TASK_NAME${GFC0} is not unique."

        elif [ "$gf_current_task_status" == "chosen" ]; then
            gf_fatal "Task name ${GFH7}$TASK_NAME${GFC0} already used as mother or task to wait."

        # Task command should not be empty
        elif [ -z "$GF_TASK_CMD" ]; then
            gf_fatal "No gf_create_task ${GFH7}-command${GFC0} option used, nor ${GFH7}gf_set_task_command${GFC0} or ${GFH7}gf_use_*${GFC0} commands between gf_create_task and gf_submit_task."
        fi
    fi

    # Start task if not skipped
    if [ -z "$GF_SKIP_TASK" ]; then

        # Save task PID
        GF_TASK_STATUSES+="$TASK_NAME $GF_TASK_BASE new"$'\n'

        # Create new executable task submit script
        rm -f "$GF_I_RUN_DIR/tasks/submit.$TASK_NAME.sh"
        gf_create_submit_script "$gf_silent_mode" > "$GF_I_RUN_DIR/tasks/submit.$TASK_NAME.sh"
        chmod u+x "$GF_I_RUN_DIR/tasks/submit.$TASK_NAME.sh"

        # Create task directory
        mkdir -p "$GF_RUN_DIR/tasks/$TASK_NAME"
        [[ -n "$GF_INT_DIR" ]] && ln -sf "$GF_RUN_DIR/tasks/$TASK_NAME" "$GF_I_RUN_DIR/tasks/"

        # Link run directories
        local dir
        for dir in scripts in out logs reports; do
            if [ -e "$GF_RUN_DIR/tasks/$TASK_NAME/../../$dir" -a ! -e "$GF_RUN_DIR/tasks/$TASK_NAME/$dir" ]; then
                ln -sf "../../$dir" "$GF_RUN_DIR/tasks/$TASK_NAME/$dir"
            fi
        done

        # Create new executable task start script
        rm -f "$GF_RUN_DIR/tasks/$TASK_NAME/start.sh"
        rm -f "$GF_RUN_DIR/logs/$TASK_NAME.log"
        rm -f "$GF_RUN_DIR/logs/$TASK_NAME.filtered.log"
        gf_create_start_script > "$GF_RUN_DIR/tasks/$TASK_NAME/start.sh"
        chmod u+x "$GF_RUN_DIR/tasks/$TASK_NAME/start.sh"

        # Create new executable task run script
        rm -f "$GF_RUN_DIR/tasks/$TASK_NAME/run"
        gf_create_task_script > "$GF_RUN_DIR/tasks/$TASK_NAME/run"
        chmod u+x "$GF_RUN_DIR/tasks/$TASK_NAME/run"

        # Status message
        if [ -z "$GF_WAIT_TASKS" ]; then
            gf_info "${GFH6}$TASK_NAME${GFC0} scheduled.\n"
        else
            gf_info "${GFH6}$TASK_NAME${GFC0} scheduled after ${GFC4}$(echo $(echo "$GF_WAIT_TASKS" | sed -ne 's/^WA[IN]T=\([^=]\+\)=.*/\1/p') | sed -e "s/ /\\${GFC0}, \\${GFC4}/g")${GFC0}.\n"
        fi

        # Append run commands
        echo "$(gf_auto_tab_commands "
            # Submit task $TASK_NAME
            ./submit.$TASK_NAME.sh & GF_PID=\$!
            GF_PIDS+=\"\$GF_PID \"
            sleep 0.05

        ")" >> "$GF_RUN_SCRIPT"

        # Update task count
        GF_TASK_COUNT=$((GF_TASK_COUNT+1))

        # Update active tasks
        GF_ACTIVE_TASKS+=" $TASK_NAME"
    fi

    # Save last task name
    if [ -z "$GF_SKIP_TASK" -o "$GF_SKIP_TASK" == "running" -o "$GF_SKIP_TASK" == "done" ]; then
       LAST_TASK_NAME=$TASK_NAME
    fi

    # Reset task info
    gf_reset_task

    eval "$(gf_revert_function)"
}

##################################################
gf_help_section "Additional GF script commands"
##################################################

gf_help_command '
    {gf_source} [-once] <file>
    Source external {file} in Generic Flow environment.
    File path can be relative to current directory, root script path or current script path.
    Content of the {file} will be saved in $GF_RUN_DIR/scripts/*.sources.gf files.
    Option {-once} prevents loading the same file twice.
'
function gf_source {
    eval "$(gf_update_function)"
    local gf_parent_last_file_content="$GF_LAST_FILE_CONTENT"

    local gf_once=0
    local gf_file=
    while [ $# -gt 0 ]; do
        key="$1"; shift
        case "$key" in
            "-once" )
                gf_once=1
            ;;
            -* )
                gf_fatal "Incorrect ${GFH7}$key${GFC0} option."
            ;;
            * )
                if [ -z "$gf_file" ]; then
                    gf_file="$key"
                else
                    gf_fatal "Incorrect ${GFH7}$key${GFC0} option."
                fi
            ;;
        esac
    done

    # Source file
    if [ -n "$gf_file" ]; then
        local gf_file_full_name=$(gf_full_path "$gf_file")

        local gf_file_used="$(echo "$GF_SOURCED_SCRIPTS" | grep -Fx -- "$gf_file_full_name" || :)"
        if [ -z "$gf_file_used" -o "$gf_once" == "0" ]; then
            GF_SOURCED_SCRIPTS+="$gf_file_full_name"$'\n'

            local gf_file_short_name=$(gf_get_short_path "$gf_file_full_name")
            gf_debug gf_file_full_name gf_file_short_name

            # Save values for sensitive global variables
            local gf_parent_source_file="$GF_SOURCE_FILE"
            local gf_parent_func_name_source="$GF_FUNC_NAME"

            # Update current help section
            gf_help_section "User script"

            # Update global variables
            GF_SOURCE_FILE="$gf_file_full_name"
            GF_FUNC_NAME="${FUNCNAME[0]}"

            # Load file content
            gf_load_file_content "$gf_file"
            local gf_status="$GF_LAST_FILE_STATUS"
            local gf_content="$GF_LAST_FILE_CONTENT"
            GF_FUNC_NAME="$(basename "$gf_file")"

            # Update line number offset and evaluate content
            local gf_last_file="$GF_LAST_FILE"
            eval "local GF_LINENO=$((LINENO-1)); $gf_content"
            GF_LAST_FILE="$gf_last_file"

            # Save content and show messages in normal mode only
            GF_FUNC_NAME="${FUNCNAME[0]}"
            if [ -z "$GF_PRELOAD_MODE" ]; then

                # Save file content
                gf_save_file_content "$gf_file" "$gf_last_file" "$gf_content"

                # Show messages
                if [ "$gf_status" == "IU" ]; then
                    gf_info "File ${GFC7}$gf_file${GFC0} loaded.\n"

                elif [ "$gf_status" == "IS" ]; then
                    gf_info "File ${GFC6}$gf_file${GFC0} reused.\n"

                elif [ "$gf_status" == "ESIU" ]; then
                    gf_warning "File ${GFC7}$gf_file${GFC0} loaded, not reused.\n"

                elif [ "$gf_status" == "EUIS" ]; then
                    gf_warning "File ${GFC6}$gf_file${GFC0} reused, not loaded.\n"

                elif [ "$gf_status" == "ES" ]; then
                    gf_error "File ${GFH6}$gf_file${GFC0} not found to reuse.\n"

                elif [ "$gf_status" == "EU" ]; then
                    gf_error "File ${GFH7}$gf_file${GFC0} not found.\n"
                fi
            fi

            # Restore saved global variables
            GF_SOURCE_FILE="$gf_parent_source_file"
            GF_FUNC_NAME="$gf_parent_func_name_source"
        else
            gf_info "Already loaded ${GFC7}$gf_file${GFC0} skipped.\n"
        fi
    fi

    GF_LAST_FILE_CONTENT="$gf_parent_last_file_content"
    eval "$(gf_revert_function)"
}

gf_help_command '
    {gf_save_source} <file> [-copy [<file>] [-internal]]
    Save content of any text {file} into $GF_RUN_DIR/scripts/*.sources.gf files.
    Optional {-copy} argument will save copy of file into ./in/ directory. File path inside ./in/ directory can be customized in {file} parameter.
    Option {-internal} used to save data into internal directory instead of working one (see -internal mode).
'
function gf_save_source {
    eval "$(gf_update_function)"

    # Process arguments
    local gf_file=
    local gf_copy=
    local gf_dir="$GF_RUN_DIR"
    while [ $# -gt 0 ]; do
        key="$1"; shift
        case "$key" in
            "-copy" )
                gf_copy="./in/"
            ;;
            "-internal" )
                gf_dir="$GF_I_RUN_DIR"
            ;;
            -* )
                gf_fatal "Incorrect ${GFH7}$key${GFC0} option."
            ;;
            * )
                if [ -z "$gf_file" ]; then
                    gf_file="$key"
                else
                    gf_copy="./in/$(echo "$key" | sed -e 's|^\./||; s|^/||')"
                fi
            ;;
        esac
    done

    # File name cannot be empty
    [[ -z "$gf_file" ]] && gf_fatal "Please specify source file to save."

    local gf_file_full_name=$(gf_full_path "$gf_file")
    local gf_file_short_name=$(gf_get_short_path "$gf_file_full_name")

    # Preload file content
    local gf_last_file="$GF_LAST_FILE"
    local gf_last_status="$GF_LAST_FILE_STATUS"
    local gf_last_content="$GF_LAST_FILE_CONTENT"
    gf_load_file_content "$gf_file"

    # Save content and show messages in normal mode only
    if [ -z "$GF_PRELOAD_MODE" ]; then

        # Save file content in execution mode
        gf_save_file_content "$gf_file" "$GF_LAST_FILE" "$GF_LAST_FILE_CONTENT"

        # Show messages
        if [ "$GF_LAST_FILE_STATUS" == "ES" ]; then
            gf_error "File content ${GFH6}$gf_file${GFC0} not found to resave.\n"

        elif [ "$GF_LAST_FILE_STATUS" == "EU" ]; then
            gf_error "File ${GFH7}$gf_file${GFC0} not found.\n"

        else
            if [ "$GF_LAST_FILE_STATUS" == "IU" ]; then
                gf_info "File content ${GFC7}$gf_file${GFC0} saved to sources."

            elif [ "$GF_LAST_FILE_STATUS" == "IS" ]; then
                gf_info "File content ${GFC6}$gf_file${GFC0} resaved to sources."

            elif [ "$GF_LAST_FILE_STATUS" == "EUIS" ]; then
                gf_warning "File content ${GFC6}$gf_file${GFC0} resaved to sources, not updated."

            elif [ "$GF_LAST_FILE_STATUS" == "ESIU" ]; then
                gf_warning "File content ${GFC7}$gf_file${GFC0} saved to sources, not reused."
            fi

            # Save content copy to file if required
            if [ -n "$gf_copy" ]; then
                [[ $gf_copy == */ ]] && gf_copy+="$(basename "$gf_file")"
                mkdir -p "$(dirname "$gf_dir/$gf_copy")"
                echo "$GF_LAST_FILE_CONTENT" > "$gf_dir/$gf_copy"
                [[ -e "$gf_file" ]] && touch -r "$gf_file" "$gf_dir/$gf_copy"

                if [ "$GF_LAST_FILE_STATUS" == "IU" -o "$GF_LAST_FILE_STATUS" == "ESIU" ]; then
                    gf_info "File ${GFC7}$gf_file_short_name${GFC0} copy saved to ${GFC7}$gf_copy${GFC0}."
                else
                    gf_info "File ${GFC7}$gf_file_short_name${GFC0} content copy saved to ${GFC7}$gf_copy${GFC0}."
                fi

            fi
        fi
    fi
    GF_LAST_FILE="$gf_last_file"
    GF_LAST_FILE_STATUS="$gf_last_status"
    GF_LAST_FILE_CONTENT="$gf_last_content"

    eval "$(gf_revert_function)"
}

# Check if option used
function gf_was_option_used {
    echo "$GF_USED_OPTIONS" | grep -e "^\($1\) \($2\)\$" || :
}

# Check if option can be redefined
# Syntax: gf_check_option {S | C} forbidden_options_grep_expr redefined_options_grep_expr
GF_CHECK_OPTION_LAST_STATUS=0
function gf_check_option {
    local source="$1"
    local forbidden_options="$2"
    local redefined_options="$3"
    local text="$4"

    if [ -z "$(gf_was_option_used "$source" "$forbidden_options")" ]; then
        [[ -z "$redefined_options" ]] && redefined_options="$forbidden_options"
        for option in $(echo "$(gf_was_option_used "." "$redefined_options")" | grep -o ' .\+$' | awk '!x[$1]++'); do
            if [ "$text" == "$option" ]; then
                gf_warning_message "Option ${GFC7}$text${GFC0} used several times."
            else
                gf_warning_message "Option ${GFC7}$text${GFC0} overrides ${GFC7}$option${GFC0} one."
            fi
        done
        GF_CHECK_OPTION_LAST_STATUS=1
    else
        if [ "$GF_OPTIONS_SOURCE" == "S" ]; then
            gf_warning_message "Option ${GFC7}$text${GFC0} ignored in the script."
        else
            gf_warning_message "Option ${GFC7}$text${GFC0} ignored."
        fi
        GF_CHECK_OPTION_LAST_STATUS=0
    fi
}

# Option parse script
gf_help_command '
    {gf_set_flow_options} [<options>] [-help]
    Specify command line options inside script.
    Synonyms: gf_set_flow_options, gf_use_option, gf_use_options
'
function gf_use_option { gf_warning "Command gf_use_option is obsolete. Use gf_set_flow_options $@ instead."; gf_set_flow_options "$@"; }
function gf_use_options { gf_warning "Command gf_use_options is obsolete. Use gf_set_flow_options $@ instead."; gf_set_flow_options "$@"; }
function gf_set_flow_options {
    eval "$(gf_update_function gf_set_flow_options)"

    # Forbidden option redefine direction
    local gf_forbidden_source="C"

    # Source information
    if [ "$GF_OPTIONS_SOURCE" == "C" ]; then
        GF_FUNC_NAME="gflow"
        gf_forbidden_source=
    fi

    # Parse arguments
    local key=
    local gf_next_key=
    while [ $# -gt 0 ]; do
        case "$1" in
            -* )
                key="$1"
                shift
            ;;
            * )
                if [ -n "$gf_next_key" ]; then
                    key="$gf_next_key"
                    gf_next_key=
                else
                    key="$1"
                    shift
                fi
            ;;
        esac

        # Last option is ok flag
        GF_CHECK_OPTION_LAST_STATUS=0

        # Parse options
        case "$key" in
            "-script" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-script' '' "$key $1"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_SCRIPT="$1"
                fi
            fi; shift;;

            "-ref" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-ref' '' "$key $1"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_REF_FILE="$1"
                fi
            fi; shift;;

            "-run" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                if [ "$(basename "$1")" == "$1" ]; then
                    gf_check_option "$gf_forbidden_source" '-run' '' "$key $1"
                    if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                        GF_RUN_NAME="$1"
                        [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Run name changed to ${GFC7}$GF_RUN_NAME$GF_RUN_SUFFIX${GFC0}."
                    fi
                else
                    gf_check_option "$gf_forbidden_source" '-dir\|-run\|-suffix\|-today\|-yesterday\|-now' '' "$key $1"
                    if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                        GF_WORK_DIR=$(dirname "$1")
                        GF_RUN_NAME=$(basename "$1")
                        GF_RUN_SUFFIX=
                        GF_RUN_AUTO_INCREMENT=
                        GF_USED_OPTIONS+="$GF_OPTIONS_SOURCE -dir"$'\n'
                        [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Working directory changed to ${GFC7}$GF_WORK_DIR${GFC0}."
                        [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Run name changed to ${GFC7}$GF_RUN_NAME${GFC0}."
                    fi
                fi
            fi; shift;;

            "-resume" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-suffix\|-today\|-yesterday\|-now\|-resume\|-last' '-suffix\|-today\|-yesterday\|-now\|-resume\|-last' "$key"
                GF_RUN_SUFFIX_RESUME=1
            fi;;

            "-last" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-suffix\|-today\|-yesterday\|-now\|-resume\|-last' '-suffix\|-today\|-yesterday\|-now\|-resume\|-last' "$key"
                GF_RUN_SUFFIX_RESUME=2
            fi;;

            "-dir" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-dir' '' "$key $1"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_WORK_DIR="$1"
                    [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Working directory changed to ${GFC7}$GF_WORK_DIR${GFC0}."
                fi
            fi; shift;;

            "-internal" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-internal' '' "$key $1"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_INT_DIR="$1"
                    [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Flow internal directory changed to ${GFC7}$GF_INT_DIR${GFC0}."
                fi
            fi; shift;;

            "-suffix" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-dir\|-run\|-suffix\|-today\|-yesterday\|-now\|-resume\|-last\|-clean' '-suffix\|-today\|-yesterday\|-now\|-resume\|-last' "$key $1"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    if [ -n "$1" ]; then
                        local gf_last_suffix="$GF_RUN_SUFFIX"
                        GF_RUN_SUFFIX=".$1"
                        if [ "$gf_last_suffix" != "$GF_RUN_SUFFIX" ]; then
                            [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Run suffix changed to ${GFC7}$GF_RUN_SUFFIX${GFC0}."
                        fi
                    elif [ -n "$GF_RUN_SUFFIX" ]; then
                        GF_RUN_SUFFIX=
                        [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Run suffix removed."
                    fi
                fi
            fi; shift;;

            "-tag" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                if [[ $1 =~ ^[a-zA-Z0-9_]+$ ]]; then
                    GF_TAG=".$1"
                    gf_info_message "Tasks tag changed to ${GFC7}$GF_TAG${GFC0}."
                else
                    gf_fatal "Tasks tag ${GFH7}$1${GFC0} contains non-alphanumeric characters."
                fi
                shift
            fi; shift;;

            "-today" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-dir\|-run\|-suffix\|-today\|-yesterday\|-now\|-resume\|-last\|-clean' '-suffix\|-today\|-yesterday\|-now\|-resume\|-last' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    local gf_last_suffix="$GF_RUN_SUFFIX"
                    GF_RUN_SUFFIX=".$(date +%m%d)"
                    if [ "$gf_last_suffix" != "$GF_RUN_SUFFIX" ]; then
                        [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Run suffix changed to today ${GFC7}$GF_RUN_SUFFIX${GFC0}."
                    fi
                fi
            fi;;

            "-yesterday" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-dir\|-run\|-suffix\|-today\|-yesterday\|-now\|-resume\|-last\|-clean' '-suffix\|-today\|-yesterday\|-now\|-resume\|-last' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    local gf_last_suffix="$GF_RUN_SUFFIX"
                    GF_RUN_SUFFIX=".$(date -d yesterday +%m%d)"
                    if [ "$gf_last_suffix" != "$GF_RUN_SUFFIX" ]; then
                        [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Run suffix changed to yesterday ${GFC7}$GF_RUN_SUFFIX${GFC0}."
                    fi
                fi
            fi;;

            "-now" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-dir\|-run\|-suffix\|-today\|-yesterday\|-now\|-resume\|-last\|-clean' '-suffix\|-today\|-yesterday\|-now\|-resume\|-last' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    local gf_last_suffix="$GF_RUN_SUFFIX"
                    GF_RUN_SUFFIX=".$(date +%m%d-%H.%M)"
                    if [ "$gf_last_suffix" != "$GF_RUN_SUFFIX" ]; then
                        [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Run suffix changed to now ${GFC7}$GF_RUN_SUFFIX${GFC0}."
                    fi
                fi
            fi;;

            "-reset" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-reset\|-new\|-save\|-continue' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_NEED_CLEAN=R
                    [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Reset and clean run mode activated."
                fi
            fi;;

            "-new" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-reset\|-new\|-save\|-continue' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_NEED_CLEAN=N
                    [[ -z "$GF_HELP_MODE" ]] && gf_info_message "New run mode activated."
                fi
            fi;;

            "-save" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-reset\|-new\|-save\|-continue' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_NEED_CLEAN=S
                    [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Save run mode activated."
                fi
            fi;;

            "-continue" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-reset\|-new\|-save\|-continue' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_NEED_CLEAN=C
                    [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Continue run mode activated."
                fi
            fi;;

            "-restart" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                GF_TASK_OPTIONS+="gf_set_task_option>$GF_TASK_OPTIONS_PRIORITY>*>-restart_mode"$'\n'"R"$'\n'
                # gf_check_option "$gf_forbidden_source" '-restart\|-skip\|-incr' '' "$key"
                # if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    # GF_NEED_RESTART_GLOBAL=R
                    # [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Restart executed tasks mode activated."
                # fi
            fi;;

            "-skip" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                GF_TASK_OPTIONS+="gf_set_task_option>$GF_TASK_OPTIONS_PRIORITY>*>-restart_mode"$'\n'"S"$'\n'
                # gf_check_option "$gf_forbidden_source" '-restart\|-skip\|-incr' '' "$key"
                # if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    # GF_NEED_RESTART_GLOBAL=S
                    # [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Ignore executed tasks mode activated."
                # fi
            fi;;

            "-incr" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                GF_TASK_OPTIONS+="gf_set_task_option>$GF_TASK_OPTIONS_PRIORITY>*>-restart_mode"$'\n'"I"$'\n'
                # gf_check_option "$gf_forbidden_source" '-restart\|-skip\|-incr' '' "$key"
                # if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    # GF_NEED_RESTART_GLOBAL=I
                    # [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Incremental tasks mode activated."
                # fi
            fi;;

            "-reuse" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-reuse\|-update' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_REF_CHOICE=SU
                    [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Reuse sources mode activated."
                fi
            fi;;

            "-update" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-reuse\|-update' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_REF_CHOICE=US
                    [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Use updated sources mode activated."
                fi
            fi;;

            "-no_win" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                if [ "$GF_OPTIONS_SOURCE" == "S"  ]; then
                    gf_warning_message "Option ${GFC7}$key${GFC0} ignored in the script."
                else
                    [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Option ${GFC7}$key${GFC0} used."
                fi
            fi;;

            "-debug" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                if [ -z "$GF_HELP_MODE" ]; then
                    gf_warning_message "Debug information will be written to ${GFC7}./tasks/run.debug${GFC0} file."
                    function gf_debug {
                        if [ -z "$GF_RUN_INDEX" ]; then
                            GF_DEBUG_INDEX0=$((GF_DEBUG_INDEX0+1))
                            local gf_id="I-$GF_DEBUG_INDEX0"
                        else
                            GF_DEBUG_INDEX=$((GF_DEBUG_INDEX+1))
                            local gf_id="$GF_RUN_INDEX-$GF_DEBUG_INDEX"
                        fi
                        for var in $@; do
                            GF_DEBUG_MESSAGES+="$gf_id - $GF_FUNC_NAME: $var = $(eval "echo \"{\$$var}\"")"$'\n'
                        done
                        if [ -n "$GF_I_RUN_DIR" -a -e "$GF_I_RUN_DIR/tasks/run.info" ]; then
                            echo -n "$GF_DEBUG_MESSAGES" >> "$GF_I_RUN_DIR/tasks/run.debug"
                            GF_DEBUG_MESSAGES=
                        fi
                        echo -e "\e[90;40m I \e[0;30m $GF_FUNC_NAME\e[30m - Debug record ${GFC5}$gf_id\e[30m - $@${GFC0}" 1>&2
                    }
                fi
            fi;;

            "-auto_close"|"-no_wait" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                GF_NO_WAIT_KEY=1
            fi;;

            "-h"|"-help"|"-info" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                if [ "$key" == "-info" ]; then
                    GF_HELP_MODE=INFO
                    [[ -z "$GF_REF_CHOICE" ]] && GF_REF_CHOICE=SU
                    gf_info_message "Interactive info mode activated. No scripts to be generated."
                else
                    GF_HELP_MODE=HELP
                    [[ -z "$GF_REF_CHOICE" ]] && GF_REF_CHOICE=SU
                    gf_info_message "Interactive help mode activated. No scripts to be generated."
                fi
                GF_HELP_FILTERS="$@"
                if [ -n "$GF_HELP_FILTERS" ]; then
                    local gf_filters=""
                    local gf_filter
                    for filter in "$@"; do
                        gf_filters+=" ${GFC7}$1${GFC0}"
                        shift
                    done
                    gf_info_message "Content filters are$gf_filters."
                fi
                break
            fi;;

            "-ask" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-task\|-tasks\|-enable\|-disable\|-ask' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_NEED_ASK_GLOBAL=A
                    [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Interactive task selection mode activated."
                fi
            fi;;

            "-choices" ) if [ -n "$GF_PRELOAD_MODE" ]; then
                gf_check_option "$gf_forbidden_source" '-choices' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_PREDEFINED_CHOICES="$(gf_escape_single_quotes "$(echo -e "$1=")")"
                    [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Interactive choices are ${GFC7}"$1"${GFC0}."

                fi
            fi; shift;;

            "-tasks"|"-task" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                gf_check_option "$gf_forbidden_source" '-task\|-tasks\|-enable\|-disable\|-ask' '-' "$key $1"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    local gf_task
                    GF_TASK_OPTIONS+="gf_set_task_option>$GF_TASK_OPTIONS_PRIORITY>*>-enable"$'\n'"0"$'\n'
                    gf_info "${GFC4}Specific${GFC0} tasks selected in command line."
                    for gf_task in "$1"; do
                        GF_TASK_OPTIONS+="gf_set_task_option>$GF_TASK_OPTIONS_PRIORITY>$gf_task>-enable"$'\n'"1"$'\n'
                        # if [ -z "$GF_CONTROL_TASKS_CMD_LINE" ]; then
                            # GF_CONTROL_TASKS_CMD_LINE+="NE=* "
                            # gf_info "${GFC4}All${GFC0} tasks disabled in command line."
                        # fi
                        # GF_CONTROL_TASKS_CMD_LINE+="EN=$gf_task "
                    done
                    if [ -n "$(echo "$1" | sed -ne '/[\*\? ]/p')" ]; then
                        gf_info_message "Tasks ${GFC4}$(echo "$1")${GFC0} enabled in command line."
                    else
                        gf_info_message "Task ${GFC4}$(echo "$1")${GFC0} enabled in command line."
                    fi
                fi
            fi; gf_next_key="$key"; shift;;

            "-enable" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                gf_check_option "$gf_forbidden_source" '-task\|-tasks\|-enable\|-disable\|-ask' '-' "$key $1"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    local gf_task
                    for gf_task in $1; do
                        GF_TASK_OPTIONS+="gf_set_task_option>$GF_TASK_OPTIONS_PRIORITY>$gf_task>-enable"$'\n'"1"$'\n'
                        # GF_CONTROL_TASKS_CMD_LINE+="EN=$gf_task "
                    done
                    if [ -n "$(echo "$1" | sed -ne '/[\*\? ]/p')" ]; then
                        gf_info_message "Tasks ${GFC4}$(echo "$1")${GFC0} enabled in command line."
                    else
                        gf_info_message "Task ${GFC4}$(echo "$1")${GFC0} enabled in command line."
                    fi
                fi
            fi; gf_next_key="$key"; shift;;

            "-disable" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                gf_check_option "$gf_forbidden_source" '-task\|-tasks\|-enable\|-disable\|-ask' '-' "$key $1"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    local gf_task
                    for gf_task in $1; do
                        GF_TASK_OPTIONS+="gf_set_task_option>$GF_TASK_OPTIONS_PRIORITY>$gf_task>-enable"$'\n'"0"$'\n'
                        # GF_CONTROL_TASKS_CMD_LINE+="NE=$gf_task "
                    done
                    if [ -n "$(echo "$1" | sed -ne '/[\*\? ]/p')" ]; then
                        gf_info_message "Tasks ${GFC4}$(echo "$1")${GFC0} disabled in command line."
                    else
                        gf_info_message "Task ${GFC4}$(echo "$1")${GFC0} disabled in command line."
                    fi
                fi
            fi; gf_next_key="$key"; shift;;

            "-gen" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                GF_GEN_ONLY=1
                [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Generate only mode activated."
            fi;;

            "-local" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                gf_check_option "$gf_forbidden_source" '-local\|-sge\|-lsf' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_TASK_OPTIONS+="gf_set_task_option>$GF_TASK_OPTIONS_PRIORITY>*>-grid"$'\n'""$'\n'
                    # GF_GRID_MODE_GLOBAL=
                    [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Local task distribution mode activated."
                fi
            fi;;

            "-sge" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                gf_check_option "$gf_forbidden_source" '-local\|-sge\|-lsf' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    if [ -z "$(which qsub 2> /dev/null)" ]; then
                        gf_fatal "SGE mode cannot be activated. No path to ${GFH7}qsub${GFC0} command."
                    else
                        GF_TASK_OPTIONS+="gf_set_task_option>$GF_TASK_OPTIONS_PRIORITY>*>-grid"$'\n'"sge"$'\n'
                        # GF_GRID_MODE_GLOBAL=SGE
                        [[ -z "$GF_HELP_MODE" ]] && gf_info_message "SGE mode activated."
                    fi
                fi
            fi;;

            "-lsf" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                gf_check_option "$gf_forbidden_source" '-local\|-sge\|-lsf' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    if [ -z "$(which bsub 2> /dev/null)" ]; then
                        gf_fatal "LSF mode cannot be activated. No path to ${GFH7}bsub${GFC0} command."
                    else
                        GF_TASK_OPTIONS+="gf_set_task_option>$GF_TASK_OPTIONS_PRIORITY>*>-grid"$'\n'"lsf"$'\n'
                        # GF_GRID_MODE_GLOBAL=LSF
                        [[ -z "$GF_HELP_MODE" ]] && gf_info_message "LSF mode activated."
                    fi
                fi
            fi;;

            "-sge_options" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                gf_check_option "$gf_forbidden_source" '-sge_options' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    if [ -z "$(echo "$1" | grep -e '$GF_TASK_CPU\b' -e '${GF_TASK_CPU}' || :)" ]; then
                        gf_fatal "Option ${GFC7}$key${GFC0} value ${GFC7}$1${GFC0} should contain ${GFH7}\$GF_TASK_CPU${GFC0} variable. Use single quotes to avoid substitution."
                    elif [ -z "$(echo "$1" | grep -e '$GF_TASK_MEM\b' -e '${GF_TASK_MEM}' || :)" ]; then
                        gf_fatal "Option ${GFC7}$key${GFC0} value ${GFC7}$1${GFC0} should contain ${GFH7}\$GF_TASK_MEM${GFC0} variable. Use single quotes to avoid substitution."
                    else
                        GF_TASK_OPTIONS+="gf_set_task_option>$GF_TASK_OPTIONS_PRIORITY>*>-sge_options"$'\n'"$1"$'\n'
                        # GF_SGE_OPTIONS="$1"
                        [[ -z "$GF_HELP_MODE" ]] && gf_info_message "SGE options ${GFC7}$1${GFC0} used."
                    fi
                fi
            fi; shift;;

            "-lsf_options" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                gf_check_option "$gf_forbidden_source" '-lsf_options' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    if [ -z "$(echo "$1" | grep -e '$GF_TASK_CPU\b' -e '${GF_TASK_CPU}' || :)" ]; then
                        gf_fatal "Option ${GFC7}$key${GFC0} value ${GFC7}$1${GFC0} should contain ${GFH7}\$GF_TASK_CPU${GFC0} variable. Use single quotes to avoid substitution."
                    elif [ -z "$(echo "$1" | grep -e '$GF_TASK_MEM\b' -e '${GF_TASK_MEM}' || :)" ]; then
                        gf_fatal "Option ${GFC7}$key${GFC0} value ${GFC7}$1${GFC0} should contain ${GFH7}\$GF_TASK_MEM${GFC0} variable. Use single quotes to avoid substitution."
                    else
                        GF_TASK_OPTIONS+="gf_set_task_option>$GF_TASK_OPTIONS_PRIORITY>*>-lsf_options"$'\n'"$1"$'\n'
                        # GF_LSF_OPTIONS="$1"
                        [[ -z "$GF_HELP_MODE" ]] && gf_info_message "LSF options ${GFC7}$1${GFC0} used."
                    fi
                fi
            fi; shift;;

            "-hide"|"-bg"|"-background" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                GF_BACKGROUND_MODE=1
                [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Main window will be hidden while flow is running."
            fi;;

            "-silent" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                GF_SILENT=1
                [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Silent mode activated. Tool output can be found in log files."
            fi;;

            "-shell" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                gf_check_option "$gf_forbidden_source" '-shell' '' "$key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    SHELL="$1"
                    [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Shell ${GFC7}$SHELL${GFC0} will be default for the tasks."
                fi
            fi; shift;;

            "-verbose" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                GF_VERBOSE_MODE=1
                [[ -z "$GF_VERBOSE_LINES" ]] && GF_VERBOSE_LINES=10
            fi;;

            "-skip_errors" )
                GF_SKIP_ERRORS_MODE=1
                gf_info_message "Skip script errors and continue mode activated."
            ;;

            "-lines" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                if [[ $1 =~ ^[0-9]+$ ]]; then
                    GF_VERBOSE_LINES="$1"
                else
                    gf_fatal "Option ${GFC7}$key${GFC0} value ${GFH7}$1${GFC0} is not a number."
                fi
            fi; shift;;

            "-utils"|"-tools" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                break
            fi; shift;;

            "-smooth"|"-white"|"-focus"|"-raise"|"-clean"|"-sync" ) if [ -z "$GF_PRELOAD_MODE"  -o "$GF_OPTIONS_SOURCE" == "C" ]; then
                [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Option ${GFC7}$key${GFC0} used."
            fi;;

            -* )
                gf_fatal "Incorrect ${GFH7}$key${GFC0} option. Run ${GFH7}$GF_BIN_FILE -help${GFC0} for more info."
            ;;

            * )
                gf_check_option "$gf_forbidden_source" '-script' '' "-script $key"
                if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
                    GF_SCRIPT="$key"
                    key="-script"
                fi
            ;;
        esac

        # Remember used option
        if [ $GF_CHECK_OPTION_LAST_STATUS == 1 ]; then
            GF_USED_OPTIONS+="$GF_OPTIONS_SOURCE $key"$'\n'
        fi
    done

    eval "$(gf_revert_function)"
}

# Perl script to parse task options
gf_get_task_option_perl='
    my $task = shift;
    my $option = shift;
    my $value = ""; my $is_value = 0;
    my $priority = -1;
    while (<STDIN>) {
        s/\n$//;
        if (/^gf_set_task_option\>(\d+)\>([^\>]+)\>(\-\w+)/) {
            $is_value = 0;
            my $current_priority = $1;
            my $current_pattern = $2;
            my $current_option = $3;
            if (($current_option eq $option) && (($current_priority <= $priority) || ($priority<0))) {
                $current_pattern =~ s|\?|.|g;
                $current_pattern =~ s|\*|.*|g;
                if ($task =~ m|^$current_pattern$|) {
                    $priority = $current_priority;
                    $value = "";
                    $is_value = 1
                }
            }
        } elsif ($is_value == 1) {
            $value = $_;
            $is_value = 2;
        } elsif ($is_value == 2) {
            $value .= "\n".$_;
        }
    }
    print $value;
'

# Option parse script
gf_help_command '
    {gf_set_task_options} [[-tasks] <pattern>] [-enable|-disable] [-local|-sge|-lsf] [-cpu <cpu>] [-mem <mem>] [-sge_options <grid_options>|-lsf_options <grid_options>] [-restart|-skip|-incr] [-group <group> [-parallel <count>]
    Specify default tasks options inside script.
    Options applied to the tasks by {pattern}.
        If no pattern specified, options applied to {all} tasks.
    CPU and MEM usage can be set with {-cpu} and {-mem} options.
    Task-specific grid engine can be selected with one of {-local}, {-sge} or {-lsf} options.
    Task-specific grid engine options can be set with {-sge_options} or {-lsf_options} arguments.
    Option {-restart} can be used to automatically restart the task if it is running or done.
    Option {-skip} can be used to automatically skip the task if it is running or done.
    Option {-incr} can be used to automatically start the task in incremental mode.
    Options {-group} and {-parallel} can be used to limit tasks of the same running at the same time.
'
function gf_set_task_options {
    eval "$(gf_update_function gf_set_task_options)"

    # Parse options
    local gf_options=
    local gf_next_key=
    local gf_key=
    local gf_tasks=
    local gf_status=
    while [ $# -gt 0 -a -z "$gf_next_key" ]; do
        if [ -n "$gf_next_key" ]; then
            gf_key="$gf_next_key"
            gf_next_key=
        else
            gf_key="$1"
            shift
        fi
        case "$gf_key" in
            -task|-tasks )
                if [[ $1 =~ ^[a-zA-Z0-9_\*\?]+$ ]]; then
                    gf_options+="gf_record>-tasks>$1"$'\n'
                    gf_tasks+="$1 "
                elif [ -z "$1" ]; then
                    gf_fatal "Empty ${GFH7}$gf_key${GFC0} value."
                else
                    gf_fatal "Incorrect ${GFH7}$1${GFC0} task pattern."
                fi
                shift
            ;;
            -cpu|-cpus )
                if [[ $1 =~ ^[0-9]+$ ]]; then
                    gf_options+="gf_record>-cpu>$1"$'\n'
                    gf_status+="$gf_key $1 "
                elif [ -z "$1" ]; then
                    gf_fatal "Empty ${GFH7}$gf_key${GFC0} value."
                else
                    gf_fatal "Value $gf_key ${GFH7}$1${GFC0} is not a number."
                fi
                shift
            ;;
            -mem|-ram )
                if [[ $1 =~ ^[0-9]+$ ]]; then
                    gf_options+="gf_record>-mem>$1"$'\n'
                    gf_status+="$gf_key $1 "
                elif [ -z "$1" ]; then
                    gf_fatal "Empty ${GFH7}$gf_key${GFC0} value."
                else
                    gf_fatal "Value $gf_key ${GFH7}$1${GFC0} is not a number."
                fi
                shift
            ;;
            -group )
                if [[ $1 =~ ^[a-zA-Z0-9_\*\?]+$ ]]; then
                    gf_options+="gf_record>-group>$1"$'\n'
                    gf_status+="$gf_key $1 "
                elif [ -z "$1" ]; then
                    gf_fatal "Empty ${GFH7}$gf_key${GFC0} value."
                else
                    gf_fatal "Option $gf_key ${GFH7}$1${GFC0} contains non-alphanumeric characters."
                fi
                shift
            ;;
            -parallel )
                if [[ $1 =~ ^[0-9]+$ ]]; then
                    gf_options+="gf_record>-parallel>$1"$'\n'
                    gf_status+="$gf_key $1 "
                elif [ -z "$1" ]; then
                    gf_fatal "Empty ${GFH7}$gf_key${GFC0} value."
                else
                    gf_fatal "Value $gf_key ${GFH7}$1${GFC0} is not a number."
                fi
                shift
            ;;
            -en|-enable )
                gf_options+="gf_record>-enable>1"$'\n'
                gf_status+="$gf_key "
            ;;
            -dis|-disable )
                gf_options+="gf_record>-enable>0"$'\n'
                gf_status+="$gf_key "
            ;;
            -local )
                gf_options+="gf_record>-grid>"$'\n'
                gf_status+="$gf_key "
            ;;
            -sge )
                gf_options+="gf_record>-grid>sge"$'\n'
                gf_status+="$gf_key "
            ;;
            -lsf )
                gf_options+="gf_record>-grid>lsf"$'\n'
                gf_status+="$gf_key "
            ;;
            -sge_options|-lsf_options )
                if [ -z "$(echo "$1" | grep -e '$GF_TASK_CPU\b' -e '${GF_TASK_CPU}' || :)" ]; then
                    gf_fatal "Option ${GFC7}$gf_key${GFC0} value ${GFC7}$1${GFC0} should contain ${GFH7}\$GF_TASK_CPU${GFC0} variable. Use single quotes to avoid substitution."
                elif [ -z "$(echo "$1" | grep -e '$GF_TASK_MEM\b' -e '${GF_TASK_MEM}' || :)" ]; then
                    gf_fatal "Option ${GFC7}$gf_key${GFC0} value ${GFC7}$1${GFC0} should contain ${GFH7}\$GF_TASK_MEM${GFC0} variable. Use single quotes to avoid substitution."
                else
                    gf_options+="gf_record>$gf_key>$1"$'\n'
                    gf_status+="$gf_key $1 "
                fi
                shift
            ;;
            -restart )
                gf_options+="gf_record>-restart_mode>R"$'\n'
                gf_status+="$gf_key "
            ;;
            -skip )
                gf_options+="gf_record>-restart_mode>S"$'\n'
                gf_status+="$gf_key "
            ;;
            -incr|-incremental )
                gf_options+="gf_record>-restart_mode>I"$'\n'
                gf_status+="$gf_key "
            ;;
            -silent )
                gf_options+="gf_record>-silent>1"$'\n'
                gf_status+="$gf_key "
            ;;
            -* )
                gf_fatal "Incorrect ${GFH7}$gf_key${GFC0} option."
            ;;
            * )
                if [[ $gf_key =~ ^[a-zA-Z0-9_\*\?]+$ ]]; then
                    gf_options+="gf_record>-tasks>$gf_key"$'\n'
                    gf_tasks+="$gf_key "
                else
                    gf_fatal "Incorrect ${GFH7}$gf_key${GFC0} task pattern."
                fi
            ;;
        esac
    done

    # Options records
    GF_TASK_OPTIONS+="$(echo "$gf_options" | perl -e '
        my $priority = shift;
        my $key = ""; my %data; my @keys; my @tasks;
        my $counter = -1;
        while (<STDIN>) {
            s/\n$//;
            if (s/^gf_record\>(\-\w+)\>//) {
                $key = $1;
                if ($key eq "-tasks") {
                    push @tasks, $_;
                } else {
                    push @keys, $1 if (!defined $data{$key});
                    $data{$key} = $_;
                }
            } else {
                $data{$key} .= "\n".$_;
            }
        }

        push @tasks, "*" if ($#tasks<0);
        foreach my $key (@keys) {
            foreach my $task (@tasks) {
                print "gf_set_task_option>$priority>$task>$key\n$data{$key}\n";
            }
        }
    ' $GF_TASK_OPTIONS_PRIORITY)"$'\n'

    # Info message
    if [ -z "$gf_tasks" ]; then
        gf_info "${GFC4}*${GFC0} tasks will use ${GFC7}$(echo $gf_status)${GFC0} options."
    elif [ -n "$(echo $gf_tasks | sed -ne '/[\*\? ]/p')" ]; then
        gf_info "${GFC4}$(echo $gf_tasks)${GFC0} tasks will use ${GFC7}$(echo $gf_status)${GFC0} options."
    else
        gf_info "${GFC4}$(echo $gf_tasks)${GFC0} task will use ${GFC7}$(echo $gf_status)${GFC0} options."
    fi

    eval "$(gf_revert_function)"
}

##################################################
gf_help_section "Tool commands"
##################################################

# Append tool argument if not used
gf_help_command '
    {gf_add_tool_arguments} <arguments> [...]
    Append additional tool command line {arguments}.
    Synonyms: gf_add_tool_argument, gf_add_tool_arguments
'
function gf_add_tool_argument { gf_add_tool_arguments "$@"; }
function gf_add_tool_arguments {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function gf_add_tool_argument)"

    gf_check_task_name

    local gf_arg
    for gf_arg in "$@"; do
        if [ -n "$gf_arg" -a -z "$(echo -e "$GF_TASK_ARGS" | grep -Fx -- "$gf_arg")" ]; then
            GF_TASK_ARGS+="$gf_arg\n"
            gf_info "Argument ${GFC7}$gf_arg${GFC0} added."
        fi
    done

    eval "$(gf_revert_function)"
}

# Add initialization or post-processing shell commands
gf_help_command '
    {gf_add_shell_commands} -init | -post '"'"'<commands>'"'"'
    Add shell multi-line {commands} to be executed before or after the main tool.
    It is required to use one of {-init} or {-post} option indicating when to run commands.
    Commands {-init} are executed before the tool starts.
        Typically used to initialize shell environment or load required modules.
    Commands {-post} are executed after the tool starts.
        Typically used to post-process results.
    Flow steps can be pasted inside {commands} using {`gf_paste_step step`} or {`@step`} syntax.
    Flow or shell variables can be substituted in {commands} using {`$variable`} syntax.
    Example:
        gf_add_shell_commands -init '"'"'
            export VAR=VALUE
            `@flow_step`
            `$flow_variable`
        '"'"'
'
function gf_add_shell_commands {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function)"

    gf_check_task_name

    # Add commands
    local gf_command_type=
    local gf_key=
    while [ $# -gt 0 ]; do
        gf_key="$1"; shift
        case "$gf_key" in
            "-init" )
                gf_command_type="init"
            ;;
            "-post" )
                gf_command_type="post"
            ;;
            * )
                if [ -n "$gf_command_type" ]; then
                    gf_debug gf_key
                    if [ -z "$(echo "$gf_key" | grep -e '\<PLACEHOLDER' | grep -v '^\s*#')" ]; then
                        if [ "$gf_command_type" == "init" ]; then
                            # GF_TASK_INIT+="$(gf_auto_tab_commands "$gf_key")"$'\n'
                            GF_TASK_INIT+="$(gf_auto_tab_commands "$(gf_expand_content '' "$gf_key")")"$'\n'
                        elif [ "$gf_command_type" == "post" ]; then
                            # GF_TASK_DONE+="$(gf_auto_tab_commands "$gf_key")"$'\n'
                            GF_TASK_DONE+="$(gf_auto_tab_commands "$(gf_expand_content '' "$gf_key")")"$'\n'
                        fi
                        gf_print_commands_info "$gf_key" "$GF_RUN_DIR/tasks/$TASK_NAME/run"
                    else
                        gf_fatal "Shell commands contains placeholders:"$'\n'"${GFH7}$(echo "$gf_key" | grep -e '\<PLACEHOLDER' | grep -v '^\s*#')${GFC0}."
                    fi
                else
                    gf_fatal "One of ${GFH7}-init${GFC0} or ${GFH7}-post${GFC0} arguments is required."
                fi
            ;;
        esac
    done

    eval "$(gf_revert_function)"
}

# Send e-mail when all is done
gf_help_command '
{gf_add_status_email} [-subject <subject>] [-message <message>] [-to <e-mail> ... ] [-files <file> ...] [-smtp <server>] [-port <port>]
    Send e-mail with specified {subject} and multi-line {message}.
    Default {message} contatins information about current task.
    Default {subject} contains task name, current user name and run directory.
    Default recipient {e-mail} is current user name. Suffix @<domainname> can be skipped for local users.
    User {file} can be attached. File paths are relative to current task working directory. Multiple fiels allowed.
    Default SMTP {server} to send e-mails are smtp.<domainname> or mail.<domainname>.
    Default SMTP {port} is 25.
    Examples:
        gf_add_status_email
        gf_add_status_email -subject "Task $TASK_NAME completed" -to user@domain.com -smtp mail.domain.com -port 25
'
function gf_add_status_email {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function)"

    local key
    local gf_flow_step gf_flow_steps
    local gf_pasted_steps=

    gf_check_task_name

    local gf_arg=
    local gf_subject=
    local gf_message=
    local gf_to=
    local gf_files=
    local gf_smtp=
    local gf_port=25
    while [ $# -gt 0 ]; do
        case "$1" in
            "-to"|"-file"|"-files" )
                key="$1"
                last_key="$1"
                shift
            ;;
            "-subject"|"-message"|"-smtp"|"-port" )
                key="$1"
                last_key=""
                shift
            ;;
            * )
                key="$last_key"
            ;;
        esac
        case "$key" in
            "-subject" )
                gf_subject="$1"; shift
            ;;
            "-message" )
                gf_message+="$1"$'\n'; shift
            ;;
            "-to" )
                gf_to+="$1"$'\n'; shift
            ;;
            "-file"|"-files" )
                gf_files+="$(echo "$1" | sed -e 's/\(\s\)/\\\1/g;') "; shift
            ;;
            "-smtp" )
                gf_smtp+="$1 "; shift
            ;;
            "-port" )
                gf_port+="$1"$'\n'; shift
            ;;
            -* )
                gf_fatal "Incorrect ${GFH7}$key${GFC0} option used."
            ;;
            * )
                gf_message+="$1"$'\n'; shift
            ;;
        esac
    done

    [[ -z "$gf_subject" ]] && gf_subject="Task $TASK_NAME \$gf_current_task_status"
    [[ -z "$gf_message" ]] && gf_message="See $GF_RUN_DIR/<b>logs/$TASK_NAME.log</b> for details."
    [[ -z "$gf_to" ]] && gf_to="\$USER"
    [[ -z "$gf_smtp" ]] && gf_smtp="smtp.$(domainname)"$'\n'"mail.$(domainname)"$'\n'
    [[ -z "$gf_port" ]] && gf_port=25

    local gf_email_commands='        # Send status e-mail
        SMTP=
        errors=
        for server in '"$(echo $gf_smtp)"'; do
            if [ -n "$(ping -c 1 $server 2> /dev/null | grep "1 received")" ]; then
                SMTP=$server
                break
            fi
        done
        if [ -n "$SMTP" ]; then
            echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH3}''"$TASK_NAME"''${GFC0}' is sending e-mail ..."
            { \
                echo "open $SMTP '"$gf_port"'"; sleep 2; \
                echo "HELO $USER"; sleep 1; \
                echo "MAIL FROM: $USER@$(domainname)"; sleep 1; \
                for user in '"$gf_to"'; do
                    echo "RCPT TO: $user"; sleep 1; \
                done
                echo "DATA"; sleep 1; \
                echo "Subject: '"$gf_subject"'"; \
                echo "From: $HOSTNAME<$USER@$(domainname)>"; \
                for user in '"$gf_to"'; do
                    [[ $user != *@* ]] && user+="@$(domainname)"; \
                    echo "To: $user"; \
                done
                echo "Mime-Version: 1.0;"; \
                echo "Content-Type: multipart/mixed; boundary=_email_sep_text_"; \
                echo "--_email_sep_text_"; \
                echo "Content-Type: text/html; charset=\"ISO-8859-1\";"; \
                echo "Content-Transfer-Encoding: 7bit;"; \
                echo "<html xmlns=\"http://www.w3.org/TR/REC-html40\"><head>"; \
                echo "<style>p{font-size:11.0pt;font-family:\"Calibri\",\"sans-serif\";margin:0cm;margin-bottom:.0001pt;margin-left:120.0pt;text-indent:-120.0pt;tab-stops: 120.0pt;text-autospace:none;padding:3.0pt 0cm 0cm 0cm;}</style>"; \
                echo "</head><body>"; \
                echo "'"$(echo "$gf_message" | perl -e 'while (<STDIN>) {s|\s*$||; print "<p>$_</p>" if ($_)}')"'"; \
                echo "</body></html>"; \
                for gf_file in '"$gf_files"'; do
                    echo "--_email_sep_text_"; \
                    echo "Content-Type: text/x-log; name=\"$(basename "$gf_file")\""; \
                    echo "Content-Disposition: attachment; filename=\"$(basename "$gf_file")\""; \
                    echo "Content-Transfer-Encoding: base64"; \
                    echo ; \
                    cat "$gf_file" 2>&1 | base64; \
                done
                echo "--_email_sep_text_--"; \
                echo "."; sleep 1; \
                echo quit; \
            } | telnet >> "$GF_I_RUN_DIR/tasks/run.log" 2>&1
        else
            echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH1}''"$TASK_NAME"''${GFC0}' SMTP is incorrect. Check '"${FUNCNAME[0]}"' -smtp option"
        fi
    '

    gf_email_commands="$(gf_auto_tab_commands "$gf_email_commands")"$'\n'$'\n'

    # Add email commands
    gf_debug gf_email_commands
    gf_print_commands_info "$gf_email_commands" "$GF_I_RUN_DIR/tasks/submit.$TASK_NAME.sh"
    GF_TASK_DONE_SCRIPT+="$gf_email_commands"

    eval "$(gf_revert_function)"
}

# Add tool commands
gf_help_command '
    {gf_add_tool_commands} [-ext <file_ext>]|[-file <file_name>] [-arg <tool_arg>] [-comment <symbol>] '"'"'<commands>'"'"'
    Append tool commands to the task script with multi-line {commands} option.
    File name or extension should be set with
    Use {-file} or {-ext} option to control script file name or extension.
    Script file name is $TASK_NAME.script by default if not redefined in {gf_use_*}commands
        by setting {GF_TOOL_SCRIPT} variable manually.
    Once script file name redefined it will be used as default in current task scope.
    Tool arguments can be specified with {tool_arg} option.
    Optional {-comment} argument can be used to set symbols indicating comment line
        to put additional information like pasted steps info.
    Flow steps can be pasted inside {commands} using {`gf_paste_step step`} or {`@step`} syntax.
    Flow or shell variables can be substituted in {commands} using {`$variable`} syntax.
    Example:
        gf_add_tool_commands -ext "sh" -arg "-e" -comment "#" '"'"'
            # This is a bash script
            `@flow_step`
            `$flow_variable`
        '"'"'
'
function gf_add_tool_commands {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function gf_add_script_command gf_add_script_commands gf_add_tool_commands)"

    local key
    local gf_flow_step gf_flow_steps
    local gf_pasted_steps=

    gf_check_task_name

    local gf_arg=
    local gf_file=
    local gf_tool_commands=
    local gf_task_comment=
    local gf_task_comment_new=
    while [ $# -gt 0 ]; do
        key="$1"; shift
        case "$key" in
            "-arg" )
                gf_task_comment_new=1
                gf_arg="$1"; shift
            ;;
            "-file" )
                gf_task_comment_new=1
                gf_file="$1"; shift
            ;;
            "-ext" )
                gf_task_comment_new=1
                if [[ $1 == .* ]]; then
                    gf_file="$TASK_NAME$1"
                else
                    gf_file="$TASK_NAME.$1"
                fi
                shift
            ;;
            "-comment" )
                gf_task_comment_new=1
                gf_task_comment="$1"; shift
            ;;
            -* )
                gf_fatal "Incorrect ${GFH7}$key${GFC0} option used."
            ;;
            * )
                gf_tool_commands+=$'\n'"$key"
            ;;
        esac
    done

    # Save current file extension and task argument
    if [ -n "$gf_file" ]; then
        GF_TASK_SCRIPT="$gf_file"
        GF_TASK_ARG="$gf_arg"

    # Default file extension and task argument
    elif [ -n "$GF_TOOL_SCRIPT" ]; then
        gf_file="$GF_TOOL_SCRIPT"
        gf_arg="$GF_TOOL_ARG"

    # Previous file extension and task argument
    elif [ -n "$GF_TASK_SCRIPT" ]; then
        gf_file="$GF_TASK_SCRIPT"
        gf_arg="$GF_TASK_ARG"

    # Default script name
    else
        gf_file="$TASK_NAME.script"
    fi

    # Create file in ./scripts directory if not specified
    if [ "$(dirname $gf_file)" == "." ]; then
        gf_file="./scripts/$gf_file"
    fi

    # Comment symbol for pasted steps info
    if [ -n "$gf_task_comment_new" ]; then
        GF_TASK_COMMENT="$gf_task_comment"
        if [ -z "$GF_TASK_COMMENT" -a "$gf_file" == "$GF_TOOL_SCRIPT" ]; then
            GF_TASK_COMMENT="$GF_TOOL_COMMENT"
        fi
    fi

    # Paste flow steps
    local spaces_count=$(echo "$gf_tool_commands" | perl -e '
        my $count = 0;
        while (<STDIN>) {
            if (/^(\s*)\S/) {
                $count = length($1);
            } else {
                $count = (length($_) + 3);
            }
        }
        print $count;
    ')

    # Create new file if not used before
    local gf_file_used="$(echo "$GF_TASK_SCRIPTS" | grep -Fx -- "$gf_file" || :)"
    if [ -z "$gf_file_used" ]; then
        mkdir -p "$GF_RUN_DIR/$(dirname "$gf_file")"
        echo -n > "$GF_RUN_DIR/$gf_file"
        gf_info "New command file ${GFC7}$gf_file${GFC0} created."

        # Remember used file name
        GF_TASK_SCRIPTS+="$gf_file"$'\n'
    fi
    gf_debug gf_file_used GF_TASK_SCRIPTS

    # Expand steps and variables
    gf_tool_commands="$(gf_expand_content "$GF_TASK_COMMENT" "$gf_tool_commands")"

    # Tabulate commands
    gf_tool_commands="$(gf_auto_tab_commands "$gf_tool_commands" $spaces_count)"

    # Command check
    [[ -z "$gf_tool_commands" ]] && gf_error "Commands are empty."

    # Append tool argument if not used
    [[ -n "$gf_arg" ]] && gf_add_tool_arguments "$gf_arg $gf_file"

    # Write auto-tabbed commands to file
    echo "$gf_tool_commands"$'\n' >> "$GF_RUN_DIR/$gf_file"

    # Print status message
    gf_debug gf_tool_commands
    gf_print_commands_info "$gf_tool_commands\n" "$GF_RUN_DIR/$gf_file"

    eval "$(gf_revert_function)"
}

##################################################
gf_help_section "Flow variables and steps"
##################################################

# Create flow step or variable record
function gf_create_step_record {
    # $1 : command (gf_step)
    # $2 : name
    # $3 : source file
    # $4 : content
    echo "$1>$2>gf_file>$3"$'\n'"$4<$1"
}
gf_help_command '
    {gf_create_step} [-name] <name> [-redefine|-keep] [-commands] '"'"'<commands>'"'"'
    Create flow step {name} with {commands} to be pasted into the script later.
    Command will not show warning if step has been already defined but {-redefine} option used.
    Option {-keep} used to keep previous step content if already defined.
    Flow steps can be pasted inside {commands} using {`gf_paste_step step`} or {`@step`} syntax.
    Flow or shell variables can be substituted in {commands} using {`$variable`} syntax.
    Example:
        flow_variable="value"
        gf_create_step -name flow_step '"'"'
            echo "Initializing..."
            {`@another_flow_step`}
            `$flow_variable`
        '"'"'
'
function gf_create_step {
    eval "$(gf_update_function)"

    local key

    # Parse command line
    local gf_step_commands=
    local gf_step_name=
    local gf_step_redefine=
    while [ $# -gt 0 ]; do
        key="$1"; shift
        case "$key" in
            "-redefine" )
                gf_step_redefine=1
            ;;
            "-keep" )
                gf_step_redefine=0
            ;;
            "-name" )
                gf_step_name=$(echo "$1" | sed -e 's/^gf_step_//; s/[ \t]\+/_/g')
                shift
            ;;
            "-commands" )
                continue
            ;;
            -[A-Za-z]* )
                gf_fatal "Incorrect ${GFH7}$key${GFC0} option."
            ;;
            * )
                if [ -z "$(echo "$key" | grep -e ' ' || :)" -a -z "$gf_step_name" ]; then
                    gf_step_name=$(echo "$key" | sed -e 's/^gf_step_//; s/[ \t]\+/_/g')
                else
                    gf_step_commands+=$'\n'"$key"
                fi
            ;;
        esac
    done

    # Check if step name is not empty
    if [ -z "$gf_step_name" ]; then
        gf_fatal "Step name is empty. Use ${GFH7}-name${GFC0} option."
    fi

    # Check if step name is not empty
    if [ -z "$gf_step_commands" ]; then
        gf_warning_message "Step commands are empty."

    # Define step
    else

        # Status message
        local gf_no_redefine=
        if [ -n "$(echo "$GF_FLOW_STEPS" | grep -e "^gf_step>$gf_step_name>gf_file>" || :)" ]; then
            if [ -z "$gf_step_redefine" ]; then
                gf_warning_message "Step ${GFC7}$gf_step_name${GFC0} redefined."
            elif [ "$gf_step_redefine" == 1 ]; then
                gf_info_message "Step ${GFC7}$gf_step_name${GFC0} redefined."
            else
                gf_info_message "Step ${GFC7}$gf_step_name${GFC0} kept unchanged."
                gf_no_redefine=1
            fi
        else
            gf_info_message "Step ${GFC7}$gf_step_name${GFC0} defined."
        fi

        # Define step if required
        if [ -z "$gf_no_redefine" ]; then
            GF_FLOW_STEPS+="$(gf_create_step_record gf_step "$gf_step_name" "$GF_SOURCE_FILE" "$(gf_auto_tab_commands "$gf_step_commands")")"$'\n'
        fi
   fi

    eval "$(gf_revert_function)"
}

# Process content - paste steps and variables
function gf_expand_content {
    gf_content_comment="$1"; shift

    # Recursive gf_paste_step
    local gf_paste_step_perl='
        my $content = "";

        # Parse arguments
        my $content_type = 0;
        my $step_name = "";
        my @global_options = (); my %steps;
        while (<STDIN>) {
            if ($content_type == 0) {

                # Arguments detection
                if (s/^gf_args\>//) {
                    $content_type = 1;

                # Steps detection
                } elsif (/^gf_step\>(\S+)\>gf_file\>(.+)\n$/) {
                    $step_name = $1;
                    $file_name = $2;
                    $steps{$step_name}{body} = "";

                    my $i = length($step_name) + 25;
                    $i = length($file_name) if ($i < length($file_name));
                    my $hline = ""; while ($i) {$i--; $hline .= "-";}
                    $steps{$step_name}{header} = "$hline\nBegin of flow step \"$step_name\"\n$file_name";
                    $steps{$step_name}{footer} = "End of flow step \"$step_name\"\n$hline";
                    $content_type = 2;

                # Content detection
                } elsif (/^\<gf_content\>\n$/) {
                    $content_type = 3;
                }

            # Arguments body
            } elsif ($content_type == 1) {
                if (s/\<gf_args\n$//) {
                    $content_type = 0;
                }
                s/\n$//;
                push @global_options, $_;

            # Steps body
            } elsif ($content_type == 2) {
                $content_type = 0 if (s/\<gf_step\n$//);
                $steps{$step_name}{body} .= $_;

            # Content body
            } else {
                $content .= $_;
            }
        }

        # Process options
        my %global_options = (); my $key = "";
        foreach (split /\s+/, join " ", @global_options) {
            if ($key ne "") {
                $global_options{$key} = $_ if (/\S/);
                $key = "";
            } elsif (/^-comment/i) {
                $key = "-comment";
            }
        }

        # Global variables
        my $global_steps_count = 0;
        my $global_steps_pasted = 0;
        my $global_comment_start = ""; $global_comment_start = $global_options{-comment} if (defined $global_options{-comment});

        # 1 -comment # step
        # 2 -exclude # step
        # 3 -first a b c
        # 4 -last a b c

        # Paste single step
        sub paste_step {
            my $indent = shift;
            my $options = shift;
            my $stack = shift;
            my $content = "";

            # Process local options
            my %options = (); my $key = "";
            foreach (split (/\s+/, $options)) {
                if ($key ne "") {
                    $options{$key} = $_ if (/\S/);
                    $key = "";

                } elsif (/^-optional/i) {
                    $options{-optional} = 1;
                } elsif (/^-first/i) {
                    $options{-first} = 1;
                } elsif (/^-last/i) {
                    $options{-last} = 1;
                } elsif (/^-no_comment/i) {
                    $options{-no_comment} = 1;
                } elsif (/^-comment/i) {
                    $key = "-comment";
                } elsif (/^(-remove|-exclude)/i) {
                    $key = "-exclude";

                } elsif (/^-/i) {
                    print "gf_error \"Incorrect option '${GFH7}'$_'${GFC0}' used in gf_paste_step '${GFH7}'$options'${GFH0}' command.\"\n";

                } elsif (/[^A-Z_\d]\n$/) {
                    print "gf_error \"Incorrect step name '${GFH7}'$_'${GFC0}' used in gf_paste_step '${GFH7}'$options'${GFH0}' command.\"\n";

                } else {
                    s/\s+$//;
                    push @{$options{steps}}, $_;
                }
            }

            # Local options
            my $local_comment_start = $global_comment_start; $local_comment_start = $options{-comment} if (defined $options{-comment});
            my $local_exclude_start = ""; $local_exclude_start = $options{-exclude} if (defined $options{-exclude});
            $local_exclude_start = $local_comment_start if ($options{-no_comment} && ($local_comment_start ne ""));
            $local_exclude_start =~ s/(\W)/\\$1/gm;

            # Check options
            my @content = ();
            if (!$options{-optional} && ($#{$options{steps}} < 0)) {
                print "gf_error \"No steps to paste in gf_paste_step '${GFH7}'$options'${GFH0}' command.\"\n";
                push @content, "$local_comment_start ERROR: No steps to paste." if ($local_comment_start ne "");
            }

            # Safe options output
            $options =~ s/(\W)/\\$1/gm;

            # Paste steps one by one
            foreach my $name (@{$options{steps}}) {
                
                $global_steps_count++;
                if ($stack =~ / $name /) {
                    print "gf_error \"Recursive paste of flow step '${GFH7}'$name'${GFC0}' is not allowed.\"\n";
                    push @content, "$local_comment_start ERROR: Recursive paste of flow step \"$name\" is not allowed." if ($local_comment_start ne "");

                } elsif (!(defined $steps{$name})) {
                    if (defined $options{-optional}) {
                        print "gf_info \"Flow step '${GFH7}'$name'${GFC0}' is not defined.\"\n";
                        push @content, "$local_comment_start Flow step \"$name\" is not defined.\n" if ($local_comment_start ne "");
                    } else {
                        print "gf_error \"Flow step '${GFH7}'$name'${GFC0}' is not defined.\"\n";
                        push @content, "$local_comment_start ERROR: Flow step \"$name\" is not defined.\n" if ($local_comment_start ne "");
                    }

                } elsif ($steps{$name}{body} !~ /\S/m) {
                    if (defined $options{-optional}) {
                        print "gf_info \"Flow step '${GFH7}'$name'${GFC0}' is empty.\"\n";
                        push @content, "$local_comment_start Flow step \"$name\" is empty.\n" if ($local_comment_start ne "");
                    } else {
                        print "gf_error \"Flow step '${GFH7}'$name'${GFC0}' is empty.\"\n";
                        push @content, "$local_comment_start ERROR: Flow step \"$name\" is empty.\n" if ($local_comment_start ne "");
                    }

                } else {
                    my $header = $steps{$name}{header};
                    my $footer = $steps{$name}{footer};

                    # Exclude lines
                    my @body = split /\n/, $steps{$name}{body};
                    @body = (grep !/^\s*$local_exclude_start/, @body) if ($local_exclude_start ne "");

                    # Check placeholders
                    my @placeholders = grep /\<PLACEHOLDER|PLACEHOLDER\!/, @body;
                    my $placeholders = ($#placeholders + 1);
                    if ($placeholders > 0) {
                        if ($local_comment_start ne "") {
                            $placeholders = 0;
                            foreach (@placeholders) {
                                s/$local_comment_start.*$//g;
                                $placeholders++ if (/\S/);
                            }
                        }
                    }
                    if ($placeholders > 0) {
                        if ($placeholders > 1) {
                            print "gf_error \"Flow step '${GFH7}'$name'${GFC0}' contains '${GFH7}'$placeholders'${GFC0}' placeholders.\"\n";
                        } else {
                            print "gf_error \"Flow step '${GFH7}'$name'${GFC0}' contains placeholder.\"\n";
                        }
                        $header = "ERROR: Flow step \"$name\" contains placeholder.\n".$header;
                    } else {
                        #print "gf_info \"Flow step '${GFH7}'$name'${GFC0}' pasted.\"\n";
                        $global_steps_pasted++;
                    }

                    # Header update
                    if (($header ne "") && ($local_comment_start ne "")) {
                        $header =~ s/^/$local_comment_start /gm;
                        $header = join ("\n", grep !/^\s*$local_exclude_start/, split /\n/, $header) if ($local_exclude_start ne "");
                        $header =~ s/^/$indent/gm;
                        push @content, $header if ($header =~ /\S/m);
                    }

                    # Body update
                    my $body = join ("\n", @body);
                    $body =~ s/^\s+\n(\s*\S)/$1/g;
                    $body =~ s/\s+$//g;
                    $body =~ s/^/$indent/gm if ($body =~ /\S/m);
                    push @content, paste_steps($body,$stack."$name ");

                    if (($footer ne "") && ($local_comment_start ne "")) {
                        $footer =~ s/^/$local_comment_start /gm;
                        $footer = join ("\n", grep !/^\s*$local_exclude_start/, split /\n/, $footer) if ($local_exclude_start ne "");
                        $footer =~ s/^/$indent/gm;
                        push @content, $footer if ($footer =~ /\S/m);
                    }
                }
            }

            return join("\n\n", @content);
        }

        # Expand all steps in the content
        sub paste_steps {
            my $content = shift;
            my $stack = shift;

            # Replace flow steps
            $content =~ s/([^\S\n]*)(?![^\\]\\)\`gf_paste_steps?\s+([^\`\n]+)\`/paste_step($1,$2,$stack)/gme;
            $content =~ s/^([^\S\n]*)(?![^\\]\\)\`\@(\w[^\`\n]*)\`[^\n\S]*$/paste_step($1,$2,$stack)/gme;
            # $content =~ s/^([^\S\n]*)gf_paste_step\s+(((-optional|-exclude\s+\S+)\s+)?\S+(\s+(-optional|-exclude\s+\S+))?)[^\n\S]*$/paste_step($1,$2,$stack)/gme;

            print "gf_error \"Not finalized '${GFH7}'$1'${GFC0}' command.\"\n" if ($content =~ /[^\S\n]*(?![^\\]\\)\`((\@|gf_paste_step)[^\`\n]+)\n/);

            return $content;
        }

        $content = paste_steps($content, " ");

        # Summary
        if ($global_steps_count > 0) {
            if ($global_steps_pasted < $global_steps_count) {
                print "gf_info \"'${GFH7}'$global_steps_pasted'${GFC0}' of '${GFH7}'$global_steps_count'${GFC0}' flow steps pasted.\"\n";
            } else {
                if ($global_steps_pasted > 1) {
                    print "gf_info \"'${GFH7}'$global_steps_pasted'${GFC0}' flow steps pasted.\"\n";
                } else {
                    print "gf_info \"'${GFH7}'$global_steps_pasted'${GFC0}' flow step pasted.\"\n";
                }
            }
        }

        # Result
        print "<==gf_content==>\n$content\n";
    '

    local gf_paste_variables_perl='
        my %variables; my $variable = "";
        my $is_content = 0;
        my $content = "";

        # Parse arguments
        while (<STDIN>) {
            if ($is_content) {
                $content .= $_;
            } else {
                if ($variable ne "") {
                    my $is_done = 0; $is_done = 1 if (s/\<gf_var\n$//);
                    $variables{$variable} .= $_;
                    $variable = "" if ($is_done);
                } elsif (/^gf_var\>(\S+)\<gf_var\n$/) {
                    next;
                } elsif (/^gf_var\>(\S+)\n$/) {
                    $variable = $1;
                    $variables{$variable} = "";
                } elsif (/^\<gf_content\>\n$/) {
                    $is_content = 1;
                }
            }
        }

        # Global variables
        my $global_variables_count = 0;
        my $global_variables_used = 0;

        # Paste single variable
        sub paste_variable {
            my $options = shift; 
            my $stack = shift;
            my $content = "";
            $global_variables_count++;

            my $name = " ".$options." ";
            my %options = "";
            $options{-optional} = 1 if ($name =~ s/ \-optional\w* //);

            # Check options
            $name =~ s/^\s+//;
            $name =~ s/\s+$//;
            if ($name =~ /\s/) {
                print "gf_error \"Incorrect command options '${GFH7}'$options'${GFC0}' in variable.\"\n";

            } elsif ($stack =~ / $name /) {
                print "gf_error \"Recursive substitution of variable '${GFH7}'$name'${GFC0}' is not allowed.\"\n";

            } elsif (!(defined $variables{$name})) {
                if ($options{-optional}) {
                    print "gf_info \"Variable '${GFH7}'$name'${GFC0}' is not defined.\"\n";
                } else {
                    print "gf_error \"Variable '${GFH7}'$name'${GFC0}' is not defined.\"\n";
                }

            } elsif ($variables{$name} =~ /^\s*$/) {
                if ($options{-optional}) {
                    print "gf_info \"Flow variable '${GFH7}'$name'${GFC0}' is empty.\"\n";
                } else {
                    print "gf_warning \"Flow variable '${GFH7}'$name'${GFC0}' is empty.\"\n";
                }

            } else {
                $content = $variables{$name};
                if ($content =~ /\<PLACEHOLDER|PLACEHOLDER\!/gm) {
                    print "gf_warning \"Flow variable '${GFH7}'$name'${GFC0}' contains placeholder.\"\n";
                }
                $global_variables_used++;

                $content = paste_variables($content, $stack."$name ");
            }
            return $content;
        }

        # Expand all variables and variables in the content
        sub paste_variables {
            my $content = shift;
            my $stack = shift;

            # Replace variables
            $content =~ s/(?![^\\]\\)\`\$(\w[^\`\n]*)\`/paste_variable($1,$stack)/gme;

            return $content;
        }

        $content = paste_variables($content, " ");

        # Summary
        if ($global_variables_count > 0) {
            if ($global_variables_used < $global_variables_count) {
                print "gf_info \"'${GFH7}'$global_variables_used'${GFC0}' of '${GFH7}'$global_variables_count'${GFC0}' flow variables substituted.\"\n";
            } else {
                if ($global_variables_used > 1) {
                    print "gf_info \"'${GFH7}'$global_variables_used'${GFC0}' flow variables substituted.\"\n";
                } else {
                    print "gf_info \"'${GFH7}'$global_variables_used'${GFC0}' flow variable substituted.\"\n";
                }
            }
        }

        # Result
        print "<==gf_content==>\n$content\n";
    '

    # Replace steps
    local gf_content="$(echo "gf_args>"$'\n'"-comment $gf_content_comment<gf_args"$'\n'"$GF_FLOW_STEPS"$'\n'"<gf_content>"$'\n'"$(for arg in "$@"; do echo "$arg"; done)" | perl -e "$gf_paste_step_perl")"
    # gf_debug gf_content

    # Print messages
    >&2 eval "$(echo "$gf_content" | perl -e '
        my $is_print = 1;
        while (<STDIN>) {
            $is_print = 0 if (/^<==gf_content==>$/);
            print if ($is_print);
        }
    ')"

    # Remove messages
    gf_content="$(echo "$gf_content" | perl -e '
        my $is_print = 0;
        my $data = "";
        while (<STDIN>) {
            if (/^<==gf_content==>$/) {
                $is_print = 1;
                next;
            }
            $data .= $_ if ($is_print);
        }
        print $data;
    ')"

    # Get variables list
    gf_variables="$(for variable in $(echo "$gf_content" | perl -e '
        my %variables = ();
        while (<STDIN>) {
            $variables{$1} = 1 while (s/(?![^\\]\\)\`\$(\w+)(\s[^\`\n]+)?\`//);
        }
        print join(" ", keys %variables);
    '); do
        if [ -z $(eval "[[ -z \${$variable+x} ]] && echo 1") ]; then
            echo "gf_var>$variable"$'\n'"$(eval "echo -n \"\$$variable\"")<gf_var"
        else
            echo "gf_var>$variable<gf_var"
        fi
    done)"

    # Replace variables with values
    if [ -n "$gf_variables" ]; then
        gf_debug gf_variables

        gf_debug gf_content
        gf_content="$(echo "$gf_variables"$'\n'"<gf_content>"$'\n'"$gf_content" | perl -e "$gf_paste_variables_perl")"
        # gf_debug gf_content

        # Print messages
        >&2 eval "$(echo "$gf_content" | perl -e '
            my $is_print = 1;
            while (<STDIN>) {
                $is_print = 0 if (/^<==gf_content==>$/);
                print if ($is_print);
            }
        ')"

        # Remove messages
        echo "$gf_content" | perl -e '
            my $is_print = 0;
            my $data = "";
            while (<STDIN>) {
                if (/^<==gf_content==>$/) {
                    $is_print = 1;
                    next;
                }
                $data .= $_ if ($is_print);
            }
            print $data;
        '

    # No variables
    else
        echo "$gf_content"
    fi
}

gf_help_command '
    {gf_paste_step} [-optional] [-comment|-exclude <symbol>] <step> ...
    Paste flow {step} name commands as a plain text.
    Option {-optional} will skip an error if step is empty.
    Option {-comment} will add flow step information as comments beginning with {symbol}.
    Option {-exclude} will exclude lines beginning with {symbol}.
    Supported in {gf_add_tool_commands}, {gf_add_shell_commands} or {gf_create_step} commands.
        Use {`gf_paste_step step`} or {`@step`} syntax to paste step.
    Hierarchical steps allowed with any number of levels, recursion is not allowed.
    Example:
        flow_variable="value"
        gf_create_step -name flow_step '"'"'
            echo "Initializing..."
        '"'"'
        gf_add_tool_commands '"'"'
            # Flow step init_tool_scripts will be pasted below
            `gf_paste_step init_tool_scripts`
            `@flow_step`
            `$flow_variable`
        '"'"'
'
function gf_paste_step {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function)"

    # Paste flow steps
    # local gf_content="$(gf_expand_content "$GF_TASK_COMMENT" "gf_paste_step $1")"
    gf_expand_content "$GF_TASK_COMMENT" "\`gf_paste_step $@\`" "$GF_TASK"

    eval "$(gf_revert_function)"
}

##################################################
gf_help_section "Check and wait"
##################################################

# Choose from available variants
gf_help_command '
    {gf_choose} -variable <variable> [-prompt <message>] [-header <message>] [-footer <message>] [-default <value>] [-time <seconds>] \
        {[-keys <shortcuts> [-toggles <shortcuts>]] | [-variants <lines> [-count <count>] [-initial <value>]]}
    Ask user to choose one of predefined variants and store the choice in {variable} with prompt {message}.
    Header message used to print text before displaying variants and footer to print right after but before prompt.
    Default value provided by {-default} option and will be selected automatically after period specified in {-time}.
    List of single-char shortcuts provided by {-keys} option without space separator.
    Optional toggle shortcuts specified in {-toggles} option will be added to the result if enabled.
    List of single-line variants provided by {-variants} option separated by new line symbol.
    To display last {count} variants please use {-count} option.
    Option {-initial} can be used to use specific variant as start value.
    Examples:
        gf_choose -variable VAR -prompt "Select 1, 2 or 3" -keys 123
        gf_choose -variable VAR -prompt "Select 1 or 2 with A, B and C toggles" -keys 12 -toggles ABC
        gf_choose -variable VAR -prompt "Use arrows to select from available variants" -variants "
            Variant 1
            Variant 2
            Variant 3
        "
'
function gf_choose {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function)"
    gf_choose_bash "$@"
    eval "$(gf_revert_function)"
}

# Choose files, directories and tasks
gf_help_command '
    {gf_choose_file_dir_task} -v <variable> [-files <patterns>] [-dirs <patterns>] \
        [[[-want|-wait] -active] [-task_to_file 'pattern'] [-tasks <patterns>]] \
        [-keep] [-relative <dir>] [-prompt <message>] [-variants <count>] [-allow_empty] [-hide_variants]

    Shows list of files, directories and tasks sorted by date in ascending order and matching user {patterns}.
    Asks user to choose file in interactive mode, putting the result into flow {variable}.
    Non-empty variable value will not be overwritten if option {-keep} used.
    Options {-files}, {-dirs} and {-tasks} used to define patterns.
    Option {-active} will return only active task, {-wait} and {-want} will wait selected task.
    Option {-task_to_file} can be used to return file name when task chosen.
        Variable {$TASK} will be replaced with actual task name in the {pattern}.
        Variable {$RUN} will be replaced with actual run directory in the {pattern}.
    Number of displayed variants {count} and prompt {message} can be customized by user.
    Use {-allow_empty} option to allow returning empty value.
    Use {-hide_variants} to disable file variants display.
    Note:
      Relative paths should be specified relative to {-relative} directory or {working directory} if empty.
    Example:
        gf_choose_file_dir_task -v LOG -prompt "Please select log file:" -files '"'"'
            ./*/logs/*.log
        '"'"'
        gf_choose_file_dir_task -v LOG -prompt "Please select log file or active task:" -files '"'"'
            ./*/logs/*.log
        '"'"' -want -active -task_to_file '"'"'$RUN/logs/$TASK.log'"'"' -tasks '"'"'
            */tasks/Log*
        '"'"'
'
gf_help_command '
    {gf_choose_tool_binary} -v <variable> -t <tool> [-dirs <dirs>]
    Ask user to choose {tool} binary in interactive mode, putting the result into flow {variable}.
    Tool binaries looked in {dirs} or in shell environment paths if empty (up to 3 levels of directories).
'
function gf_choose_file_dir_task {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function)"
    local gf_type=file; gf_choose_file_dir_task_bash "$@"
    eval "$(gf_revert_function)"
}
function gf_choose_tool_binary {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function)"
    gf_choose_tool_binary_bash "$@"
    eval "$(gf_revert_function)"
}

# Copy files
gf_help_command '
    {gf_save_files} <files> [-to <dir>] [-copy] [-internal]
    Link {files} into ./{dir} directory. Default: ./in/$TASK_NAME
    Option {-copy} used to create copy instead of link.
    Option {-internal} used to save data into internal directory instead of working one (see -internal mode).
    Synonyms: gf_save_file, gf_save_files
'
function gf_save_file { gf_save_files "$@"; }
function gf_save_files {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function gf_save_file)"

    local key
    gf_check_task_name

    # Target directory
    local gf_to="in/$TASK_NAME"

    # Process arguments
    local gf_files=
    local gf_copy=
    local gf_dir='$GF_RUN_DIR'
    while [ $# -gt 0 ]; do
        key="$1"; shift
        case "$key" in
            "-to" )
                gf_to="$1"; shift
            ;;
            "-internal" )
                gf_dir='$GF_I_RUN_DIR'
            ;;
            "-copy" )
                gf_copy=1
            ;;
            * )
                gf_files+="$key"$'\n'
            ;;
        esac
    done

    # Commands to add: create directory
    local gf_commands=$'\n'"# Save files"$'\n'"mkdir -p \"$gf_dir/$gf_to\""

    # Files to save
    gf_files=$(echo "$gf_files" | sed -e "s|^$GF_RUN_DIR/|../../|; s|$GF_WORK_DIR/|../../../|; s|$GF_INT_DIR/|\$GF_INT_DIR/|")

    # Link files
    if [ -z "$gf_copy" ]; then
        gf_commands+='
            # Files to link
            GF_SAVED_IFS="$IFS"
            IFS=$'"'"'\n'"'"'
            gf_files="'"$gf_files"'"
            for gf_file in $gf_files; do
                if [ -e "$gf_file" ]; then
                    ln -sf "$gf_file" "'"$gf_dir/$gf_to"'"
                    echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' linked '${GFC2}'$gf_file'${GFC0}' to '${GFC7}'./'$gf_to''${GFC0}'"
                else
                    echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' file '${GFH1}'$gf_file'${GFC0}' does not exist to link'${GFC0}'"
                fi
            done
            IFS="$GF_SAVED_IFS"
        '
    # Copy files
    else
        gf_commands+='
            # Files to copy
            GF_SAVED_IFS="$IFS"
            IFS=$'"'"'\n'"'"'
            gf_files="'"$gf_files"'"
            for gf_file in $gf_files; do
                if [ -e "$gf_file" ]; then
                    cp -Rf "$gf_file" "'"$gf_dir/$gf_to"'"
                    echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' copied '${GFC2}'$gf_file'${GFC0}' to '${GFC7}'./'$gf_to''${GFC0}'"
                else
                    echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' file '${GFH1}'$gf_file'${GFC0}' does not exist to copy'${GFC0}'"
                fi
            done
            IFS="$GF_SAVED_IFS"
        '
    fi

    # Add save file commands
    gf_debug gf_commands
    gf_print_commands_info "$gf_commands" "$GF_I_RUN_DIR/tasks/submit.$TASK_NAME.sh"
    GF_TASK_INIT_SCRIPT+="$(gf_auto_tab_commands "$gf_commands")"$'\n'

    eval "$(gf_revert_function)"
}

# Wait time
gf_help_command '
    {gf_wait_time} [[[<days>:]<hours>:]<minutes>:]seconds
    Wait required time before start following commands.
'
function gf_wait_time {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function)"

    gf_check_task_name

    # Split time arguments
    local gf_time=($(echo $@ | sed -e 's/-/:/g; s/:/:0/g; s/^:/0:/g; s/:0\([0-9]\)/:\1/g; s/:/ /g'))

    # Convert time to seconds
    if [ -n "${gf_time[3]}" ]; then
        local gf_seconds=$(( ((${gf_time[0]} * 24 + ${gf_time[1]}) * 60 + ${gf_time[2]} ) * 60 + ${gf_time[3]} ))
        local gf_message="${gf_time[0]} days ${gf_time[1]} hours ${gf_time[2]} minutes ${gf_time[3]} seconds."

    # Hours
    elif [ -n "${gf_time[2]}" ]; then
        local gf_seconds=$(( (${gf_time[0]} * 60 + ${gf_time[1]}) * 60 + ${gf_time[2]} ))
        local gf_message="${gf_time[0]} hours ${gf_time[1]} minutes ${gf_time[2]} seconds."

    # Minutes
    elif [ -n "${gf_time[1]}" ]; then
        local gf_seconds=$(( ${gf_time[0]} * 60 + ${gf_time[1]} ))
        local gf_message="${gf_time[0]} minutes ${gf_time[1]} seconds."

    # Seconds
    elif [ -n "${gf_time[0]}" ]; then
        local gf_seconds=${gf_time[0]}
        local gf_message="${gf_time[0]} seconds."

    # Error
    else
        gf_fatal "Incorrect ${GFH7}$@${GFC0} time. Use ${GFH7}%d-%h:%m:%s${GFC0} format."
    fi

    gf_info "Task will wait for ${GFC7}$gf_message${GFC0} before start."

    # Update task script
    local gf_commands='
        # Wait time
        echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' is waiting for '$gf_message' ..."
        sleep '$gf_seconds'
    '
    gf_debug gf_commands
    gf_print_commands_info "$gf_commands" "$GF_I_RUN_DIR/tasks/submit.$TASK_NAME.sh"
    GF_TASK_INIT_SCRIPT+="$(gf_auto_tab_commands "$gf_commands")"$'\n'

    eval "$(gf_revert_function)"
}

# File wait
gf_help_command '
    {gf_wait_files} [...]
    Wait until files are created externally before start following commands.
    Synonyms: gf_wait_file, gf_wait_files
'
function gf_wait_file { gf_wait_files "$@"; }
function gf_wait_files {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function gf_wait_file)"

    gf_check_task_name

    # Files to stop
    local gf_count=$(gf_count_lines "$(for gf_file in "$@"; do echo "$gf_file"; done)")
    if [ $gf_count -gt 0 ]; then
        local gf_commands='
            # Check ready files
            GF_SAVED_IFS="$IFS"
            IFS=$'"'"'\n'"'"'
            gf_wait_files="'"$(for gf_file in "$@"; do echo "$gf_file"; done)"'"

            # Verify required files
            gf_new_files=
            gf_next_files=
            for gf_file in $gf_wait_files; do
                if [ -e "$gf_file" ]; then
                    if [ $(expr $(date +%s) - $(stat -c %Y "$gf_file")) -gt 30 ]; then
                        echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' required file '${GFC2}'$gf_file'${GFC0}' is ready"
                    else
                        echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' required file '${GFC3}'$gf_file'${GFC0}' just created"
                        gf_new_files+="$gf_file$IFS"
                    fi
                else
                    echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' waits for file '${GFC3}'$gf_file'${GFC0}'"
                    gf_next_files+="$gf_file$IFS"
                fi
            done
            gf_wait_files="$gf_next_files"

            # Wait for left required files
            while [ -n "$(echo -ne $gf_wait_files $gf_new_files)" ]; do
                sleep 5

                gf_next_files=
                for gf_file in $gf_new_files; do
                    if [ $(expr $(date +%s) - $(stat -c %Y "$gf_file")) -gt 30 ]; then
                        echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' required file '${GFC2}'$gf_file'${GFC0}' is ready"
                    else
                        gf_next_files+="$gf_file$IFS"
                    fi
                done
                gf_new_files="$gf_next_files"

                gf_next_files=
                for gf_file in $gf_wait_files; do
                    if [ -e "$gf_file" ]; then
                        echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' required file '${GFC3}'$gf_file'${GFC0}' just created"
                        gf_new_files+="$gf_file$IFS"
                    else
                        gf_next_files+="$gf_file$IFS"
                    fi
                done
                gf_wait_files="$gf_next_files"
            done

            # Restore IFS
            IFS="$GF_SAVED_IFS"
        '

        # Add wait files command
        if [ $gf_count -gt 1 ]; then
            gf_info "Task will wait for ${GFC7}$gf_count${GFC0} files."
        else
            gf_info "Task will wait for ${GFC7}$@${GFC0} file."
        fi
        GF_TASK_INIT_SCRIPT+="$(gf_auto_tab_commands "$gf_commands")"$'\n'
    fi


    eval "$(gf_revert_function)"
}

# Task unique directory
gf_help_command '
{gf_get_task_dir} [-variable <name>] <task>
    Get exact task directory for {task} executed in current flow.
    If {-variable} option used, the result will be stored in variable with specific {name}.
'
function gf_get_task_dir {
    eval "$(gf_update_function gf_want_task gf_want_tasks gf_wait_task)"

    local key gf_next_key

    # Parse arguments
    local gf_var=
    local gf_result=
    while [ $# -gt 0 -a -z "$gf_next_key" ]; do
        if [ -n "$gf_next_key" ]; then
            key="$gf_next_key"
            gf_next_key=
        else
            key="$1"
            shift
        fi
        case "$key" in
            -var|-variable )
                if [[ $1 =~ ^[a-zA-Z0-9_]+$ ]]; then
                    gf_var=$1
                else
                    gf_fatal "Incorrect variable name ${GFH7}$1${GFC0} to store tasks."
                fi
                shift
            ;;
            -* )
                gf_fatal "Incorrect ${GFH7}$key${GFC0} option. Run ${GFH7}$GF_BIN_FILE -help${GFC0} for more info."
            ;;
            * )

                # Filter tasks by pattern is current session
                local gf_perl_script="$gf_parse_task_statuses_script"'
                    my $result = "";
                    foreach my $task (@tasks) {
                        $result = $task if ($tasks{$task}{base} eq "'"$key"'");
                    }
                    print "$result\n";
                '
                local gf_found_task="$(echo "$GF_TASK_STATUSES" | perl -e "$gf_perl_script")"
                # gf_debug gf_perl_script
                gf_debug GF_TASK_STATUSES gf_found_task

                # Task not found
                if [ -z "$gf_found_task" ]; then
                    gf_fatal "No task ${GFH7}$key${GFC0} found in current session."

                # Wait for tasks
                else
                    gf_result="$gf_result$GF_I_RUN_DIR/tasks/$gf_found_task"$'\n'
                fi
            ;;
        esac
    done

    # Update result variable when required
    if [ -n "$gf_var" ]; then
        gf_info "Variable ${GFC7}$gf_var${GFC0} set to ${GFC4}$(echo $gf_result)${GFC0}."
        eval "$gf_var='$(echo $gf_result)'"
    else
        echo $gf_result
    fi

    eval "$(gf_revert_function)"
}

# Task want
function gf_want_task { gf_wait_tasks "$@"; }
function gf_want_tasks { gf_wait_tasks "$@"; }

# Task wait
gf_help_command '
{gf_wait_tasks} [-variable <name>] [-run ...] [-exact] <waited_task> [...]
    Wait for all {waited_task} to complete of fail.
    Use {-exact} option if exact task name provided to disable incremental tasks choose.
    Use {-variable} option to store exact unique task name in variable.
    Task of different run name or directory can be specified using {-run} option.

{gf_want_tasks} [-variable <name>] [-run ...] [-exact] <wanted_task> [...]
    Wait for all {wanted_task} to complete successfully.
    Failed status of {wanted_task} will abort the current task.
    Use {-exact} option if exact task name provided to disable incremental tasks choose.
    Use {-variable} option to store exact unique task name in variable.
    Task of different run name or directory can be specified using {-run} option.
    Synonyms: gf_wait_task, gf_wait_tasks
'
function gf_wait_task { gf_wait_tasks "$@"; }
function gf_wait_tasks {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function gf_want_task gf_want_tasks gf_wait_task)"

    local key

    gf_check_task_name

    # Source function name
    if [ "${FUNCNAME[1]}" == "gf_want_task" -o "${FUNCNAME[1]}" == "gf_want_tasks" -o "${FUNCNAME[1]}" == "gf_submit_task" ]; then
        local gf_action=WANT
        local gf_suffix=" to complete successfully"
    else
        local gf_action=WAIT
        local gf_suffix=""
    fi

    # Parse arguments
    local gf_wait_run_dir="$GF_I_RUN_DIR"
    local gf_wait_run=""
    local gf_is_empty=1
    local gf_next_key=
    local gf_var=
    local gf_tasks=
    local gf_exact=base
    while [ $# -gt 0 -a -z "$gf_next_key" ]; do
        if [ -n "$gf_next_key" ]; then
            key="$gf_next_key"
            gf_next_key=
        else
            key="$1"
            shift
        fi
        case "$key" in
            -run )
                gf_wait_run_dir="$(gf_full_path "$1" | sed -e 's|/tasks$||')"
                if [ "$gf_wait_run_dir" == "$GF_I_RUN_DIR" ]; then
                    gf_warning "Option ${GFC7}$key $1${GFC0} points to current run."
                fi
                shift
            ;;
            -wait )
                gf_action=WAIT
                gf_suffix=""
            ;;
            -want )
                gf_action=WANT
                gf_suffix=" to complete successfully"
            ;;
            -var|-variable )
                if [[ $1 =~ ^[a-zA-Z0-9_]+$ ]]; then
                    gf_var=$1
                else
                    gf_fatal "Incorrect variable name ${GFH7}$1${GFC0} to store tasks."
                fi
                shift
            ;;
            -exact )
                gf_exact=task
            ;;
            -* )
                gf_fatal "Incorrect ${GFH7}$key${GFC0} option. Run ${GFH7}$GF_BIN_FILE -help${GFC0} for more info."
            ;;
            * )
                local gf_wait_run_dir_current="$gf_wait_run_dir"

                # Full path to the task
                if [ "$(dirname "$key")" != "." ]; then
                    gf_wait_run_dir_current="$(gf_full_path "$(dirname "$key" | sed -e 's|/tasks$||')")"
                    key="$(basename "$key")"
                fi

                # Differentiate internal and external run directories
                local gf_dir_message=""
                local gf_external_run=""
                local gf_wait_run_dir_short=""
                if [ "$gf_wait_run_dir_current" != "$GF_I_RUN_DIR" ]; then
                    if [ "$(dirname "$gf_wait_run_dir_current")" == "$(dirname "$GF_I_RUN_DIR")" ]; then
                        gf_external_run="$(basename "$gf_wait_run_dir_current")"
                        gf_wait_run_dir_short="../../../$gf_external_run"
                        gf_dir_message="run directory ${GFC7}$gf_external_run${GFC0}"
                    else
                        gf_external_run="$gf_wait_run_dir_current"
                        gf_wait_run_dir_short="$gf_wait_run_dir_current"
                        gf_dir_message="run directory ${GFC7}$gf_external_run${GFC0}"
                    fi
                fi
                gf_debug gf_dir_message gf_external_run gf_wait_run_dir_short

                # Regular expression to filter tasks by mask
                local gf_regex="$(echo "$key" | sed -e 's/*/.*/g; s/?/./g;')"

                # Wait for tasks in the current run
                gf_is_empty=
                if [ -z "$gf_wait_run_dir_short" ]; then

                    # Filter tasks by pattern is current session
                    local gf_perl_script="$gf_parse_task_statuses_script"'
                        my @variants; my %variants;
                        foreach my $task (@tasks) {
                            if ($tasks{$task}{'"$gf_exact"'} =~ /^'"$gf_regex"'$/) {
                                push @variants, $task if (!$variants{$task}); $variants{$task} = 1;
                            }
                        }
                        print "local gf_found_tasks=\"".join("\n", @variants)."\"\n";
                    '
                    eval "$(echo "$GF_TASK_STATUSES" | perl -e "$gf_perl_script")"
                    # gf_debug gf_perl_script
                    gf_debug GF_TASK_STATUSES gf_found_tasks

                    # Task can be in the same run but different session
                    if [ -z "$gf_found_tasks" ]; then
                        if [ -e "$gf_wait_run_dir_current/tasks/run.info" ]; then
                            local gf_perl_script="$gf_parse_run_info_script"'
                                my @variants; my %variants;
                                foreach my $task (@tasks) {
                                    my $choice = $tasks{$task}{'"$gf_exact"'};
                                    if ($choice =~ /^'"$gf_regex"'$/) {
                                        push @variants, $choice if (!$variants{$choice}); $variants{$choice} = 1;
                                    }
                                }
                                print "local gf_found_tasks=\"".join("\n", @variants)."\"\n";
                            '
                            eval "$(cat "$gf_wait_run_dir_current/tasks/run.info" | perl -e "$gf_perl_script")"
                            # gf_debug gf_perl_script
                            gf_debug gf_regex gf_found_tasks
                        fi
                    fi

                    # No tasks to wait
                    if [ -z "$gf_found_tasks" ]; then
                        if [ "$gf_regex" != "$key" ]; then
                            gf_fatal "Incorrect task pattern ${GFH7}$key${GFC0} to wait."
                        else
                            gf_fatal "Incorrect task ${GFH7}$key${GFC0} to wait."
                        fi

                    # Wait for tasks
                    else
                        local gf_task=
                        for gf_task in $gf_found_tasks; do

                            # Task status in current session
                            local gf_perl_script="$gf_parse_task_statuses_script"'
                                my $task = "'"$gf_task"'";
                                print "local gf_task_status=$tasks{$task}{status}\n";
                            '
                            eval "$(echo "$GF_TASK_STATUSES" | perl -e "$gf_perl_script")"
                            # gf_debug gf_perl_script
                            gf_debug GF_TASK_STATUSES gf_task_status

                            # Select task in previous sessions
                            if [ "$gf_task_status" != "new" -a "$gf_exact" != "task" ]; then
                                gf_choose_task_candidate gf_task gf_task_status "$gf_task" "$gf_wait_run_dir_current/tasks/run.info" "wait task"
                            fi

                            # Not wait skipped or disabled task
                            if [ "$gf_task_status" == "disabled" -o "$gf_task_status" == "skipped" ]; then
                                gf_warning "Will not wait for $gf_task_status ${GFC4}$gf_task${GFC0} task."

                            # Wait for the task
                            else
                                GF_WAIT_TASKS+="$gf_action=$gf_task=\$GF_I_RUN_DIR/tasks/run.info"$'\n'
                                gf_tasks+="$gf_task "
                                if [ "$gf_task_status" == "chosen" ]; then
                                    gf_info "Task will wait for ${GFC4}$gf_task${GFC0} task$gf_suffix in other session."
                                else
                                    gf_info "Task will wait for ${GFC4}$gf_task${GFC0} task$gf_suffix."
                                fi
                            fi
                        done
                    fi

                # Wait for tasks in different run
                else
                    if [ -e "$gf_wait_run_dir_current/tasks/run.info" ]; then

                        # Filter tasks by pattern
                        local gf_perl_script="$gf_parse_run_info_script"'
                            my @variants; my %variants;
                            foreach my $task (@tasks) {
                                my $choice = $tasks{$task}{'"$gf_exact"'};
                                if ($choice =~ /^'"$gf_regex"'$/) {
                                    push @variants, $choice if (!$variants{$choice}); $variants{$choice} = 1;
                                }
                            }
                            print "local gf_found_tasks=\"".join("\n", @variants)."\"\n";
                        '
                        eval "$(cat "$gf_wait_run_dir_current/tasks/run.info" | perl -e "$gf_perl_script")"
                        # gf_debug gf_perl_script
                        gf_debug gf_regex gf_found_tasks

                        # Wait for future tasks
                        if [ -z "$gf_found_tasks" ]; then
                            gf_tasks+="$key "
                            GF_WAIT_TASKS+="$gf_action=$key=$gf_wait_run_dir_short/tasks/run.info"$'\n'
                            if [ "$gf_regex" != "$key" ]; then
                                gf_warning "Task will wait for not started ${GFC4}$key${GFC0} tasks in $gf_dir_message$gf_suffix."
                            else
                                gf_warning "Task will wait for not started ${GFC4}$key${GFC0} task in $gf_dir_message$gf_suffix."
                                GF_CHOSEN_TASKS+="$key $key $(gf_full_path "$gf_wait_run_dir_current/tasks/run.info")"$'\n'
                            fi

                        # Wait for running tasks
                        else
                            local gf_task=
                            local gf_task_status=
                            for gf_task in $gf_found_tasks; do

                                # Check for candidates
                                if [ "$gf_exact" != "task" ]; then
                                    gf_choose_task_candidate gf_task gf_task_status "$gf_task" "$gf_wait_run_dir_current/tasks/run.info" "wait $gf_external_run task"
                                fi

                                # Wait for the task
                                gf_tasks+="$gf_task "
                                GF_WAIT_TASKS+="$gf_action=$gf_task=$gf_wait_run_dir_short/tasks/run.info"$'\n'
                                gf_info "Task will wait for ${GFC4}$gf_task${GFC0} task in $gf_dir_message$gf_suffix."
                            done
                        fi

                    # Wait for tasks in not created run
                    else
                        gf_tasks+="$key "
                        GF_WAIT_TASKS+="$gf_action=$key=$gf_wait_run_dir_short/tasks/run.info"$'\n'
                        if [ "$gf_regex" != "$key" ]; then
                            gf_warning "Task will wait for ${GFC4}$key${GFC0} tasks in non-existing $gf_dir_message$gf_suffix."
                        else
                            gf_warning "Task will wait for ${GFC4}$key${GFC0} task in non-existing $gf_dir_message$gf_suffix."
                            GF_CHOSEN_TASKS+="$key $key $(gf_full_path "$gf_wait_run_dir_current/tasks/run.info")"$'\n'
                        fi
                    fi
                fi
            ;;
        esac
        if [ $# -eq 0 -a -n "$gf_is_empty" ]; then
            gf_wait_run=""
            gf_next_key="$LAST_TASK_NAME"
        fi
    done

    # Update result variable when required
    if [ -n "$gf_var" ]; then
        gf_info "Variable ${GFC7}$gf_var${GFC0} set to ${GFC4}$(echo $gf_tasks)${GFC0}."
        eval "$gf_var=\"$(echo $gf_tasks)\""
    fi

    eval "$(gf_revert_function)"
}

# Stop task if file exists
gf_help_command '
    {gf_stop_files} <files> [...]
    Skip running task if all stop {files} in the single gf_stop_files commands exist.
    Please note that task will be skipped if all stop files of at least one gf_stop_files command exist.
    Synonyms: gf_stop_file, gf_stop_files
'
function gf_stop_file { gf_stop_files "$@"; }
function gf_stop_files {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function gf_stop_file)"

    gf_check_task_name

    # Files to stop
    local gf_count=$(gf_count_lines "$(for gf_file in "$@"; do echo "$gf_file"; done)")
    if [ $gf_count -gt 0 ]; then
        local gf_commands='
            # Check files to stop task
            GF_SAVED_IFS="$IFS"
            IFS=$'"'"'\n'"'"'
            gf_stop_files="'"$(for gf_file in "$@"; do echo "$gf_file"; done)"'"
            gf_check_failed=
            for gf_file in $gf_stop_files; do
                if [ -e "$gf_file" ]; then
                    echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' stop file '${GFC3}'$gf_file'${GFC0}' exists"
                else
                    echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' stop file '${GFC7}'$gf_file'${GFC0}' does not exist"
                    gf_check_failed=1
                fi
            done
            IFS="$GF_SAVED_IFS"

            # Stop task if required
            if [ -z "$gf_check_failed" ]; then
                echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' stopped because all files exist in single '${GFC7}''"${FUNCNAME[0]}"''${GFC0}' command"
                gf_current_task_status=done; exit 0
            fi
        '

        # Add stop files command
        if [ $gf_count -gt 1 ]; then
            gf_info "Task will stop if ${GFC7}$gf_count${GFC0} files exist."
        else
            gf_info "Task will stop if ${GFC7}$@${GFC0} file exists."
        fi
        GF_TASK_INIT_SCRIPT+="$(gf_auto_tab_commands "$gf_commands")"$'\n'
    fi

    eval "$(gf_revert_function)"
}

# File wait
gf_help_command '
    {gf_check_files} [...]
    Stop if any of the required files doesn'"'"'t exist.
    Synonyms: gf_check_file, gf_check_files
'
function gf_check_file { gf_check_files "$@"; }
function gf_check_files {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function gf_check_file)"

    gf_check_task_name

    # Files to stop
    local gf_count=$(gf_count_lines "$(for gf_file in "$@"; do echo "$gf_file"; done)")
    if [ $gf_count -gt 0 ]; then
        local gf_commands='
            # Check if files exist
            GF_SAVED_IFS="$IFS"
            IFS=$'"'"'\n'"'"'
            gf_check_files="'"$(for gf_file in "$@"; do echo "$gf_file"; done)"'"
            for gf_file in $gf_check_files; do
                if [ -e "$gf_file" ]; then
                    echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' required file '${GFC2}'$gf_file'${GFC0}' found"
                    md5sum "$(realpath "$gf_file")" >> ./in/$TASK_NAME.md5sum
                else
                    echo -e "['${GFH4}'$$'${GFC0}'] $(date +%d-%H:%M:%S) '${GFH4}''$TASK_NAME''${GFC0}' required file '${GFH1}'$gf_file'${GFC0}' not found"
                    gf_current_task_status=aborted; exit 2
                fi
            done
            IFS="$GF_SAVED_IFS"
        '

        # Add wait files command
        if [ $gf_count -gt 1 ]; then
            gf_info "Task will check if ${GFC7}$gf_count${GFC0} files exist."
        else
            gf_info "Task will check if ${GFC7}$@${GFC0} exists."
        fi
        GF_TASK_INIT_SCRIPT+="$(gf_auto_tab_commands "$gf_commands")"$'\n'
    fi

    eval "$(gf_revert_function)"
}

##################################################
gf_help_section "Log processing"
##################################################

# Log filter commands
gf_help_command '
    {gf_add_log_filters} <expressions> [...]
    Filter task log by {expressions}.
    Full command log will be saved in {./logs/$TASK_NAME.log} file.
    Filtered log will be also saved in {./logs/$TASK_NAME.filtered.log} file.
    Synonyms: gf_add_log_filter, gf_add_log_filters
'
function gf_add_log_filter { gf_add_log_filters "$@"; }
function gf_add_log_filters {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function gf_add_log_filter)"

    gf_check_task_name

    # Filter commands
    local gf_message=
    while [ $# -gt 0 ]; do
        gf_message+=", ${GFC7}$1${GFC0}"
        GF_TASK_LOG_FILTER+=" -e '$1'"
        shift
    done
    gf_message=${gf_message#, }

    # Look for error mark
    if [ -n "$gf_message" ]; then
        if [ -z "$GF_TASK_LOG_FILTER_DISABLE" ]; then
            gf_info "Log filters $(echo $gf_message) added."
        else
            gf_warning "Log filters $(echo $gf_message) added, but log filtering disabled."
        fi
    fi

    eval "$(gf_revert_function)"
}

# Info mark
gf_help_command '
    {gf_add_status_marks} [-<count>] [+<count>] [-m <max>] [-from <expr>] [-to <expr>] [-exclude <expr>] [-file <file>] [-expr] <expr> [...]
    Add directives to display part of the task in status section of run log.
    When {-expr} option used, it will display lines matching the regexp.
        Log area to check can be decreased by {-from} and {-to} regexp.
        Several {-from} and {-to} options can be used for spet-by-step match.
            Log:
              #1:  A
              #2:  B
              #3:  A
              #4:  C
              #5:  text
            Ex: {-from B -from A} will limit log where line containing B found after A (lines #3-#5).
            Ex: {-from A -to C} will limit log between lines #1-4).
        Option {-<count>} can be used to display more lines in backward direction.
        Option {+<count>} can be used to display more lines in forward direction.
    If {-expr} omitted, single {-from} works until end of file and single {-to} from the beginning.
        Both {-from} and {-to} will display all text
        Option {-m} can be used to limit maximum number of the lines for each matching block.
    Option {-exclude} can be used to cut out lines with matching pattern from selected results.
    Option {-file} can be used to filter any user-defined file.
    Synonyms: gf_add_status_mark, gf_add_status_marks
'
function gf_add_status_mark { gf_add_status_marks "$@"; }
function gf_add_status_marks {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function gf_add_status_mark)"

    gf_check_task_name

    # Wildcard
    if [ "$(echo *)" == "$(echo $@)" ]; then
        gf_info "Task status mark ${GFC7}*${GFC0} added."
        GF_TASK_INFO_MARKS+="=N="$'\n'"=E=.*"$'\n'

    # Info marks
    else

        # Parse command line
        local gf_limit="=N=250"$'\n'
        local gf_files=
        local gf_options=
        local gf_options_ok=0
        local gf_last_key=
        local gf_message1=
        local gf_message2=
        local gf_message3=
        local gf_message4=
        while [ $# -gt 0 ]; do
            if [[ "$1" != -* ]]; then key="$gf_last_key"; else key=; fi
            if [ -z "$key" ]; then key="$1"; shift; fi
            gf_last_key=; case "$key" in
                -a|-A|-after )
                    if [[ $1 =~ ^[0-9][0-9]*$ ]]; then
                        gf_options+="=A=$1"$'\n'
                        gf_message2+="${GFC7}+$1${GFC0} "
                    else
                        gf_fatal "Argument \e[1m$key\e[0m requires positive number."
                    fi
                    shift
                ;;
                -b|-B|-before )
                    if [[ $1 =~ ^[0-9][0-9]*$ ]]; then
                        gf_options+="=B=-$1"$'\n'
                        gf_message2+="${GFC7}-$1${GFC0} "
                    else
                        gf_fatal "Argument \e[1m$key\e[0m requires positive number."
                    fi
                    shift
                ;;
                -l|-m|-limit|-max )
                    if [[ $1 =~ ^[0-9][0-9]*$ ]]; then
                        gf_limit="=N=$1"$'\n'
                        gf_message2+="-max ${GFC7}$1${GFC0} "
                    else
                        gf_fatal "Argument \e[1m$key\e[0m requires positive number."
                    fi
                    shift
                ;;
                -e|-expr|-expression|-expression )
                    gf_last_key="$key"
                    if [ -z "$1" ]; then
                        gf_fatal "Argument \e[1m$key\e[0m requires valid regexp."
                    else
                        gf_message3+="${GFC7}$1${GFC0} "
                        gf_options_ok=1; gf_options+="=E=$1"$'\n'
                    fi
                    shift
                ;;
                -x|-except|-exclude )
                    gf_last_key="$key"
                    if [ -z "$1" ]; then
                        gf_fatal "Argument \e[1m$key\e[0m requires valid regexp."
                    else
                        gf_message4+="-except ${GFC7}$1${GFC0} "
                        gf_options+="=X=$1"$'\n'
                    fi
                    shift
                ;;
                -f|-start|-begin|-from )
                    if [ -z "$1" ]; then
                        gf_fatal "Argument \e[1m$key\e[0m requires valid regexp."
                    else
                        gf_options_ok=1; gf_options+="=F=$1"$'\n'
                        gf_message1+="-start ${GFC7}$1${GFC0} "
                    fi
                    shift
                ;;
                -t|-stop|-end|-to )
                    if [ -z "$1" ]; then
                        gf_fatal "Argument \e[1m$key\e[0m requires valid regexp."
                    else
                        gf_options_ok=1; gf_options+="=T=$1"$'\n'
                        gf_message1+="-stop ${GFC7}$1${GFC0} "
                    fi
                    shift
                ;;
                -i|-in|-file|-files )
                    gf_last_key="$key"
                    if [ -z "$1" ]; then
                        gf_fatal "Argument \e[1m$key\e[0m requires file name."
                    else
                        gf_message1+="-file ${GFC7}$1${GFC0} "
                        gf_files+="=F=$1"$'\n'
                    fi
                    shift
                ;;
                * )
                    if [[ $key =~ ^-[1-9][0-9]*$ ]]; then
                        gf_options+="=B=$key"$'\n'
                        gf_message2+="${GFC7}$key${GFC0} "
                    elif [[ $key =~ ^\+[1-9][0-9]*$ ]]; then
                        gf_options+="=A=$key"$'\n'
                        gf_message2+="${GFC7}$key${GFC0} "
                    else
                        gf_options_ok=1; gf_options+="=E=$key"$'\n'
                        gf_message3+="${GFC7}$key${GFC0} "
                    fi
                ;;
            esac
        done

        # Log filtering if files not specified
        [[ -z "$gf_files" ]] && gf_files="=I=./logs/$TASK_NAME.log"$'\n'
        gf_debug gf_limit gf_files gf_options gf_message1 gf_message2 gf_message3 gf_message4

        # Check mandatory options
        if [ $gf_options_ok == 1 ]; then
            local gf_incorrect_patterns="$(echo "$gf_options" | perl -e '
                while (<STDIN>) {
                    if (/^=[FTEX]=(.*)/) {
                        my $pattern = $1;
                        eval {qr($pattern)};
                        print "Regex pattern '"${GFH7}"'$pattern'"${GFH0}"' is incorrect\n" if ($@);
                    }
                }
            ')"
            if [ -n "$gf_incorrect_patterns" ]; then
                echo "$gf_incorrect_patterns" | while read error; do
                    gf_error "$error"
                done
                gf_fatal "Please fix erros above"
            fi

            # Add status mark directives
            GF_TASK_INFO_MARKS+="$gf_limit$gf_files$gf_options"
            if [ -n "$gf_message1$gf_message2$gf_message3$gf_message4" ]; then
                gf_info "Task status marks ${gf_message1}${gf_message2}${gf_message3}${gf_message4}added."
            fi
        else
            gf_fatal "At least one expression required."
        fi
        gf_debug GF_TASK_INFO_MARKS
    fi

    eval "$(gf_revert_function)"
}

# Clear info mark
gf_help_command '
    {gf_clear_status_marks}
    Reset status marks defined earlier with {gf_add_status_marks} command.
'
function gf_remove_status_marks {
    GF_TASK_INFO_MARKS=
    gf_info "Task status marks ${GFC7}removed${GFC0}."
}

gf_help_command '
{gf_add_success_marks} <expressions> [...]
    Grep task log for sucessful {expressions} to identify done tasks.
    If none expressions found task becomes failed.
     Synonyms: gf_add_success_mark, gf_add_success_marks

{gf_add_failed_marks} <expressions> [...]
    Grep task log for failed {expressions} to identify failed tasks.
    If any expression found task becomes failed.
    Synonyms: gf_add_failed_mark, gf_add_failed_marks
'

# Successful mark
function gf_add_success_mark { gf_add_success_marks "$@"; }
function gf_add_success_marks {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function gf_add_success_mark)"

    gf_check_task_name

    # Successful marks
    local gf_message=
    while [ $# -gt 0 ]; do
        GF_TASK_DONE_MARKS+=" '$1'"
        gf_message+=", ${GFC7}$1${GFC0}"
        shift
    done
    gf_message=${gf_message#, }

    # Error mark message
    if [ -n "$gf_message" ]; then
        gf_info "Task success marks $(echo $gf_message) added."
    fi

    eval "$(gf_revert_function)"
}

# Failed mark
function gf_add_failed_mark { gf_add_failed_marks "$@"; }
function gf_add_failed_marks {
    [[ -n "$GF_SKIP_TASK" ]] && return
    eval "$(gf_update_function gf_add_failed_mark)"

    gf_check_task_name

    # Error marks
    local gf_message=
    while [ $# -gt 0 ]; do
        GF_TASK_FAIL_MARKS+=" '$1'"
        gf_message+=", ${GFC7}$1${GFC0}"
        shift
    done
    gf_message=${gf_message#, }

    # Look for error mark
    if [ -n "$gf_message" ]; then
        gf_info "Task failed marks $(echo $gf_message) added."
    fi

    eval "$(gf_revert_function)"
}

# Add test marks to check log after task completion
gf_help_command '
    {gf_check_session_log} [-skip] lines ...
    Check if session log matches {lines} when flow completed.
    Option {-skip} can be used to exclude some lines from comparison.
'
function gf_check_session_log {
    local gf_file=
    while [ $# -gt 0 ]; do
        case "$1" in
            -skip )
                GF_CHECK_LOG_MESSAGES_SKIP+="$2"$'\n'
                shift;
            ;;
            * )
                GF_CHECK_LOG_MESSAGES+="$1"$'\n'
            ;;
        esac
        shift
    done
}

# Add test marks to check log after task completion
function gf_do_check_session_log {
    if [ -n "$GF_CHECK_LOG_MESSAGES" ]; then
        local gf_perl_script='
            my $index = "'$GF_RUN_INDEX'";

            sub simplify {
                my $line = shift;
                $line =~ s/\e\][012];[^\x07]*\x07//g;
                $line =~ s/\\e\][012];[^\x07]*\x07//g;
                $line =~ s/\e\[\d+(;\d+)*m//g;
                $line =~ s/\\e\[\d+(;\d+)*m//g;
                while ($line =~ s/[^\x08]\x08//g) {};
                $line =~ s/^\[\d+] \d+-\d+:\d+:\d+ /^\[PID\] DD-HH:MM:SS /;
                $line =~ s/^\s+//g;
                $line =~ s/\s+$//g;
                return $line;
            }

            sub match_ratio {
                my $line1 = shift;
                my $line2 = shift;
                $line1 =~ s/^\s+//;
                $line2 =~ s/^\s+//;
                $line1 =~ s/\s+$//;
                $line2 =~ s/\s+$//;
                $line1 =~ tr/A-Z/a-z/;
                $line2 =~ tr/A-Z/a-z/;
                $line1 = join("", sort(split "", $line1));
                $line2 = join("", sort(split "", $line2));
                my $matched;
                my $mismatched;
                while ("$line1$line2" ne "") {
                    my $char1 = $1 if ($line1 =~ /^(.)/);
                    my $char2 = $1 if ($line2 =~ /^(.)/);
                    if ($char1 eq $char2) {
                        $matched .= $char1;
                        $line1 =~ s/^(.)//;
                        $line2 =~ s/^(.)//;
                    } elsif (($char1 ne "") && ($char2 ne "")) {
                        if ($char1 lt $char2) {
                            $mismatched .= $1 if ($line1 =~ s/^(.)//);
                        } else {
                            $mismatched .= $1 if ($line2 =~ s/^(.)//);
                        }
                    } elsif ($char1 ne "") {
                        $mismatched .= $1 if ($line1 =~ s/^(.)//);
                    } elsif ($char2 ne "") {
                        $mismatched .= $1 if ($line2 =~ s/^(.)//);
                    }
                }
                if ($matched eq "") {
                    return 0.0;
                } else {
                    return (1.0 * (length $matched) / ((length $matched) + (length $mismatched)));
                }
            }

            my @checks;
            my @lines;
            my @skip;
            my $mode = "";
            my $line = 0;
            while (<STDIN>) {
                s/^\s+//g;
                s/\s+$//g;
                s/ESC([\[\]]\d+(;\d+)*m)/\e$1/g;
                s/ESC(\][012];)/\e$1/g;
                s/\\x07/\x07/g;
                s/\\x08/\x08/g;
                s/\\x1B/\x1B/g;
                next if (!$_);
                if (/^===(GF_(CHECK|SKIP|CONTENT))===$/) {
                    $mode = $1;
                } elsif ($mode eq "GF_CHECK") {
                    push @checks, $_;
                } else {
                    s/^\[(\e|\\e)\[94m\d+(\e|\\e)\[0m\] \d+-\d+:\d+:\d+ /\[\e\[94mPID\e\[0m\] DD-HH:MM:SS /;
                    if ($mode eq "GF_SKIP") {
                        my $skip = simplify($_);
                        push @skip, $skip if ($skip ne "");
                    } elsif ($mode eq "GF_CONTENT") {
                        push @lines, $_;
                    }
                }
            }

            my $expected = "";
            my $updated = "";
            my $results = "";

            my $is_new_line = 0;
            my $is_match = 1;
            my $start_line = 0;

            # Process each check one by one
            foreach my $check (@checks) {
                my $escaped_check = $check;
                my $expr = simplify($check);
                my $is_line_matched = 0;

                # Process lines from last matched until next match
                for (my $pass = 1; $pass <= 3; $pass++) {
                    for (my $line=$start_line; $line <= $#lines; $line++) {
                        my $line_check = $lines[$line];

                        # Check match
                        if (($pass == 1) && ($line_check eq $check)) {
                            $is_line_matched = 1;
                        } else {
                            my $line_expr = simplify($line_check);
                            if (($pass == 2) && ($line_expr eq $expr)) {
                                $is_line_matched = 2;
                                $is_match = 0;
                            } elsif (($pass == 3) && (match_ratio($line_expr, $expr) > 0.8)) {
                                $is_line_matched = 3;
                                $is_match = 0;
                            }
                        }

                        # Process accumulated lines
                        if ($is_line_matched) {
                            $escaped_check = $line_check;
                            for (my $i=$start_line; $i < $line; $i++) {
                                my $is_skip = 0;
                                my $line_expr = simplify($lines[$i]);
                                foreach my $skip_expr (@skip) {
                                    if ($skip_expr eq $line_expr) {
                                        $is_skip = 1;
                                        last;
                                    }
                                }
                                if (!$is_skip) {
                                    $results .= "\n" if ($is_new_line); $is_new_line = 0;
                                    $results .= "  \e[30;40m '${GFC0}' $lines[$i]\n";
                                }
                            }
                            $start_line = $line+1;
                        }

                        # Update results
                        if ($is_line_matched == 1) {
                            $results .= "\n" if ($is_new_line); $is_new_line = 0;
                            $results .= "  '${GFM2}' '${GFC0}' $line_check\n";
                            $updated .= "  '${GFM2}' '${GFC0}'";
                        } elsif ($is_line_matched == 2) {
                            $results .= "\n"; $is_new_line = 1;
                            $results .= "  '${GFM6}' '${GFC0}' $line_check\n";
                            $results .= "  '${GFM4}' '${GFC0}' $check\n";
                            $updated .= "  '${GFM6}' '${GFC0}'";
                        } elsif ($is_line_matched == 3) {
                            $results .= "\n"; $is_new_line = 1;
                            $results .= "  '${GFM3}' '${GFC0}' $line_check\n";
                            $results .= "  '${GFM4}' '${GFC0}' $check\n";
                            $updated .= "  '${GFM3}' '${GFC0}'";
                        }
                        last if ($is_line_matched);
                    }
                    last if ($is_line_matched);
                }

                # Not matched
                if (!$is_line_matched) {
                    $is_match = 0;
                    my $matched_color = "41m";
                    for (my $line=0; $line <= $#lines; $line++) {
                        my $line_check = $lines[$line];
                        my $line_expr = simplify($line_check);
                        if ($line_expr eq $expr) {
                            $matched_color = "45m";
                            last;
                        }
                    }
                    $results .= "\n" if ($is_new_line); $is_new_line = 0;
                    $results .= "  \e[$matched_color '${GFC0}' $check\n";
                    $updated .= "  \e[$matched_color '${GFC0}'";
                }

                $escaped_check =~ s/\x07/\\x07/g;
                $escaped_check =~ s/\x08/\\x08/g;
                $escaped_check =~ s/\e/ESC/g;
                $escaped_check =~ s/([\\\$\"])/\\$1/g;
                $escaped_check =~ s/\'"'"'/\'"'"'\"\'"'"'\"\'"'"'/g;

                $expected .= "$check\n";
                $updated .= " $escaped_check\n";
            }

            # Show rest not matched lines
            for (my $i=$start_line; $i <= $#lines; $i++) {
                my $is_skip = 0;
                my $line_expr = simplify($lines[$i]);
                foreach my $skip_expr (@skip) {
                    if ($skip_expr eq $line_expr) {
                        $is_skip = 1;
                        last;
                    }
                }
                if (!$is_skip) {
                    $results .= "\n" if ($is_new_line); $is_new_line = 0;
                    $results .= "  \e[30;40m '${GFC0}' $lines[$i]\n";
                }
            }

             # Prepare to transfer to bash
            $results =~ s/\'"'"'/\'"'"'\"\'"'"'\"\'"'"'/gm;
            $expected =~ s/\'"'"'/\'"'"'\"\'"'"'\"\'"'"'/gm;

            # Transfer results to bash
            print "local gf_updated='"'"'$updated'"'"'\n";
            print "local gf_results='"'"'$results'"'"'\n";
            print "local gf_expected='"'"'$expected'"'"'\n";
            print "local gf_is_match=$is_match"
        '

        local content="$(cat "$GF_I_RUN_DIR/logs/run.$GF_RUN_INDEX.log")"
        eval "$(echo "===GF_CHECK==="$'\n'"$GF_CHECK_LOG_MESSAGES"$'\n'"===GF_SKIP==="$'\n'"$GF_CHECK_LOG_MESSAGES_SKIP"$'\n'"===GF_CONTENT==="$'\n'"$content" | perl -e "$gf_perl_script")"
        # gf_debug gf_perl_script
        gf_debug gf_updated gf_results gf_expected gf_is_match

        if [ -n "$gf_results" ]; then
            echo
            echo -e "\e[90;40m I ${GFC0} Color map:"
            echo
            echo -e "  ${GFM2}  ${GFC0} Exact match  ${GFM3}  ${GFC0} Text is similar  ${GFM5}  ${GFC0} Line moved"
            echo -e "  ${GFM6}  ${GFC0} Text match   ${GFM4}  ${GFC0} Expected line    ${GFM1}  ${GFC0} Not match"
            echo
            echo -e "${GFM2} I ${GFC0} Checking ${GFC7}./logs/run.$GF_RUN_INDEX.log${GFC0} expected lines:"
            echo
            echo "$gf_results"

            # Print updated expression to match
            if [ "$gf_is_match" == "1" ]; then
                echo -e "${GFM2} I ${GFC0} Check finished. Matched"
            else
                echo -e "${GFM3} I ${GFC0} Update pattern to match current log:\n"
                echo "$gf_updated"
                echo -e "${GFM3} I ${GFC0} Check finished. Mismatched"
            fi
        fi
    fi
}

##################################################
gf_help_section "Information commands"
##################################################
gf_help_command '
    {gf_help_section} <title>
    Set section to {title} for command help added using gf_help_command commands.
'

gf_help_command '
    {gf_help_command} <description>
    Add multi-line command {description} into current help section.
    Use gf_help_section to change current help section.
    Text in the {description} can be highlighted if put in {\{...\}} brackets.
'
gf_help_command '
    {gf_set_window_title} <title> [<minimized>]
    Set {title} to display it in taskbar and as current log window.
    Separate window title {minimized} supported when window minimized to toolbar.
'
gf_help_command '
{gf_info} <gf_message> [<function>]
    Show information {message}.
    Option {function} can be used to print message source.

{gf_warning} <message> [<function>]
    Show warning {message}.
    Option {function} can be used to print message source.

{gf_error} <message> [<function>]
    Show error {message}.
    Option {function} can be used to print message source.
'

##################################################
gf_help_section "User script"
##################################################

# Reserved to keep help page order

##################################################
gf_help_section "Generic Flow special variables"
##################################################

gf_help_command '

Please avoid use of variables starting with {GF_} and {gf_} in GF scripts.

Tasks

    {$TASK_NAME}          Current task name
    {$LAST_TASK_NAME}     Last submitted task name
    {$MOTHER_TASK_NAME}   Mother task name of current task

Files and directories

    {$GF_ROOT}            Generic Flow root directory containing ./bin/gflow binary

    {$GF_SCRIPT}          Currently running GF script
    {$GF_SCRIPT_DIR}      Currently running GF script directory

    {$GF_SCRIPT_COPY}     Path to the copy of currently running GF script
    {$GF_SCRIPT_SOURCES}  Path to the copy of sourced files content

    {$GF_WORK_DIR}        Absolute path to working directory where run directories created
    {$GF_RUN_DIR}         Absolute path to current run directory ($GF_WORK_DIR/$GF_RUN_NAME)

    {$GF_RUN_NAME}        Current run name (GF script name by default)
    {$GF_RUN_INDEX}       Current index of run in run directory (starting with 1)

    {$GF_I_WORK_DIR}      Absolute path to internal flow directory if -internal option used
    {$GF_I_RUN_DIR}       Absolute path to internal run directory ($GF_I_WORK_DIR/$GF_RUN_NAME)
'

##################################################
gf_help_section "Terminal hotkeys"
##################################################

gf_help_command '
    Keyboard shortcuts

    {Shift+PgUp}   Scroll half page back
    {Shift+PgDn}   Scroll half page forward
    {Ctrl}+{1}..{6}    Font scale
    {Alt}+{Down}     Minimize window
'

gf_help_command '
    Mouse shortcuts

    {Alt}+{MouseL}   Main menu
    {Alt}+{MouseM}   Terminal menu
    {Alt}+{MouseR}   Font menu
    {Ctrl}+{MouseL}  Smallest font size
    {Ctrl}+{MouseR}  Default font size
    {Ctrl}+{Wheel}   Font scale
    {Shift}+{Wheel}  Fast scroll
'

##################################################
gf_help_section "Generic Flow command line usage"
##################################################

gf_help_command '
    {'"$GF_BIN_FILE"'} [-script] <tasks.gf> [<options>]

    {-script} ...   Generic Flow task description script.

    {-dir} ...      Working directory. By default is current directory.
    {-run} ...      Run name or run directory if specified as dir. By default is Generic Flow script name.
    {-resume} ...   Select run directory to resume
    {-last} ...     Run in the last run directory
    {-internal} ... Optional separate directory to store internal flow files. By default is working directory.

    {-clean}        Interactive clean of working directory.

    {-ref} ...      Use reference run to reproduce the flow (run directory or *.sources.gf script).
    {-reuse}        Reuse sources from reference run when available.
    {-update}       Use updated sources instead of reference ones when available.

    {-suffix} ...   Add user suffix to run name. By default is empty.
    {-today}        Add month and day suffix to run name automatically.
    {-yesterday}    Add yesterday month and day suffix to run name automatically.
    {-now}          Add current date and time suffix to run name automatically.

    {-new}          Run in new incremented directory, default mode.
    {-save}         Save existing run data into ./saved directory.
    {-reset}        Reset and clean run directory if exists.
    {-continue}     Continue in existing directory, use data that is ready.

    {-skip_errors}  Continue even if script errors found
    {-verbose}      Verbose mode. Show 10 last lines of failed task log.
    {-lines}        Override number of lines to show in verbose mode.

    {-ask}          Ask for start confirmation for each task
    {-skip}         Skip already running or finished tasks.
    {-restart}      Restart already running or finished tasks.
    {-incr}         Auto-add increment suffix to already running or finished tasks.
    {-tag} ...      Add user tag to the name of incremental tasks. By default is empty.
    {-choices}      Use predefined choices instead of interactive input

    {-tasks} ...    Run tasks matching specified patterns only. Example: {-tasks '"'"'Task*'"'"'}
    {-enable} ...   Enable tasks by name pattern. Example: {-enable '"'"'Report* Other'"'"'}
    {-disable} ...  Disable tasks by name pattern. Example: {-disable '"'"'*Fill Other'"'"'}

    {-utils}        Run sub-shell with Generic Flow environment.
    {-gen}          Generate scripts only, not run.

    {-local}        Run tasks using local machine resources
    {-sge}          Run tasks using Sun Grid Engine
    {-lsf}          Run tasks using LSF Grid Engine

    {-sge_options}  Additional SGE options
    {-lsf_options}  Additional LSF options

    {-no_win}       Start in existing terminal, do not create new window for the main tool.
    {-sync}         Do not release current terminal until flow completed.
    {-silent}       Run tasks silently without creating terminal windows.
    {-hide}         Hide main tool window while running the flow.
    {-auto_close}   Close session window when completed

    {-smooth}       Use smooth terminal font (Terminus)
    {-white}        Use white terminal background
    {-focus}        Window size controled by mouse focus
    {-raise}        Raise main window when done

    {-shell} ...    Set default task shell. Example: {-shell /bin/bash}.

    {-help} [...]   Show help pages. Optional multiple regexp filters can be applied.
                    Example: '"$GF_BIN_FILE"' {-help variables}
    {-info} [...]   Show help and GF script parts matching regexp filters.
                    Shows interactive help shell if no filter specified.
                    Example: '"$GF_BIN_FILE"' {-info}
                             '"$GF_BIN_FILE"' {-info directory\|file}
'

##################################################
# Content functions
##################################################

# Perl commands to parse GF script content
gf_parse_gf_script='
    my $active_brackets;
    my @commands;
    my $command = "";
    my $is_new_command = 1;
    while (<STDIN>) {
        next if (/^\s*;?\s*\#/ && ($active_brackets eq ""));
        if ($is_new_command) {
            push @commands, $command;
            $command = "$_";
        } else {
            $command .= "$_";
        }
        $is_new_command = 0;
        while (s/^.*?([^\{\}\"\'"'"']?)([\{\}\'"'"'\"])//) {
            my $is_escape = (($1 eq "\\") && ($last_bracket ne "'"'"'"));
            my $current_bracket = $2;
            if (!$is_escape) {
                if (($current_bracket eq "'"'"'") || ($current_bracket eq "\"")) {
                    $active_brackets .= $current_bracket if (!($active_brackets =~ s/$current_bracket[^$current_bracket]*$//ee));
                } elsif ($current_bracket eq "\{") {
                    $active_brackets .= $current_bracket if (($active_brackets eq "") || ($active_brackets =~ /\{/));
                } elsif ($current_bracket eq "\}") {
                    if ($active_brackets =~ s/\{([^\{]*)$//) {
                        my $incorrect_brackets = $1;
                        if ($incorrect_brackets ne "") {
                            my $incorrect_command = $command;
                            $incorrect_brackets =~ s/\"/\\\"/g;
                            $incorrect_command =~ s/\\e/\\\\e/gm;
                            $incorrect_command =~ s/([\"\$\\])/\\$1/gm;
                            $incorrect_command =~ s/^/\e\[31;41m \e\[0m /gm;
                            push @commands, "gf_error \"Unbalanced '${GFH1}'$incorrect_brackets'${GFC0}' inside '${GFH7}'{}'${GFC0}' brackets in command below\n\n$incorrect_command\"\n";
                        }
                    }
                }
            }
        }
        $is_new_command = 1 if ((!/\\$/ || /\\\\$/) && ($active_brackets eq ""));
    }
    push @commands, $command;
    $active_brackets =~ s/\"/\\\"/g;
    push @commands, "gf_error \"Unbalanced '${GFH1}'$active_brackets'${GFC0}' in the end of file.\"\n" if ($active_brackets ne "");
'

# Get file content checking if it has changed
function gf_load_file_content {
    local gf_file="$1"

    # Check alternative file
    if [ ! -f "$gf_file" ]; then
        local gf_alternative_file="$(gf_full_path_rel "$GF_SCRIPT/.." "$gf_file")"
        gf_debug gf_alternative_file
        if [ ! -f "$gf_alternative_file" -a -n "$GF_LAST_FILE" ]; then
            gf_alternative_file="$(gf_full_path_rel "$GF_LAST_FILE/.." "$gf_file")"
            gf_debug gf_alternative_file
        fi
        [[ -f "$gf_alternative_file" ]] && gf_file="$gf_alternative_file"
    fi

    local gf_file_full_name=$(gf_full_path "$gf_file")
    local gf_file_short_name=$(gf_get_short_path "$gf_file_full_name")

    gf_debug GF_LAST_FILE gf_file gf_file_short_name

    # Reset internal variables
    local gf_choice=

    # Reset result
    GF_LAST_FILE_STATUS=
    GF_LAST_FILE_CONTENT=
    GF_LAST_FILE="$gf_file_full_name"

    # No sources content - default choice
    [[ -z "$GF_REF_CONTENT" ]] && gf_choice=U

    # Already made choice
    [[ -z "$gf_choice" ]] && gf_choice=$(echo "$GF_REF_CHOICES" | sed -ne "s|^$gf_file_short_name=\(.\)\$|\1|p")

    # Global choice
    [[ -z "$gf_choice" ]] && gf_choice="$GF_REF_CHOICE"

    # Get current content
    if [ "$gf_choice" == "U" -o "$gf_choice" == "US" ]; then
        if [ -e "$gf_file" ]; then
            GF_LAST_FILE_CONTENT="$(cat "$gf_file")"
            GF_LAST_FILE_STATUS=IU
        elif [ "$gf_choice" == "US" ]; then
            GF_LAST_FILE_CONTENT="$(gf_get_saved_file_content "$gf_file")"
            if [ -z "$GF_LAST_FILE_CONTENT" ]; then
                GF_LAST_FILE_STATUS=EU
            else
                GF_LAST_FILE_STATUS=EUIS
            fi
        else
            GF_LAST_FILE_STATUS=EU
        fi

    # Reuse existing content
    elif [ "$gf_choice" == "S" -o "$gf_choice" == "SU" ]; then
        GF_LAST_FILE_CONTENT="$(gf_get_saved_file_content "$gf_file")"
        if [ -z "$GF_LAST_FILE_CONTENT" ]; then
            if [ "$gf_choice" == "SU" ]; then
                if [ -e "$gf_file" ]; then
                    GF_LAST_FILE_CONTENT="$(cat "$gf_file")"
                    GF_LAST_FILE_STATUS=ESIU
                else
                    GF_LAST_FILE_STATUS=ES
                fi
            else
                GF_LAST_FILE_STATUS=ES
            fi
        else
            GF_LAST_FILE_STATUS=IS
        fi

    # Ask user if still not decided
    else

        # Current content
        local gf_current_content=
        if [ -e "$gf_file" ]; then
            gf_current_content="$(cat "$gf_file")"
        else
            gf_choice=S
        fi

        # Reused content
        local gf_saved_content="$(gf_get_saved_file_content "$gf_file")"

        # No saved content exist
        [[ -z "$gf_saved_content" ]] && gf_choice=U

        # Use current version if content not changed
        if [ -z "$gf_choice" ]; then
            [[ "$(echo "$gf_saved_content" | md5sum)" == "$(echo "$gf_current_content" | md5sum)" ]] && gf_choice=U
        fi

        # Ask user if content changed
        if [ -z "$gf_choice" ]; then
            gf_choose -variable gf_choice -toggles A -keys DUS -time 300 -default AU -message "Source file ${GFC7}$gf_file${GFC0} updated.
              ${GFH6}[D]${GFC0} Show differences$gf_message
              ${GFH2}[U]${GFC0} Use updated version
              ${GFH3}[S]${GFC0} Reuse saved version (default after 5 minutes)
              ${GFH4}[A]${GFC0} Apply to all different files
            "

            # Show differences
            if [[ $gf_choice = *D* ]]; then
                local gf_perl_script='
                    my $mode1 = "97m * ";
                    my $mode2 = "96m * ";
                    while (<STDIN>) {
                        if (s/^\</  \e\[40;$mode1\e\[0m/) {
                            print;
                        } elsif (s/^\>/  \e\[40;$mode2\e\[0m/) {
                            print;
                        } elsif (/\da\d/) {
                            $mode1 = "92m + ";
                            $mode2 = "92m + ";
                        } elsif (/\dc\d/) {
                            $mode1 = "93m * ";
                            $mode2 = "92m * ";
                        } elsif (/\dd\d/) {
                            $mode1 = "91m - ";
                            $mode2 = "91m - ";
                        }
                    }
                '
                # gf_debug gf_perl_script
                diff --normal <(echo "$gf_saved_content") <(echo "$gf_current_content") | perl -e "$gf_perl_script"
                gf_choose -variable gf_choice -toggles A -keys US -time 300 -default AU -message "Source file ${GFC7}$gf_file${GFC0} updated
                  ${GFH2}[U]${GFC0} Use updated version
                  ${GFH3}[S]${GFC0} Reuse saved version (default after 5 minutes)
                  ${GFH4}[A]${GFC0} Apply to all different files
                "
            fi

            # Global choice
            if [[ $gf_choice = *A* ]]; then

                # Reuse
                if [[ $gf_choice = *S* ]]; then
                    gf_choice=S
                    GF_REF_CHOICE=SU

                # Update
                elif [[ $gf_choice = *U* ]]; then
                    gf_choice=U
                    GF_REF_CHOICE=US
                fi
            fi
        fi

        # Only one selection per file
        GF_REF_CHOICES+="$gf_file_short_name=$gf_choice"$'\n'

        # Reuse content from saved file
        if [ "$gf_choice" == "S" ]; then
            GF_LAST_FILE_CONTENT="$gf_saved_content"
            GF_LAST_FILE_STATUS=IS

        # Use current content
        else
            GF_LAST_FILE_CONTENT="$gf_current_content"
            if [ -e "$gf_file" ]; then
                GF_LAST_FILE_STATUS=IU
            else
                GF_LAST_FILE_STATUS=EU
            fi
        fi
    fi
}

# Save sourced file content
function gf_save_file_content {
    [[ -n "$GF_PRELOAD_MODE" ]] && return
    eval "$(gf_update_function)"

    local gf_file_short="$(gf_get_short_path "$(gf_full_path "$1")")"
    local gf_file_full="$2"
    local gf_content="$3"

    # Save content only once
    if [ -z "$(echo "$GF_REF_SAVED" | grep -Fx -- "$gf_file_short")" ]; then
        if [ -e "$gf_file_full" -o -n "$gf_content" ]; then
            local gf_file_content=
            gf_file_content+="#==================================================================================================="$'\n'
            gf_file_content+="# GF source file: $gf_file_short"$'\n'
            gf_file_content+="# $gf_file_full"$'\n'
            gf_file_content+="#==================================================================================================="$'\n'
            if [ -z "$gf_content" ]; then
                gf_file_content+="$(cat "$gf_file_full")"$'\n'
            else
                gf_file_content+="$gf_content"$'\n'
            fi
            gf_file_content+="#==================================================================================================="$'\n'$'\n'

            echo "$gf_file_content" >> "$GF_I_RUN_DIR/scripts/$(basename "$GF_SCRIPT" .gf).$GF_RUN_INDEX.sources.gf"
            GF_REF_SAVED+="$gf_file_short"$'\n'
        fi
    fi

    eval "$(gf_revert_function)"
}

# Get saved file content
function gf_get_saved_file_content {
    local gf_file="$1"
    local gf_file_full_name=$(gf_full_path "$gf_file")
    local gf_file_short_name=$(gf_get_short_path "$gf_file_full_name")
    local gf_perl_script='
        my $checked_file = '"'$gf_file_short_name'"';
        my $content = "";
        my $is_required_file = 0;
        while (<STDIN>) {
            if (/^\#===================================================================================================/) {
                if ($is_required_file == 1) {
                    $is_required_file = 2;
                } else {
                    $is_required_file = 0;
                }
                next;
            }
            if (s/^\#\s*GF\s+source\s+file\s*:\s*//i) {
                $is_required_file = 0;
                my $current_file = $_;
                $current_file =~ s/\s+$//;
                if ($current_file eq $checked_file) {
                    $content = "";
                    $is_required_file = 1;
                }
            } elsif ($is_required_file == 1) {
                $is_required_file = 2 if (!/^\s*#/);
            }

            $content .= $_ if ($is_required_file == 2);
        }
        print $content;
    '
    # gf_debug gf_perl_script
    echo "$GF_REF_CONTENT" | perl -e "$gf_perl_script"
}

# Load script options
function gf_load_options {

    # Parse command line options
    GF_TASK_OPTIONS_PRIORITY=0
    GF_OPTIONS_SOURCE=C
    GF_PRELOAD_MODE=1
    gf_set_flow_options "$@"
    GF_PRELOAD_MODE=

    # Current script name
    if [ -n "$GF_SCRIPT" ]; then
        GF_SCRIPT_NAME=$(basename "$GF_SCRIPT")
        GF_SCRIPT_DIR=$(dirname "$(gf_full_path "$GF_SCRIPT")")
    fi

    # Load options from the script when it exists
    if [ -e "$GF_SCRIPT" ]; then

        # Print task script name
        if [ -z "$GF_HELP_MODE" ]; then
            gf_add_message $'\n'
            gf_info_message "Tasks script is ${GFH7}$GF_SCRIPT${GFC0}."
            echo -ne "\e]1;L - $GF_SCRIPT_NAME\a\e]2;Loading - $GF_SCRIPT_NAME\a"
        fi

        # Select between run and sources script
        local gf_sources_file=
        if [ -n "$GF_REF_FILE" ]; then

            # Select reference file
            for gf_sources_file in \
                "$GF_REF_FILE/$(basename "$GF_SCRIPT" .gf).sources.gf" \
                "$GF_INT_DIR/$(basename "$GF_REF_FILE")/$(basename "$GF_SCRIPT" .gf).sources.gf" \
                "$GF_I_WORK_DIR/$(basename "$GF_REF_FILE")/$(basename "$GF_SCRIPT" .gf).sources.gf" \
                "$GF_WORK_DIR/$(basename "$GF_REF_FILE")/$(basename "$GF_SCRIPT" .gf).sources.gf" \
            ; do
                [[ -e "$gf_sources_file" ]] && GF_REF_FILE="$gf_sources_file"
            done

        # Look for sources file in current script location
        else
            gf_sources_file="$(dirname "$GF_SCRIPT")/$(basename "$GF_SCRIPT" .gf).sources.gf"
            [[ -e "$gf_sources_file" ]] && GF_REF_FILE="$gf_sources_file"
        fi

        # Load sources file content
        if [ -n "$GF_REF_FILE" ]; then
            if [ -d "$GF_REF_FILE" ]; then
                gf_fatal "No reference script ${GFH1}$GF_REF_FILE/$(basename "$GF_SCRIPT" .gf).sources.gf${GFC0} found."
            elif [ -e "$GF_REF_FILE" ]; then
                GF_REF_CONTENT="$(cat "$GF_REF_FILE")"
                gf_info "Reference script is ${GFH7}$GF_REF_FILE${GFC0}."
            else
                gf_fatal "No reference ${GFH1}$GF_REF_FILE${GFC0} found."
            fi
        fi

        # Script options mark
        GF_TASK_OPTIONS_PRIORITY=1
        GF_OPTIONS_SOURCE=S

        # Preload GF script recusively
        local gf_followed_files=
        function gf_preload {
            local gf_file="$1"
            if [ -z "$(echo "$gf_followed_files" | grep -x "$gf_file" || :)" ]; then
                gf_followed_files+=$'\n'"$gf_file"
                gf_load_file_content "$gf_file"
                local gf_content="$GF_LAST_FILE_CONTENT"
                local gf_perl_script='
                    '"$gf_parse_gf_script"'
                    foreach (@commands) {
                        if (s/^(\s*)(gf_source|source|\.)(\s)/$1."gf_preload".$3/e) {
                            s/\s+-once\b//g;
                        }
                        print if (/^\s*(gf_set_flow_options|gf_use_options|gf_use_option|gf_preload|gf_save_source)\s/);
                    }
                '
                local gf_commands="$(echo "$gf_content" | perl -e "$gf_perl_script")"
                local gf_last_file="$GF_LAST_FILE"
                eval "$gf_commands"
                GF_LAST_FILE="$gf_last_file"
                # gf_debug gf_perl_script
                gf_debug gf_commands
            fi
        }

        # Preload options from the script
        if [ -e "$GF_SCRIPT_DIR/$GF_SCRIPT_NAME" ]; then
            GF_PRELOAD_MODE=1
            gf_preload "$GF_SCRIPT_DIR/$GF_SCRIPT_NAME"
            GF_LAST_FILE=
            GF_PRELOAD_MODE=
        fi
    fi

    # Get run name from tasks script name
    if [ -z "$GF_RUN_NAME" ]; then
        GF_RUN_NAME=$(echo "$(basename "$(gf_full_path "$GF_SCRIPT")")" | sed 's/\.[^\.]\+$//')
    fi

    # Check run name
    if [ -z "$GF_RUN_NAME" ]; then
        GF_INTERACTIVE_MODE=1
        return
    fi

    # Resume run mode
    if [ $GF_RUN_SUFFIX_RESUME != 0 ]; then

        # Choose existing run
        if [ $GF_RUN_SUFFIX_RESUME == 1 ]; then
            local gf_run_script=
            gf_choose_file_dir_task -variable gf_run_script -prompt "Please select run to resume:" -dirs "
                $GF_RUN_NAME*/
            "
        # Auto-detect last run name mode
        elif [ $GF_RUN_SUFFIX_RESUME == 2 ]; then
            local gf_run_script="$(ls -1trd "$GF_WORK_DIR/$GF_RUN_NAME"*/ "$GF_WORK_DIR/"*"/$(basename "$GF_SCRIPT")" 2> /dev/null | tail -1)"
        fi

        # Resume
        if [ -n "$gf_run_script" ]; then
            if [ -d "$gf_run_script" ]; then
                GF_RUN_NAME=$(basename "$gf_run_script")
            else
                GF_RUN_NAME=$(basename "$(dirname "$gf_run_script")")
            fi
            [[ -z "$GF_HELP_MODE" ]] && gf_info_message "Run name changed to ${GFC7}$GF_RUN_NAME${GFC0}."
            GF_RUN_AUTO_INCREMENT=
            GF_RUN_SUFFIX=
        else
            gf_warning_message "No run directory to resume detected."
        fi
    fi

    # Apply run suffix
    GF_RUN_NAME+="$GF_RUN_SUFFIX"
}

# Preload script steps
function gf_preload_script {
    local script="$1"
    gf_set_termination_traps Loading "$(basename "$script")" "$script"
    function gf_preload {
        local gf_file="$1"
        if [ -z "$(echo "$gf_followed_files" | grep -x "$gf_file" || :)" ]; then
            gf_followed_files+=$'\n'"$gf_file"
            GF_SOURCE_FILE="$gf_file"
            gf_load_file_content "$gf_file"
            local gf_content="$GF_LAST_FILE_CONTENT"
            local gf_last_file="$GF_LAST_FILE"
            if [ -n "$gf_content" ]; then
                gf_info "Loading $(gf_get_short_path "$(gf_full_path "$gf_file")")"
                local gf_perl_script='
                    '"$gf_parse_gf_script"'
                    foreach (@commands) {
                        s/^(\s*)(gf_fatal)(\s)/$1."gf_error".$3/e;
                        if (s/^(\s*)(gf_source|source|\.)(\s)/$1."gf_preload".$3/e) {
                            s/\s+-once\b//g;
                        }
                        print if (/^\s*(gf_preload|gf_warning|gf_error)\s/ || /^\s*\w+=[^\s]/);
                    }
                '
                local gf_commands="$(echo "$gf_content" | perl -e "$gf_perl_script")"
                eval "$gf_commands"
                # gf_debug gf_perl_script
                gf_debug gf_commands
            fi
            GF_LAST_FILE="$gf_last_file"
        fi
    }

    # Preload options from the script
    gf_followed_files=
    GF_PRELOAD_MODE=1
    gf_preload "$script"
    GF_LAST_FILE=
    GF_PRELOAD_MODE=
}

# Compose help filters
function gf_update_info_filters {
    GF_FILTER_EXPRESSIONS=
    local filter
    for filter in "$@"; do
        if [ "$filter" == "." ]; then
            gf_error "Filter ${GFH7}$filter${GFC0} cannot be used in ${GFH7}-info${GFC0} option. Wildcards are substituted in bash, please be careful."
        elif [ -n "$filter" ]; then
            GF_FILTER_EXPRESSIONS+="push @filters, '$(echo "$filter" | sed -e "s/\([\'\"]\)/\\\\\1/g; s/\([\\]\)/\\\\\\1/g; s/\(\$.\)/\\\\\1/g")';"$'\n'
        fi
    done
}

# Show basic help pages
function gf_show_help {
    gf_update_info_filters "$1"

    # Filter help pages
    local gf_perl_script='
        my $section;
        my %data;
        my @sections;
        my @filters;
        '"$GF_FILTER_EXPRESSIONS"'
        while (<STDIN>) {
            if (/^gf_help_section=>\s*(.+?)\s*$/) {
                $section = $1;
                push @sections, $section if (!$sections{$section});
                $sections{$section} = 1;
            } else {
                $data{$section} .= $_;
            }
        }
        foreach my $section (@sections) {
            my $section_title = $section;
            my $is_section_match = 0;
            foreach my $filter (@filters) {
                $is_section_match = 1 if ($section_title =~ s/($filter)/\e\[92m$1\e\[0m/gm);
            }
            my @functions;
            foreach (split (/gf_help_command=>/, $data{$section})) {
                s/^[\s\n]+//;
                s/[\s\n]+$//;
                my $is_function_match = 0;
                foreach my $filter (@filters) {
                    $is_function_match = 1 if (s/($filter)/'${GFH2}'$1'${GFC0}'/gm);
                }
                push @functions, $_ if (($#filters < 0) || $is_function_match || $is_section_match);
            }
            if ($#functions >= 0) {
                print "######################################################################\n";
                print "# $section_title\n";
                print "######################################################################\n\n";
                foreach my $function (sort @functions) {
                    $function =~ s/\{/'${GFH7}'/gm;
                    $function =~ s/\}/'${GFC0}'/gm;
                    $function =~ s/\\\e\[97m/\{/gm;
                    $function =~ s/\\\e\[0m/\}/gm;
                    print $function."\n\n" if ($function);
                }
            }
        }
    '
    local help_pages="$(echo "$GF_TOOL_USAGE" | perl -e "$gf_perl_script")"
    # gf_debug gf_perl_script
    gf_debug help_pages

    # Print found help pages
    if [ -n "$help_pages" ]; then
        echo "$help_pages"
        GF_HELP_FOUND=1
    fi
}

# Show script information
function gf_show_script_info {
    local script="$1"
    gf_update_info_filters "$2"

    # Script pages results
    local help_pages=

    # Check GF script
    if [ -z "$script" ]; then
        gf_error "GF script argument is empty."

    # GF script should exist
    elif [ ! -e "$script" ]; then
        gf_error "GF script to filter ${GFH7}$script${GFC0} does not exist."

    # Preload GF script recusively for non-empty filter
    elif [ -n "$GF_FILTER_EXPRESSIONS" ]; then
        local gf_followed_files=
        function gf_filter_file {
            local gf_file=
            while [ $# -gt 0 ]; do
                case "$1" in
                    -* )
                    ;;
                    * )
                        gf_file="$1"
                    ;;
                esac
                shift
            done
            if [ -z "$(echo "$gf_followed_files" | grep -x "$gf_file" || :)" ]; then
                gf_followed_files+=$'\n'"$gf_file"
                local gf_last_file="$GF_LAST_FILE"
                local gf_last_status="$GF_LAST_FILE_STATUS"
                local gf_last_content="$GF_LAST_FILE_CONTENT"
                gf_load_file_content "$gf_file"
                local gf_perl_script='
                    my @filters;
                    '"$GF_FILTER_EXPRESSIONS"'
                    my @results;
                    my $result = "";
                    my $brackets = "";
                    my $is_new_line = 0;
                    while (<STDIN>) {
                        my $is_match = 0;
                        my $line = $_;
                        foreach my $filter (@filters) {
                            $is_match = 1 if ($line =~ s/($filter)/\e\[92m$1\e\[0m/gm);
                        }
                        if (($is_match || $is_new_line || ($brackets ne "")) && ($_ ne "")) {
                            $result .= $line;
                            if (/\\$/) {$is_new_line = 1} else {$is_new_line = 0}
                            while (s/^[^\'"'"'\"\{\}\(\)\[\]]*([\'"'"'\"\{\}\(\)\[\]])//) {
                                my $symbol = $1;
                                if ($symbol eq "'"'"'") {$brackets .= $symbol if (!($brackets =~ s/\'"'"'$//))}
                                if ($symbol eq "\"") {$brackets .= $symbol if (!($brackets =~ s/\"$//))}
                                $brackets =~ s/\{$// if ($symbol eq "\}");
                                $brackets =~ s/\($// if ($symbol eq "\)");
                                $brackets =~ s/\[$// if ($symbol eq "\]");
                                $brackets .= $symbol if ($symbol eq "\{");
                                $brackets .= $symbol if ($symbol eq "\(");
                                $brackets .= $symbol if ($symbol eq "\[");
                            }
                        }
                        if (!$is_match && !$is_new_line && ($brackets eq "") && ($result ne "")) {
                            push @results, $result;
                            $result = "";
                        }
                    }
                    push @results, $result if ($result ne "");
                    if ($#results >= 0) {
                        print "######################################################################\n";
                        print "# Included script '${GFH7}''"$(basename "$gf_file")"''${GFC0}' filtered content\n";
                        print "######################################################################\n";
                        print "'${GFH4}''"$(gf_full_path "$GF_LAST_FILE")"''${GFC0}'\n\n";
                        foreach (@results) {
                            s/\t/    /g;
                            my $indent = "";
                            $indent = $1 if (/^(\s*)/);
                            foreach my $line (split /\n/, $_) {
                                if ($line =~ /^(\s*)/) {
                                    $indent = $1 if (length($indent) > length($1));
                                }
                            }
                            s/^$indent//gm if ($indent ne "");
                            print "$_\n";
                        }
                    }
                '
                # gf_debug gf_perl_script
                local gf_text="$(echo "$GF_LAST_FILE_CONTENT" | perl -e "$gf_perl_script")"
                if [ -n "$gf_text" ]; then
                    if [ -n "$help_pages" ]; then
                        help_pages+=$'\n'$'\n'"$gf_text"
                    else
                        help_pages="$gf_text"
                    fi
                fi
                GF_LAST_FILE="$gf_last_file"
                GF_LAST_FILE_STATUS="$gf_last_status"
                GF_LAST_FILE_CONTENT="$gf_last_content"
            fi
        }
        function gf_filter_script {
            local gf_file="$1"
            if [ -z "$(echo "$gf_followed_files" | grep -x "$gf_file" || :)" ]; then
                gf_followed_files+=$'\n'"$gf_file"
                gf_load_file_content "$gf_file"
                local gf_content="$GF_LAST_FILE_CONTENT"
                local gf_perl_script='
                    '"$gf_parse_gf_script"'
                    foreach (@commands) {
                        if (s/^(\s*)(gf_source|source|\.)(\s)/$1."gf_filter_script".$3/e) {
                            s/\s+-once\b//g;
                        }
                        s/^(\s*)(gf_save_source)(\s)/$1."gf_filter_file".$3/e;
                        print if (/^\s*(gf_filter_script|gf_filter_file)\s/ || /^\s*\w+=[^\s]/);
                    }
                '
                local gf_commands="$(echo "$gf_content" | perl -e "$gf_perl_script")"
                local gf_last_file="$GF_LAST_FILE"
                eval "$gf_commands"
                GF_LAST_FILE="$gf_last_file"
                # gf_debug gf_perl_script
                gf_debug gf_commands
                local gf_perl_script='
                    my @filters;
                    '"$GF_FILTER_EXPRESSIONS"'
                    '"$gf_parse_gf_script"'
                    my @functions;
                    foreach (@commands) {
                        s/^[\s\n]+//;
                        s/[\s\n]+$//;
                        my $is_match = 0;
                        foreach my $filter (@filters) {
                            $is_match = 1 if (s/($filter)/\e\[92m$1\e\[0m/gm);
                        }
                        s/^(gf_\w+|function)\s/'${GFH7}'$1'${GFC0}' /;
                        push @functions, $_ if ($is_match && ($_ ne ""));
                    }
                    if ($#functions >= 0) {
                        print "######################################################################\n";
                        print "# GF script '${GFH7}''"$(basename "$gf_file")"''${GFC0}' filtered commands\n";
                        print "######################################################################\n";
                        print "'${GFH4}''"$(gf_full_path "$GF_LAST_FILE")"''${GFC0}'\n\n";
                        foreach (@functions) {
                            print "$_\n\n";
                        }
                    }
                '
                local gf_text="$(echo "$gf_content" | perl -e "$gf_perl_script")"
                # gf_debug gf_perl_script
                gf_debug gf_text
                if [ -n "$gf_text" ]; then
                    if [ -n "$help_pages" ]; then
                        help_pages+=$'\n'$'\n'"$gf_text"
                    else
                        help_pages="$gf_text"
                    fi
                fi

                if [ ! -e "$gf_file" -a -z "$gf_content" ]; then
                    gf_error "Source file ${GFH7}$gf_file${GFC0} not found."
                fi
            fi
        }

        # Switch to preload mode
        GF_PRELOAD_MODE=1

        # Preload options from the script
        gf_filter_script "$script"
        GF_LAST_FILE=
        GF_PRELOAD_MODE=
    fi

    # Print found help pages
    if [ -n "$help_pages" ]; then
        echo $'\n'"$help_pages"
        GF_HELP_FOUND=1
    fi
}

# Show interactive help
function gf_show_interactive_help {
    local script="$1"

    # Wait for user filter input
    if [ "$GF_HELP_MODE" == "HELP" ]; then
        echo -ne "${GFM4} \e[0;94m Filter help (regexp):${GFC0}"
    else
        echo -ne "${GFM4} \e[0;94m Filter GF script (regexp):${GFC0}"
    fi
    read -p " " -re gf_filters

    if [ "$gf_filters" == '*' -o "$gf_filters" == '.*' ]; then
        gf_error "Incorrect filter.\n"
        gf_filters=
    fi

    # Filter script and help sections
    if [ -n "$gf_filters" ]; then
        GF_HELP_FOUND=

        # Show help pages
        echo; gf_show_help "$gf_filters"
        [[ -z "$GF_FILTER_EXPRESSIONS" ]] && gf_error "GF script filters are empty."

        # Show script pages in -info mode
        if [ "$GF_HELP_MODE" == "INFO" ]; then
            gf_show_script_info "$script" "$gf_filters"
        fi

        # No help sections found
        if [ -z "$GF_HELP_FOUND" ]; then
            local gf_perl_script='
                my @filters;
                '"$GF_FILTER_EXPRESSIONS"'
                print "No information matching regexp '${GFH7}'".join("'${GFC0}', '${GFH7}'", @filters)."'${GFC0}' found.";
            '
            # gf_debug gf_perl_script
            gf_error "$(perl -e "$gf_perl_script")"
        fi

        echo
    fi
}

##################################################
# Preparation functions
##################################################

function gf_is_file_updated {
    local file="$1"
    local status_var="$2"
    local last_status="$(eval "echo \"\$$status_var\"")"
    local new_status="$(stat -c %Z "$file" || :)"
    gf_debug file last_status
    if [ "$last_status" == "$new_status" ]; then
        echo 0
    else
        eval "$status_var=\"$new_status\""
        echo 1
    fi
}

# Get current run summary
function gf_get_run_summary {
    local gf_run_name="$1"
    local gf_internal_dir="$2"
    local gf_work_dir="$3"
    local gf_need_summary="$4"
    if [ -d "$gf_internal_dir" -o -d "$gf_work_dir" ]; then
        [[ ! -d "$gf_internal_dir" ]] && gf_internal_dir="$gf_work_dir"
        [[ ! -d "$gf_work_dir" ]] && gf_work_dir="$gf_internal_dir"
        local gf_disk_size="$(du -sh "$gf_internal_dir" | awk '{print $1;}')"
        if [ "$gf_internal_dir" != "$gf_work_dir" ]; then
            gf_disk_size+="/$(du -sh "$gf_work_dir" | awk '{print $1;}')"
        fi
        local gf_perl_script="$gf_parse_run_info_script"'
            sub get_date {
                my $date = shift;
                my $seconds = ('$(date +%s)' - $date);
                my $days = int($seconds / 60 / 60 / 24);
                my $hours = int($seconds / 60 / 60);
                my $minutes = int($seconds / 60);
                my $result = "";
                if ($days > 13) {
                    $result = "'${GFH3}'$days'${GFC0}' days ago";
                } elsif ($days > 1) {
                    $result = "'${GFH7}'$days'${GFC0}' days ago";
                } elsif ($hours > 1) {
                    $result = "'${GFC7}'$hours'${GFC0}' hours ago";
                } elsif ($minutes > 1) {
                    $result = "'${GFC7}'$minutes'${GFC0}' minutes ago";
                } else {
                    $result = "'${GFC7}'$seconds'${GFC0}' seconds ago";
                }
                return $result;
            }

            my $result = "";
            my %statuses_index;
            my %statuses;
            if ($#sessions >= 0) {
                foreach my $session (@sessions) {
                    my $status = "";
                    my $user = "";
                    my $host = "";

                    # Status
                    $status = "'${GFH6}'opened'${GFC0}'" if ($sessions{$session}{status} eq "generate");
                    $status = "'${GFH2}'started'${GFC0}'" if ($sessions{$session}{status} eq "started");
                    $status = "finished" if ($sessions{$session}{status} eq "finished");
                    $status = "'${GFH1}'interrupted'${GFC0}'" if ($sessions{$session}{status} eq "interrupted");
                    $status = "'${GFH1}'terminated'${GFC0}'" if ($sessions{$session}{status} eq "terminated");

                    # User name
                    if ("'"$USER"'" eq $sessions{$session}{user}) {
                        $user = "'${GFC7}'".$sessions{$session}{user}."'${GFC0}'";
                    } else {
                        $user = "'${GFH3}'".$sessions{$session}{user}."'${GFC0}'";
                    }

                    # Host name
                    if ("'"$HOSTNAME"'" eq $sessions{$session}{host}) {
                        $host = "'${GFC7}'".$sessions{$session}{host}."'${GFC0}'";
                    } else {
                        $host = "'${GFH3}'".$sessions{$session}{host}."'${GFC0}'";
                    }

                    # Unique fields
                    if (!defined $statuses_index{statuses}{$status}) {
                        $statuses_index{statuses}{$status} = 1;
                        push @{$statuses{statuses}}, $status;
                    }
                    if (!defined $statuses_index{users}{$user}) {
                        $statuses_index{users}{$user} = 1;
                        push @{$statuses{users}}, $user;
                    }
                    if (!defined $statuses_index{hosts}{$host}) {
                        $statuses_index{hosts}{$host} = 1;
                        push @{$statuses{hosts}}, $host;
                    }

                    # Task information
                    my $task_info = "";
                    foreach my $task (@tasks) {
                        if (defined $sessions{$session}{tasks}{$task}) {
                            my $status = $sessions{$session}{tasks}{$task}{status};
                            my $task_result = "    ";
                            $summary{$status}++ if ($tasks{$task}{session} eq $session);
                            $task_result .= "'${GFH6}'$task'${GFC0}' submitted" if ($status eq "submitted");
                            $task_result .= "'${GFH3}'$task'${GFC0}' started" if ($status eq "running");
                            $task_result .= "'${GFH2}'$task'${GFC0}' done" if ($status eq "done");
                            $task_result .= "'${GFH1}'$task'${GFC0}' failed" if ($status eq "failed");
                            $task_result .= "'${GFH1}'$task'${GFC0}' interrupted" if ($status eq "interrupted");
                            $task_result .= "'${GFH1}'$task'${GFC0}' aborted" if ($status eq "aborted");

                            $task_result .= " ".get_date($tasks{$task}{time});
                            $task_result .= " by '${GFH3}'".$tasks{$task}{user}."'${GFC0}'" if ($sessions{$session}{user} ne $tasks{$task}{user});
                            $task_result .= " at '${GFH3}'".$tasks{$task}{host}."'${GFC0}'" if ($sessions{$session}{host} ne $tasks{$task}{host});
                            $task_result =~ s/\e\[\d+m//g if ($tasks{$task}{session} ne $session);
                            $task_result =~ s/\e\[\d+m//g if ($tasks{$task}{session} ne $session);
                            $task_info .= $task_result."\n";
                        }
                    }
                    if ($task_info ne "") {
                        $result .= "\n  '${GFH6}'#$session'${GFC0}' $status";
                        $result .= " ".get_date($sessions{$session}{time}) if ($sessions{$session}{time});
                        $result .= " by $user at $host";
                        $result .= "\n".$task_info;
                    }
                }
                $result .= "\n";
            }

            # Session information
            my $title = "'${GFH7}''"$gf_run_name"''${GFC0}' - '${GFC7}''"$gf_disk_size"''${GFC0}', ";
            my $footer = "";
            if ($#sessions < 0) {
                $title .= "'${GFH1}'no'${GFC0}' sessions";
                $footer .= "  Total '${GFH1}'0'${GFC0}' tasks\n";
            } else {
                if ($#sessions == 0) {
                    $title .= "'${GFC7}'1'${GFC0}' session";
                } else {
                    $title .= "'${GFC7}'".($#sessions+1)."'${GFC0}' sessions";
                }
                $title .= " ".join("/", @{$statuses{statuses}});
                $title .= " ".get_date($session_date) if ($session_date && ($#sessions == 0));
                $title .= " by ".join("/", @{$statuses{users}});
                $title .= " at ".join("/", @{$statuses{hosts}});

                # Task summary
                if ($#tasks == 0) {
                    $footer .= "  Total '${GFH6}'1'${GFC0}' task";
                } elsif ($#tasks > 0) {
                    $footer .= "  Total '${GFH6}'".($#tasks+1)."'${GFC0}' tasks";
                } else {
                    $footer .= "  Total '${GFH1}'0'${GFC0}' tasks";
                }
                $footer .= ", '${GFH6}'".$summary{"submitted"}."'${GFC0}' waiting" if ($summary{"submitted"});
                $footer .= ", '${GFH3}'".$summary{"running"}."'${GFC0}' running" if ($summary{"running"});
                $footer .= ", '${GFH2}'".$summary{"done"}."'${GFC0}' done" if ($summary{"done"});
                $footer .= ", '${GFH1}'".$summary{"failed"}."'${GFC0}' failed" if ($summary{"failed"});
                $footer .= ", '${GFH1}'".$summary{"interrupted"}."'${GFC0}' interrupted" if ($summary{"interrupted"});
                $footer .= ", '${GFH1}'".$summary{"aborted"}."'${GFC0}' aborted" if ($summary{"aborted"});
                $footer .= "\n";
            }

            # Task information sections
            if ("'"$gf_need_summary"'") {
                $result = "$title\n$result$footer";
            } else {
                $result = "$title\n$footer";
            }

            print $result;
        '
        cat "$gf_internal_dir/tasks/run.info" 2> /dev/null | perl -e "$gf_perl_script"
        # gf_debug gf_perl_script
    fi
}

# Prepare working directory
function gf_clean_working_directory {
    local gf_last_runs=
    local GF_FOUND_RUNS=
    local gf_init_run_name=
    local gf_run_name=
    local gf_do_clean=1

    echo -ne "\e]1;C - $GF_SCRIPT_NAME\a\e]2;Cleaning - $GF_SCRIPT_NAME\a"
    gf_set_termination_traps Cleaning "$(basename "$GF_SCRIPT_NAME")" "$GF_SCRIPT_NAME"

    # Make paths absolute
    GF_WORK_DIR="$(gf_full_path "$GF_WORK_DIR")"

    # Check if separate internal directory used
    [[ -n "$GF_INT_DIR" ]] && GF_I_WORK_DIR="$(gf_full_path "$GF_INT_DIR")"
    [[ "$GF_I_WORK_DIR" == "$GF_WORK_DIR" ]] && GF_INT_DIR=
    [[ -z "$GF_INT_DIR" ]] && GF_I_WORK_DIR="$GF_WORK_DIR"

    # Clean while directory exist
    while [ "$gf_do_clean" != "Q" ]; do
        gf_last_runs="$GF_FOUND_RUNS"

        # Check if run directories exist
        GF_FOUND_RUNS=$(ls -1trd "$GF_WORK_DIR/$GF_RUN_NAME"/ "$GF_WORK_DIR/$GF_RUN_NAME."*/ "$GF_I_WORK_DIR/$GF_RUN_NAME"/ "$GF_I_WORK_DIR/$GF_RUN_NAME."*/ 2> /dev/null | sed -e 's|/$||g; s|^.*/||g' | awk '!x[$0]++')

        # Nothing to clean
        if [ -z "$GF_FOUND_RUNS" ]; then
            gf_fatal "No run directories to clean."

        # Show summary
        else

            # Multiple runs
            if [ $(gf_count_words $GF_FOUND_RUNS) -gt 1 ]; then
                if [ "$gf_last_runs" != "$GF_FOUND_RUNS" ]; then
                    for gf_run_name in $GF_FOUND_RUNS; do
                        gf_get_run_summary "$gf_run_name" "$GF_I_WORK_DIR/$gf_run_name" "$GF_WORK_DIR/$gf_run_name"
                        echo
                    done
                fi

                gf_choose -variable gf_run_name -initial "$gf_init_run_name" -variants "$GF_FOUND_RUNS" -message "Please select run directory for details:"
                echo

            # Single match
            else
                gf_run_name=$GF_FOUND_RUNS
            fi

            gf_get_run_summary "$gf_run_name" "$GF_I_WORK_DIR/$gf_run_name" "$GF_WORK_DIR/$gf_run_name" 1
            gf_init_run_name="$gf_run_name"
            echo

            gf_choose -variable gf_do_clean -keys YNQ -message "Do you want to clean ${GFC7}$gf_run_name${GFC0} run directory?
              ${GFH1}[Y]${GFC0} Yes
              ${GFH2}[N]${GFC0} No
              ${GFH4}[Q]${GFC0} Quit
            "

            # Clean directory
            if [ "$gf_do_clean" == "Q" ]; then
                GF_WAIT_KEY=Q
                exit 0

            elif [ "$gf_do_clean" == "Y" ]; then
                local gf_can_clean=1
                local gf_perl_script="$gf_parse_run_info_script"'
                    my @users; my %users;
                    my @hosts; my %hosts;
                    foreach my $session (@sessions) {
                        if (($sessions{$session}{status} eq "started") || ($sessions{$session}{status} eq "generate")) {
                            my $user = $sessions{$session}{user};
                            my $host = $sessions{$session}{host};
                            push @users, $user if (!defined $users{$user}); $users{$user} = 1;
                            push @hosts, $host if (!defined $hosts{$host}); $hosts{$host} = 1;
                            print "gf_pids_to_kill+=\"$sessions{$session}{pid} \"\n";
                        }
                    }
                    foreach my $host (@hosts) {
                        print "gf_incorrect_hosts+=\"$host \"\n" if ($host ne "'$HOSTNAME'");
                    }
                    foreach my $user (@users) {
                        print "gf_incorrect_users+=\"$user \"\n" if ($user ne "'$USER'");
                    }
                '
                local gf_pids_to_kill=
                local gf_incorrect_hosts=
                local gf_incorrect_users=

                # Check run.info for running sessions
                if [ -e "$GF_I_WORK_DIR/$gf_run_name/tasks/run.info" ]; then
                    eval "$(cat "$GF_I_WORK_DIR/$gf_run_name/tasks/run.info" | perl -e "$gf_perl_script")"
                    # gf_debug gf_perl_script
                    gf_debug gf_pids_to_kill gf_incorrect_hosts gf_incorrect_users
                fi

                # Can kill tasks at current host only
                if [ -n "$gf_incorrect_hosts" ]; then
                    local host
                    for host in $gf_incorrect_hosts; do
                        gf_error "Cannot terminate running session at different ${GFH1}$host${GFC0} host."
                    done
                fi

                # Can kill tasks of current user only
                if [ -n "$gf_incorrect_users" ]; then
                    local user
                    for user in $gf_incorrect_users; do
                        gf_error "Cannot terminate running session of different ${GFH1}$user${GFC0} user."
                    done
                fi

                # Cannot clean the session
                if [ -n "$gf_incorrect_hosts$gf_incorrect_users" ]; then
                    gf_can_clean=0
                else

                    # Kill others sessions
                    local gf_pids_to_kill=$(echo $gf_pids_to_kill)
                    if [ -n "$gf_pids_to_kill" ]; then

                        gf_choose -variable gf_do_clean -keys YNQ -message "Do you want to terminate ${GFC7}$gf_run_name${GFC0} sessions?
                          ${GFH1}[Y]${GFC0} Yes
                          ${GFH2}[N]${GFC0} No
                          ${GFH4}[Q]${GFC0} Quit
                        "

                        if [ "$gf_do_clean" == "Q" ]; then
                            exit 0

                        elif [ "$gf_do_clean" == "Y" ]; then
                            echo

                            local gf_kill_pid
                            for gf_kill_pid in $gf_pids_to_kill; do
                                gf_info_message "Killing session ${GFC4}$gf_kill_pid${GFC0} tasks ..."
                            done

                            local gf_counter=0
                            while ps -p $gf_pids_to_kill &> /dev/null; do
                                if [ $gf_counter -eq 40 ]; then
                                    kill -SIGKILL $gf_pids_to_kill &> /dev/null
                                elif [ $gf_counter -eq 20 ]; then
                                    kill -SIGTERM $gf_pids_to_kill &> /dev/null
                                elif [ $gf_counter -eq 0 ]; then
                                    kill -SIGQUIT $gf_pids_to_kill &> /dev/null
                                fi
                                gf_counter=$((gf_counter+1))
                                sleep 0.5
                            done

                            gf_info_message "All sessions ${GFH1}terminated${GFC0}."
                            sleep 0.5
                            echo
                        else
                            gf_can_clean=
                        fi
                    fi
                fi

                # Clean the directory
                if [ "$gf_can_clean" == "1" ]; then
                    rm -Rf "$GF_I_WORK_DIR/$gf_run_name/" && gf_info_message "Directory ${GFC7}$GF_I_WORK_DIR/${GFH7}$gf_run_name${GFC0} deleted."
                    [[ "$GF_I_WORK_DIR" != "$GF_WORK_DIR" ]] && rm -Rf "$GF_WORK_DIR/$gf_run_name/" && gf_info_message "Directory ${GFC7}$GF_WORK_DIR/${GFH7}$gf_run_name${GFC0} deleted."
                    sleep 5

                    # Next run to be cleaned
                    gf_init_run_name="$(echo "$GF_FOUND_RUNS" | grep -A 1 -Fx -- "$gf_run_name" | tail -1 || :)"
                    GF_FOUND_RUNS="$(echo "$GF_FOUND_RUNS" | grep -v -Fx -- "$gf_run_name" || :)"
                else
                    gf_info_message "Directory ${GFC7}$GF_I_WORK_DIR/${GFH7}$gf_run_name${GFC0} not modified."
                fi
            fi
        fi
        echo
    done
}

# Prepare run directory
function gf_prepare_run_directory {
    local gf_directory_created=

    # Make paths absolute
    GF_WORK_DIR="$(gf_full_path "$GF_WORK_DIR")"

    # Check if separate internal directory used
    [[ -n "$GF_INT_DIR" ]] && GF_I_WORK_DIR="$(gf_full_path "$GF_INT_DIR")"
    [[ "$GF_I_WORK_DIR" == "$GF_WORK_DIR" ]] && GF_INT_DIR=

    # Check internal directory
    if [ -n "$GF_INT_DIR" ]; then
        if [ ! -e "$GF_I_WORK_DIR" ]; then
            gf_choose -variable GF_WAIT_KEY -keys CQ -message "Flow internal directory ${GFH7}$GF_I_WORK_DIR${GFC0} does not exist$GF_RAISE_WINDOW
              ${GFH3}[C]${GFC0} Create it
              ${GFH4}[Q]${GFC0} Quit
            "

            if [ "$GF_WAIT_KEY" == "C" ]; then
                GF_WAIT_KEY=
            else
                exit 0
            fi
            mkdir -p "$GF_I_WORK_DIR"
            echo
        fi
        [[ ! -w "$GF_I_WORK_DIR" ]] && gf_fatal "Internal flow directory ${GFH1}$GF_I_WORK_DIR${GFC0} is not writable."

    # Public mode
    else
        GF_I_WORK_DIR="$GF_WORK_DIR"
    fi

    # Check working directory
    if [ ! -e "$GF_WORK_DIR" ]; then
        gf_choose -variable GF_WAIT_KEY -keys CQ -message "Working directory ${GFH7}$GF_WORK_DIR${GFC0} does not exist$GF_RAISE_WINDOW
          ${GFH3}[C]${GFC0} Create it
          ${GFH4}[Q]${GFC0} Quit
        "

        if [ "$GF_WAIT_KEY" == "C" ]; then
            GF_WAIT_KEY=
        else
            exit 0
        fi
        mkdir -p "$GF_WORK_DIR"
        echo
    fi
    [[ ! -w "$GF_WORK_DIR" ]] && gf_fatal "Working directory ${GFH1}$GF_WORK_DIR${GFC0} is not writable."

    # Check if run directories exist
    if [ -n "$GF_RUN_AUTO_INCREMENT" ]; then
        GF_FOUND_RUNS=$(ls -1trd "$GF_WORK_DIR/$GF_RUN_NAME/" "$GF_WORK_DIR/$GF_RUN_NAME."*/ "$GF_I_WORK_DIR/$GF_RUN_NAME/" "$GF_I_WORK_DIR/$GF_RUN_NAME."*/ 2> /dev/null | sed -e 's|/$||; s|^.*/||g' | awk '!x[$0]++')
    else
        GF_FOUND_RUNS=$(ls -1trd "$GF_WORK_DIR/$GF_RUN_NAME/" "$GF_I_WORK_DIR/$GF_RUN_NAME/" 2> /dev/null | sed -e 's|/$||; s|^.*/||g' | awk '!x[$0]++')
    fi
    GF_FOUND_RUNS_COUNT=$(gf_count_words $GF_FOUND_RUNS)

    # Existing directory mode
    if [ $GF_FOUND_RUNS_COUNT -gt 0 ]; then

        # Found run suffix
        GF_FOUND_SUFFIX=
        if [ $GF_FOUND_RUNS_COUNT == 1 ]; then
           GF_FOUND_SUFFIX=${GF_FOUND_RUNS#$GF_RUN_NAME}
        fi

        # Check next directory suffix
        if [ -z "$GF_NEED_CLEAN" -o "$GF_NEED_CLEAN" == "N" ]; then
            GF_NEXT_SUFFIX=".2"
            local gf_run_name gf_suffix
            for gf_run_name in $GF_FOUND_RUNS; do
                gf_suffix=${gf_run_name#$GF_RUN_NAME.}
                [[ $gf_suffix =~ ^[1-9][0-9]*$ ]] && GF_NEXT_SUFFIX=".$((gf_suffix+1))"
            done
        fi

        # Ask if user would like to save previous data
        if [ -z "$GF_NEED_CLEAN" ]; then

            # Message
            if [ $GF_FOUND_RUNS_COUNT -gt 1 ]; then
                local msg="Several run directories ${GFH7}$GF_RUN_NAME*${GFC0} exist"
            else
                if [ -n "$GF_INT_DIR" -a -d "$GF_I_WORK_DIR/$GF_RUN_NAME$GF_FOUND_SUFFIX" ]; then
                    local msg="Internal run directory ${GFH7}$GF_I_WORK_DIR/$GF_RUN_NAME$GF_FOUND_SUFFIX${GFC0} exists"
                else
                    local msg="Run directory ${GFH7}$GF_WORK_DIR/$GF_RUN_NAME$GF_FOUND_SUFFIX${GFC0} exists"
                fi
            fi

            # Ask user
            if [ -n "$GF_RUN_AUTO_INCREMENT" ]; then
                gf_choose -variable GF_NEED_CLEAN -keys NSCRQ -time 300 -default N -message "$msg$GF_RAISE_WINDOW
                  ${GFH2}[N]${GFC0} Create new directory ${GFC7}$GF_RUN_NAME$GF_NEXT_SUFFIX${GFC0} (default after 5 minutes)
                  ${GFH2}[S]${GFC0} Move existing run data into ./${GFC7}saved${GFC0} directory
                  ${GFH3}[C]${GFC0} Continue in existing run directory
                  ${GFH1}[R]${GFC0} Reset and clean run directory
                  ${GFH4}[Q]${GFC0} Quit
                "
            else
                gf_choose -variable GF_NEED_CLEAN -keys SCRQ -time 300 -default C -message "$msg$GF_RAISE_WINDOW
                  ${GFH2}[S]${GFC0} Move existing run data into ./${GFC7}saved${GFC0} directory
                  ${GFH3}[C]${GFC0} Continue in existing run directory
                  ${GFH1}[R]${GFC0} Reset and clean run directory
                  ${GFH4}[Q]${GFC0} Quit
                "
            fi
        fi

        # Select one of multiple runs
        if [ $GF_FOUND_RUNS_COUNT -gt 1 ]; then
            if [ -n "$(echo $GF_NEED_CLEAN | grep '[SCR]')" ]; then
                echo
                gf_choose -variable GF_FOUND_SUFFIX -variants "$GF_FOUND_RUNS" -message "Please select existing directory:"
                GF_FOUND_SUFFIX=${GF_FOUND_SUFFIX#$GF_RUN_NAME}
            fi
        fi

        # Check for suspicious activity
        if [ -n "$(echo $GF_NEED_CLEAN | grep '[SCR]')" ]; then
            if [ -e "$GF_I_WORK_DIR/$GF_RUN_NAME$GF_FOUND_SUFFIX/tasks/run.info" ]; then
                local gf_perl_script="$gf_parse_run_info_script"'
                    my $gf_last_user = "";
                    my $gf_last_date = "";
                    foreach my $session (@sessions) {
                        if ($sessions{$session}{status} eq "finished") {
                            $gf_last_user = $sessions{$session}{user};
                            $gf_last_date = $sessions{$session}{time};
                        }
                    }
                    print "gf_last_user=$gf_last_user\n";
                    if ($gf_last_date =~ /^\d+$/) {
                         my $days = (('$(date +%s)' - $gf_last_date) / 60 / 60 / 24);
                         print "gf_last_date=".int($days)."\n" if ($days > 7);
                    }
                '
                eval "$(cat "$GF_I_WORK_DIR/$GF_RUN_NAME$GF_FOUND_SUFFIX/tasks/run.info" | perl -e "$gf_perl_script")"
                # gf_debug gf_perl_script
                gf_debug gf_last_user gf_last_date

                # Ask if other user worked in the run before
                if [ -n "$gf_last_user" -a "$gf_last_user" != "$USER" ]; then
                    gf_choose -variable GF_WAIT_KEY -keys CQ -message "Run directory ${GFH7}$GF_I_WORK_DIR/$GF_RUN_NAME$GF_FOUND_SUFFIX${GFC0} has been used by user ${GFH7}$gf_last_user${GFC0} before$GF_RAISE_WINDOW
                      ${GFH3}[C]${GFC0} Continue
                      ${GFH4}[Q]${GFC0} Quit
                    "

                    if [ "$GF_WAIT_KEY" == "C" ]; then
                        GF_WAIT_KEY=
                    else
                        exit 0
                    fi
                fi

                # Ask if run has been finished more than 2 weeks ago
                if [ -n "$gf_last_date" ]; then
                    gf_choose -variable GF_WAIT_KEY -keys CQ -message "Run directory ${GFH7}$GF_I_WORK_DIR/$GF_RUN_NAME$GF_FOUND_SUFFIX${GFC0} updated ${GFH7}$gf_last_date${GFC0} days ago$GF_RAISE_WINDOW
                      ${GFH3}[C]${GFC0} Continue
                      ${GFH4}[Q]${GFC0} Quit
                    "

                    if [ "$GF_WAIT_KEY" == "C" ]; then
                        GF_WAIT_KEY=
                    else
                        exit 0
                    fi
                fi
            fi
        fi

        # Kill running tasks if mode requires
        if [ -n "$(echo $GF_NEED_CLEAN | grep '[SR]')" -a -e "$GF_I_WORK_DIR/$GF_RUN_NAME$GF_FOUND_SUFFIX/tasks/run.info" ]; then
            local gf_perl_script="$gf_parse_run_info_script"'
                my @users; my %users;
                my @hosts; my %hosts;
                foreach my $session (@sessions) {
                    if (($sessions{$session}{status} eq "started") || ($sessions{$session}{status} eq "generate")) {
                        my $user = $sessions{$session}{user};
                        my $host = $sessions{$session}{host};
                        push @users, $user if (!defined $users{$user}); $users{$user} = 1;
                        push @hosts, $host if (!defined $hosts{$host}); $hosts{$host} = 1;
                        print "gf_pids_to_kill+=\"$sessions{$session}{pid} \"\n";
                    }
                }
                foreach my $host (@hosts) {
                    print "gf_incorrect_hosts+=\"$host \"\n" if ($host ne "'$HOSTNAME'");
                }
                foreach my $user (@users) {
                    print "gf_incorrect_users+=\"$user \"\n" if ($user ne "'$USER'");
                }
            '
            local gf_pids_to_kill=
            local gf_incorrect_hosts=
            local gf_incorrect_users=

            eval "$(cat "$GF_I_WORK_DIR/$GF_RUN_NAME$GF_FOUND_SUFFIX/tasks/run.info" | perl -e "$gf_perl_script")"
            # gf_debug gf_perl_script
            gf_debug gf_pids_to_kill gf_incorrect_hosts gf_incorrect_users

            # Can kill tasks at current host only
            if [ -n "$gf_incorrect_hosts" ]; then
                local host
                for host in $gf_incorrect_hosts; do
                    gf_error "Cannot terminate running session at different ${GFH1}$host${GFC0} host."
                done
            fi

            # Can kill tasks of current user only
            if [ -n "$gf_incorrect_users" ]; then
                local user
                for user in $gf_incorrect_users; do
                    gf_error "Cannot terminate running session of different ${GFH1}$user${GFC0} user."
                done
            fi

            if [ -n "$gf_incorrect_hosts$gf_incorrect_users" ]; then
                exit 1
            fi

            # Kill others sessions
            local gf_pids_to_kill=$(echo $gf_pids_to_kill)
            if [ -n "$gf_pids_to_kill" ]; then
                local gf_kill_pid
                for gf_kill_pid in $gf_pids_to_kill; do
                    gf_info_message "Killing other session ${GFC4}$gf_kill_pid${GFC0} tasks ..."
                done

                local gf_counter=0
                while ps -p $gf_pids_to_kill &> /dev/null; do
                    if [ $gf_counter -eq 40 ]; then
                        kill -SIGKILL $gf_pids_to_kill &> /dev/null
                    elif [ $gf_counter -eq 20 ]; then
                        kill -SIGTERM $gf_pids_to_kill &> /dev/null
                    elif [ $gf_counter -eq 0 ]; then
                        kill -SIGQUIT $gf_pids_to_kill &> /dev/null
                    fi
                    gf_counter=$((gf_counter+1))
                    sleep 0.5
                done

                gf_info_message "All other sessions ${GFH1}terminated${GFC0}."
                sleep 0.5
            fi
        fi

        # Add index to the directory name
        if [ "$GF_NEED_CLEAN" == "N" ]; then

            # New run name
            GF_RUN_NAME+=$GF_NEXT_SUFFIX

            # Create internal directory
            if [ -n "$GF_INT_DIR" ]; then
                mkdir -p "$GF_I_WORK_DIR/$GF_RUN_NAME"
                gf_info_message "New internal run directory ${GFC7}$GF_I_WORK_DIR/$GF_RUN_NAME${GFC0} ${GFH2}created${GFC0}."
            fi

            # Create run directory
            mkdir -p "$GF_WORK_DIR/$GF_RUN_NAME"
            gf_info_message "New run directory ${GFC7}$GF_WORK_DIR/$GF_RUN_NAME${GFC0} ${GFH2}created${GFC0}.\n"

        # Move existing run data into ./saved directory
        elif [ "$GF_NEED_CLEAN" == "S" ]; then

            # Create internal backup directory
            if [ -n "$GF_INT_DIR" ]; then
                mkdir -p "$GF_I_WORK_DIR/saved"
                [[ ! -w "$GF_I_WORK_DIR/saved" ]] && gf_fatal "Internal backup directory ${GFH1}$GF_I_WORK_DIR/saved${GFC0} is not writable."
            fi

            # Create backup directory
            mkdir -p "$GF_WORK_DIR/saved"
            [[ ! -w "$GF_WORK_DIR/saved" ]] && gf_fatal "Backup directory ${GFH1}$GF_WORK_DIR/saved${GFC0} is not writable."

            # Run index
            gf_counter=1
            gf_save_index=01

            # Increase directory number
            while [ -d "$GF_WORK_DIR/saved/$GF_RUN_NAME.$gf_save_index" -o -d "$GF_I_WORK_DIR/saved/$GF_RUN_NAME.$gf_save_index" ]; do
                local gf_counter=$((gf_counter+1))
                if [ $gf_counter -lt 10 ]; then
                    gf_save_index="0$gf_counter"
                else
                    gf_save_index="$gf_counter"
                fi
            done

            # Move internal directory
            if [ -n "$GF_INT_DIR" ]; then
                if [ -e "$GF_I_WORK_DIR/$GF_RUN_NAME$GF_FOUND_SUFFIX" ]; then
                    mv "$GF_I_WORK_DIR/$GF_RUN_NAME$GF_FOUND_SUFFIX" "$GF_I_WORK_DIR/saved/$GF_RUN_NAME.$gf_save_index"
                    gf_info_message "Internal run ${GFC7}$GF_RUN_NAME$GF_FOUND_SUFFIX${GFC0} directory ${GFH2}moved${GFC0} to ${GFC7}$GF_I_WORK_DIR/saved/$GF_RUN_NAME.$gf_save_index${GFC0}."
                fi
            fi

            # Move directory
            if [ -e "$GF_WORK_DIR/$GF_RUN_NAME$GF_FOUND_SUFFIX" ]; then
                mv "$GF_WORK_DIR/$GF_RUN_NAME$GF_FOUND_SUFFIX" "$GF_WORK_DIR/saved/$GF_RUN_NAME.$gf_save_index"
                gf_info_message "Run ${GFC7}$GF_RUN_NAME$GF_FOUND_SUFFIX${GFC0} directory ${GFH2}moved${GFC0} to ${GFC7}$GF_WORK_DIR/saved/$GF_RUN_NAME.$gf_save_index${GFC0}.\n"
            fi

            # Add run suffix
            GF_RUN_NAME+=$GF_FOUND_SUFFIX

        # Continue in existing directory
        elif [ "$GF_NEED_CLEAN" == "C" ]; then
            GF_RUN_NAME+=$GF_FOUND_SUFFIX

            # Both internal and run directories should exist
            if [ -n "$GF_INT_DIR" ]; then
                [[ ! -e "$GF_WORK_DIR/$GF_RUN_NAME" ]] && gf_fatal "Run directory ${GFH1}$GF_WORK_DIR/$GF_RUN_NAME${GFC0} does not exist."
                [[ ! -e "$GF_I_WORK_DIR/$GF_RUN_NAME" ]] && gf_fatal "Internal run directory ${GFH1}$GF_I_WORK_DIR/$GF_RUN_NAME${GFC0} does not exist."
                [[ ! -w "$GF_I_WORK_DIR/$GF_RUN_NAME" ]] && gf_fatal "Existing internal run directory ${GFH1}$GF_I_WORK_DIR/$GF_RUN_NAME${GFC0} is not writable."
            fi

            # Check working directory
            [[ ! -w "$GF_WORK_DIR/$GF_RUN_NAME" ]] && gf_fatal "Existing run directory ${GFH1}$GF_WORK_DIR/$GF_RUN_NAME${GFC0} is not writable."

            gf_info_message "Run ${GFH3}continued${GFC0} in existing ${GFC7}$GF_WORK_DIR/$GF_RUN_NAME${GFC0} directory.\n"

        # Clean existing directory
        elif [ "$GF_NEED_CLEAN" == "R" ]; then
            GF_RUN_NAME+=$GF_FOUND_SUFFIX

            # Check internal run directory
            if [ -n "$GF_INT_DIR" -a -e "$GF_I_WORK_DIR/$GF_RUN_NAME" -a ! -w "$GF_I_WORK_DIR/$GF_RUN_NAME" ]; then
                gf_fatal "Internal run directory ${GFH1}$GF_I_WORK_DIR/$GF_RUN_NAME${GFC0} is not writable."
            fi

            # Check run directory
            if [ -e "$GF_WORK_DIR/$GF_RUN_NAME" -a ! -w "$GF_WORK_DIR/$GF_RUN_NAME" ]; then
                gf_fatal "Run directory ${GFH1}$GF_WORK_DIR/$GF_RUN_NAME${GFC0} is not writable."
            fi

            # Clean internal run directory
            if [ -n "$GF_INT_DIR" -a -e "$GF_I_WORK_DIR/$GF_RUN_NAME" ]; then
                rm -Rf "$GF_I_WORK_DIR/$GF_RUN_NAME"; if [ $? -ne 0 ]; then exit 1; fi
                gf_info_message "Internal run directory ${GFH1}cleaned${GFC0}."
            fi

            # Clean run directory
            if [ -e "$GF_WORK_DIR/$GF_RUN_NAME" ]; then
                rm -Rf "$GF_WORK_DIR/$GF_RUN_NAME"; if [ $? -ne 0 ]; then exit 1; fi
                local i=0; while [ -e "$GF_WORK_DIR/$GF_RUN_NAME" ]; do
                    i=$((i+1))
                    if [ $i -gt 5 ]; then
                        gf_fatal "Run directory ${GFH1}$GF_WORK_DIR/$GF_RUN_NAME${GFC0} locked."
                    else
                        rm -Rf "$GF_WORK_DIR/$GF_RUN_NAME"
                        sleep 1
                    fi
                done
                gf_info_message "Run directory ${GFH1}cleaned${GFC0}.\n"
            elif [ -n "$GF_INT_DIR" ]; then
                echo
            fi

        # Interrupt
        else
            gf_warning_message "User interrupted.\n"
            GF_WAIT_KEY=Q
            exit 0
        fi
    fi

    # Current run directory
    GF_RUN_DIR="$GF_WORK_DIR/$GF_RUN_NAME"
    GF_I_RUN_DIR="$GF_I_WORK_DIR/$GF_RUN_NAME"
    gf_update_path_replaces

    # Check internal run directory
    if [ -n "$GF_INT_DIR" -a -e "$GF_I_RUN_DIR" -a ! -w "$GF_I_RUN_DIR" ]; then
        gf_fatal "Internal run directory ${GFH1}$GF_I_RUN_DIR${GFC0} is not writable."
    fi

    # Check run directory
    if [ -e "$GF_RUN_DIR" -a ! -w "$GF_RUN_DIR" ]; then
        gf_fatal "Run directory ${GFH1}$GF_RUN_DIR${GFC0} is not writable."
    fi

    # Create internal run directory
    if [ -n "$GF_INT_DIR" -a ! -e "$GF_I_RUN_DIR" ]; then
        mkdir "$GF_I_RUN_DIR"
        # chmod a+rwxs "$GF_I_RUN_DIR"
        gf_info_message "Internal run directory ${GFC2}$GF_I_RUN_DIR${GFC0} created."
    fi

    # Create run directory
    if [ ! -e "$GF_RUN_DIR" ]; then
        mkdir "$GF_RUN_DIR"
        # chmod a+rwxs "$GF_RUN_DIR"
        gf_info_message "Run directory ${GFC2}$GF_RUN_DIR${GFC0} created.\n"
    fi

    # Create directory structure
    local dir
    for dir in scripts tasks in out logs reports; do
        if [ ! -e "$GF_RUN_DIR/$dir" ]; then
            mkdir -p "$GF_RUN_DIR/$dir"
            # chmod a+rwxs "$GF_RUN_DIR/$dir"
        fi
    done
    if [ -n "$GF_INT_DIR" ]; then
        ln -sf "$(gf_full_path "$GF_RUN_DIR")" "$GF_I_RUN_DIR/work"
        for dir in scripts tasks in logs; do
            if [ ! -e "$GF_I_RUN_DIR/$dir" ]; then
                mkdir -p "$GF_I_RUN_DIR/$dir"
                # chmod a+rwxs "$GF_I_RUN_DIR/$dir"
            fi
        done
    fi

    # Create empty internal files
    local gf_file
    for gf_file in tasks/run.info tasks/run.log; do
        if [ ! -e "$GF_I_RUN_DIR/$gf_file" ]; then
            touch "$GF_I_RUN_DIR/$gf_file"
            # chmod a+rw "$GF_I_RUN_DIR/$gf_file"
        fi
    done

    # Test functionality
    touch "$GF_I_RUN_DIR/tasks/run.info" || gf_fatal "Internal file ${GFH1}$GF_I_RUN_DIR/tasks/run.info${GFC0} is not writable."

    # Wait if internal directory locked
    local gf_lock_time=0
    local gf_file_time=
    local gf_need_info=1
    while [ -e "$GF_I_RUN_DIR/tasks/run.lock" -a $gf_lock_time == 0 ]; do
        [[ "$gf_need_info" == 1 ]] && gf_info_message "Run directory locked. Waiting ..."
        if [ "$(gf_is_file_updated "$GF_I_RUN_DIR/tasks/run.lock" gf_file_time)" == 1 ]; then
            gf_lock_time=0
        else
            gf_lock_time=1
        fi
        gf_need_info=0
        sleep 1
    done

    # Temporary lock internal directory
    touch "$GF_I_RUN_DIR/tasks/run.lock"
    # chmod a+rwx "$GF_I_RUN_DIR/tasks/run.lock"

    # Run script and log should be unique
    GF_RUN_INDEX=1
    GF_DONE_INDEXES_REVERSE=
    local gf_perl_script="$gf_parse_run_info_script"'
        print "gf_session=$sessions[$#sessions]\n";
        print "gf_status=$sessions{$sessions[$#sessions]}{status}\n";
    '
    # gf_debug gf_perl_script
    local gf_info_session=
    local gf_stop=
    local gf_file_updated=
    while [ -z "$gf_stop" -a "$(gf_is_file_updated "$GF_I_RUN_DIR/tasks/run.info" gf_file_updated)" == "1" ]; do
        local gf_status=
        local gf_session=
        eval "$(cat "$GF_I_RUN_DIR/tasks/run.info" | perl -e "$gf_perl_script")"
        gf_debug gf_session gf_status
        if [ "$gf_status" == "generate" ]; then
            [[ "$gf_info_session" != "$gf_session" ]] && gf_info_message "Session ${GFC7}$gf_session${GFC0} is in script generation phase. Waiting ..."
            gf_info_session=$gf_session
            sleep 2
        else
            gf_stop=1
            if [ "$gf_status" == "ready" ]; then
                GF_RUN_INDEX=$gf_session
            elif [ "$gf_status" != "" ]; then
                GF_RUN_INDEX=$((gf_session+1))
                sleep 0.5
            fi
        fi
    done

    # Current run variables
    GF_RUN_SCRIPT="$GF_I_RUN_DIR/tasks/run.$GF_RUN_INDEX.sh"
    GF_RUN_LOG="$GF_I_RUN_DIR/logs/run.$GF_RUN_INDEX.log"
    gf_debug GF_RUN_INDEX

    # Take care of interruptions
    echo "session $GF_RUN_INDEX generate $$ $HOSTNAME $USER $(date +%s)" >> "$GF_I_RUN_DIR/tasks/run.info"
    trap "echo 'session $GF_RUN_INDEX interrupted $$ $HOSTNAME $USER '\"\$(date +%s)\" >> '$GF_I_RUN_DIR/tasks/run.info'; gf_do_check_session_log; gf_wait_before_close" EXIT
    gf_set_termination_traps Generation "$(basename "$GF_I_RUN_DIR")" "$GF_I_RUN_DIR"

    # Unlock internal directory
    rm -f "$GF_I_RUN_DIR/tasks/run.lock"

    # Initialize session log
    echo -e 'bash -e `readlink -m "$0/../../tasks/show_log.sh"` "$0"; exit' > "$GF_RUN_LOG"
    chmod a+x "$GF_RUN_LOG"
    chmod a-w "$GF_RUN_LOG"
    chmod u+w "$GF_RUN_LOG"

    echo -n "$(echo -e "$GF_TITLE")"$'\n\n'"$GF_MESSAGES" | sed -e 's/\x1b\][12];.\+\x07//g' >> "$GF_RUN_LOG"
}

# Generate flow scripts
function gf_generate_flow_scripts {

    # Check run directory script
    if [ ! -d "$GF_I_RUN_DIR" ]; then
        gf_error "Run directory ${GFH7}$GF_I_RUN_DIR${GFC0} not exists. Please run ${GFH7}gf_prepare_run_directory${GFC0} first."
        return
    fi

    # Start task creation
    echo -ne "\e]1;G - $GF_RUN_NAME - $GF_WORK_DIR\a\e]2;Generating - $GF_RUN_NAME - $GF_WORK_DIR\a"
    gf_info "Creating run script ${GFC7}$GF_I_RUN_DIR/tasks/$(basename "$GF_RUN_SCRIPT")${GFC0}."

    # Create log browse script
    echo '#!/bin/bash

        echo -ne "\e[22;0t"
        trap '"'"'echo -ne "\e[23;0t"'"'"' EXIT

        # Cat log if no display used
        if [ -z "$DISPLAY" ]; then
            cat "$1" | grep -v -e '"'"'^bash -e '"'"'

        # Open terminal
        elif [ -z "$GF_NO_XTERM" ]; then
            export GF_NO_XTERM=1
            export GF_LOG_FILE="$(readlink -m "$1")"
            script="$(cat "$0")"
            cd /
            xterm '"$GF_XTERM_RES"' -xrm "'"$GF_XTERM_HOTKEYS"'" -geometry '"$GF_XTERM_SIZE"' -T "$PWD/$(basename "$1")" -e bash <(echo "$script") &

        # Show log content
        else
            grep -v -e '"'"'^bash -e '"'"' "$GF_LOG_FILE"
            echo -e "\nAll done in this session. Press '${GFH4}'[Q]'${GFC0}' to finish"
            gf_key=; while [ -z "$(echo $gf_key | grep -e "[qQ]")" ]; do
                read -n 1 -s gf_key
            done
        fi
    ' | sed -e 's/^\s\{4,8\}//' > "$GF_I_RUN_DIR/tasks/show_log.sh"
    # chmod a+rwx "$GF_I_RUN_DIR/tasks/show_log.sh"
    chmod a+x "$GF_I_RUN_DIR/tasks/show_log.sh"

    # Create run script
    gf_create_run_script > "$GF_RUN_SCRIPT"

    # Source task script
    if [ -e "$GF_SCRIPT" -o -n "$GF_SCRIPT_CONTENT" ]; then
        gf_info "Loading flow script ${GFC7}$GF_SCRIPT${GFC0}.\n"

        # Current script
        local gf_script_file="$GF_I_RUN_DIR/scripts/$(basename "$GF_SCRIPT" .gf).$GF_RUN_INDEX.gf"

        # Update current help section
        gf_help_section "User script"

        # Save copy of current script
        echo "$GF_SCRIPT_CONTENT" > "$gf_script_file"
        chmod a+x "$gf_script_file"
        GF_SCRIPT_COPY="./scripts/$(basename "$GF_SCRIPT" .gf).$GF_RUN_INDEX.gf"
        ln -sf "$GF_SCRIPT_COPY" "$GF_I_RUN_DIR/$(basename "$GF_SCRIPT")"
        GF_SCRIPT_COPY="$(gf_full_path_rel "$GF_I_RUN_DIR" "$GF_SCRIPT_COPY")"

        # Reset sources file when exists
        rm -f "$GF_I_RUN_DIR/scripts/$(basename "$GF_SCRIPT" .gf).$GF_RUN_INDEX.sources.gf"
        touch "$GF_I_RUN_DIR/scripts/$(basename "$GF_SCRIPT" .gf).$GF_RUN_INDEX.sources.gf"
        GF_SCRIPT_SOURCES="./scripts/$(basename "$GF_SCRIPT" .gf).$GF_RUN_INDEX.sources.gf"
        ln -sf "$GF_SCRIPT_SOURCES" "$GF_I_RUN_DIR/$(basename "$GF_SCRIPT" .gf).sources.gf"
        GF_SCRIPT_SOURCES="$(gf_full_path_rel "$GF_I_RUN_DIR" "$GF_SCRIPT_SOURCES")"

        GF_SOURCE_FILE="$(gf_full_path "$GF_SCRIPT")"
        GF_LAST_FILE_CONTENT="$GF_SCRIPT_CONTENT"
        eval "local GF_LINENO=$((LINENO-1)); $GF_SCRIPT_CONTENT"
        GF_LAST_FILE=
        GF_SOURCE_FILE=
    fi

    # Last created task name should be run before the next
    if [ -n "$TASK_NAME" ]; then
        gf_fatal "${GFH7}$TASK_NAME${GFC0} has been created but not submitted."
    fi

    # Finalize run script
    gf_done_run_script >> "$GF_RUN_SCRIPT"
    chmod u+x "$GF_RUN_SCRIPT"

    # Error when nothing to run
    if [ $GF_TASK_COUNT -eq 0 ]; then
        gf_fatal "\e]1;X - $GF_RUN_NAME - $GF_WORK_DIR\a\e]2;No tasks to run - $GF_RUN_NAME - $GF_WORK_DIR\aNo tasks to run."
    elif [ $GF_TASK_COUNT -eq 1 ]; then
        gf_info "Total ${GFH6}$GF_TASK_COUNT${GFC0} task to run.\n"
    else
        gf_info "Total ${GFH6}$GF_TASK_COUNT${GFC0} tasks to run.\n"
    fi

    # Link current script
    ln -sf "./tasks/run.$GF_RUN_INDEX.sh" "$GF_I_RUN_DIR/run.sh"
}

# Print previous sessions task statuses
function gf_show_previous_task_statuses {

    # Tasks to show
    local gf_perl_script="$gf_parse_chosen_tasks_script"'
        my %logs; my @logs;
        my %dirs; my @dirs;
        my %runs;
        foreach my $chosen_task (@chosen_tasks) {
            my $task = $$chosen_task{task};
            my $run = $$chosen_task{run};
            my $dir = $run;
            $dir =~ s|/tasks/run.info$||;
            if (!defined $runs{$run}) {
                if (open FILE, $run) {
                    '"$(echo "$gf_parse_run_info_script" | sed -e 's/<STDIN>/<FILE>/')"'
                    foreach my $log_task (@tasks) {
                        if (defined $chosen_tasks{$run}{$log_task}) {
                            my $log = "$dir/logs/run.$tasks{$log_task}{session}.log";
                            push @logs, $log if (!defined $logs{$log});
                            $runs{$run}{$log_task} = $log;
                            $logs{$log}{$log_task} = 1;
                        }
                    }
                    close FILE;
                }
            }
            if (!defined $runs{$run}{$task}) {
                push @dirs, $dir if (!defined $dirs{$dir});
                push @{$dirs{$dir}{index}}, $task if (!defined $dirs{$dir}{tasks}{$task});
                $dirs{$dir}{tasks}{$task} = 1;
                $runs{$run}{$task} = "";
            }
        }
        foreach my $log (@logs) {
            my $short_name = $log;
            $short_name =~ s|^'"$(gf_full_path "$GF_I_RUN_DIR" | sed -e 's/|/\\|/g')"'/|./|;
            $short_name =~ s|^'"$(gf_full_path "$GF_I_WORK_DIR" | sed -e 's/|/\\|/g')"'/|../|;
            print "'${GFM7}' I '${GFC0}' Status of '${GFC7}'$short_name'${GFC0}' tasks\n\n";
            my %found;
            if (open FILE, $log) {
                my $is_results = 1;
                my $is_print = 0;
                my $is_status = 0;
                my $log_task = "";
                while (<FILE>) {
                    if (/^\e\]1;.+\a\e\]2;.+\a/) {
                        if (/2;Running/) {
                            $is_results = 1;
                        } else {
                            $is_results = 0;
                        }
                    }
                    if ($is_results && /^\[\e\[\d+m\d+\e\[\d+m\]\s+\d+-\d+:\d+:\d+\s+\e\[\d+m(\S+)\e\[\d+m/) {
                        $log_task = $1;
                        if (defined $logs{$log}{$log_task}) {
                            $found{$log_task} = 1;
                            $is_print = 1;
                            $is_status = 1 if (/status is\s*$/);
                            print "'$GFM0' '$GFC0' $_";
                            next;
                        } else {
                            $is_print = 0;
                        }
                    }
                    $is_print = 0 if (/^\e\]1;.+\a\e\]2;.+\a/);
                    $is_print = 0 if (/^\[\e\[\d+m\d+\e\[\d+m\]\s+\d+-\d+:\d+:\d+\s+\e\[\d+m/);
                    print "'$GFM0' '$GFC0' $_" if ($is_print);
                    $is_print = 0 if ($is_status && /\e\[0m/);
                }
                close FILE;
            }
            print "\n";
        }
        foreach my $dir (@dirs) {
            my $short_name = "$dir/";
            $short_name =~ s|^'"$(gf_full_path "$GF_I_RUN_DIR" | sed -e 's/|/\\|/g')"'/|./|;
            $short_name =~ s|^'"$(gf_full_path "$GF_I_WORK_DIR" | sed -e 's/|/\\|/g')"'/|../|;
            print "'${GFM3}' W '${GFC0}' Status of '${GFC7}'${short_name}logs/run.*.log'${GFC0}' tasks\n\n";
            foreach my $task (@{$dirs{$dir}{index}}) {
                print "  Task '${GFH1}'$task'${GFC0}' is not defined yet\n";
            }
            print "\n";
        }
    '
    # gf_debug gf_perl_script
    gf_debug GF_CHOSEN_TASKS
    echo "$GF_CHOSEN_TASKS" | perl -e "$gf_perl_script"
}

# Initialize terminal resources
function gf_init_xterm_resources {

    # Terminal resources
    GF_XTERM_RES=

    # Terminal size in symbols
    if [ -n "$GF_HELP_MODE" ]; then
        GF_XTERM_SIZE=180x50
    else
        GF_XTERM_SIZE=120x20
    fi

    # Terminal font
    if [ "$GF_SMOOTH_FONT" == "TERMINUS" ]; then
        GF_XTERM_RES+=" -xrm 'xterm*renderFont:true'"
        GF_XTERM_RES+=" -xrm 'xterm*faceName:Terminus'"
        GF_XTERM_RES+=" -fs '12'"
    elif [ "$GF_SMOOTH_FONT" == "MONOSPACE" ]; then
        GF_XTERM_RES+=" -xrm 'xterm*renderFont:true'"
        GF_XTERM_RES+=" -xrm 'xterm*faceName:Monospace'"
        GF_XTERM_RES+=" -fs '10'"
    else
        # GF_XTERM_RES+=" -xrm 'xterm*font:-misc-fixed-medium-r-normal--13-*-*-*-*-*-iso8859-1'"
        # GF_XTERM_RES+=" -xrm 'xterm*font1:-cronyx-*-*-r-normal-*-2-*-*-*-*-*-*-*'"
        # GF_XTERM_RES+=" -xrm 'xterm*font2:-misc-fixed-medium-r-normal--6-*-*-*-*-*-iso8859-1'"
        # GF_XTERM_RES+=" -xrm 'xterm*font3:-misc-fixed-medium-r-normal--8-*-*-*-*-*-iso8859-1'"
        # GF_XTERM_RES+=" -xrm 'xterm*font4:-misc-fixed-medium-r-normal--13-*-*-*-*-*-iso8859-1'"
        # GF_XTERM_RES+=" -xrm 'xterm*font5:-misc-fixed-medium-r-normal--15-*-*-*-*-*-iso8859-1'"
        # GF_XTERM_RES+=" -xrm 'xterm*font6:-misc-fixed-medium-r-normal--20-*-*-*-*-*-iso8859-1'"

        GF_XTERM_RES+=" -xrm 'xterm*font:-misc-fixed-medium-r-normal--13-120-*-*-*-70-iso8859-1'"
        GF_XTERM_RES+=" -xrm 'xterm*font1:-cronyx-*-*-r-normal-*-2-*-*-*-*-*-*-*'"
        GF_XTERM_RES+=" -xrm 'xterm*font2:-misc-fixed-medium-r-normal--6-60-*-*-*-*-iso8859-1'"
        GF_XTERM_RES+=" -xrm 'xterm*font3:-misc-fixed-medium-r-normal--8-80-*-*-*-*-iso8859-1'"
        GF_XTERM_RES+=" -xrm 'xterm*font4:-misc-fixed-medium-r-normal--13-120-*-*-*-70-iso8859-1'"
        GF_XTERM_RES+=" -xrm 'xterm*font5:-misc-fixed-medium-r-normal--15-140-*-*-*-*-iso8859-1'"
        GF_XTERM_RES+=" -xrm 'xterm*font6:-misc-fixed-medium-r-normal--20-140-*-*-*-*-iso8859-1'"
    fi

    # Terminal colors for white background
    if [ "$GF_BACKGROUND" == "WHITE" ]; then
        GF_XTERM_RES+=" -fg '#444444'"
        GF_XTERM_RES+=" -bg '#FFFFFF'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.foreground:#444444'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.background:#FFFFFF'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.cursorColor:#444444'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color0:#AAAAAA'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color8:#888888'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color1:#AA0000'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color9:#FF0000'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color2:#008800'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color10:#00CC00'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color3:#777700'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color11:#999900'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color4:#005588'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color12:#0088AA'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color5:#885588'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color13:#AA88AA'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color6:#008888'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color14:#00AAAA'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color7:#222222'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color15:#000000'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.colorBD:#000000'"
    # Terminal colors for black background
    else
        GF_XTERM_RES+=" -fg '#AAAAAA'"
        GF_XTERM_RES+=" -bg '#000000'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.foreground:#AAAAAA'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.background:#000000'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.cursorColor:#AAAAAA'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color0:#555555'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color8:#888888'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color1:#BB3333'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color9:#FF4040'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color2:#33AA33'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color10:#66FF66'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color3:#CCCC33'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color11:#FFFF33'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color4:#0066CC'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color12:#3399FF'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color5:#AA66AA'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color13:#FF88FF'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color6:#00CCCC'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color14:#00FFFF'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color7:#D5D5D5'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.color15:#FFFFFF'"
        GF_XTERM_RES+=" -xrm 'xterm.vt100.colorBD:#FFFFFF'"
    fi

    # Terminal environment
    GF_XTERM_RES+=" -xrm 'xterm.vt100.allowBoldFonts:false'"
    GF_XTERM_RES+=" -xrm 'xterm.vt100.scrollBar:true'"
    GF_XTERM_RES+=" -xrm 'xterm.vt100.saveLines:10000'"
    GF_XTERM_RES+=" -xrm 'xterm.vt100.reverseWrap:true'"
    GF_XTERM_RES+=" -xrm 'xterm.vt100.boldMode:true'"
    GF_XTERM_RES+=" -xrm 'xterm.vt100.jumpScroll:true'"
    GF_XTERM_RES+=" -xrm 'xterm.vt100.fastScroll:true'"
    GF_XTERM_RES+=" -xrm 'xterm.vt100.scrollKey:true'"
    GF_XTERM_RES+=" -xrm 'xterm.vt100.utf8title:true'"
    GF_XTERM_RES+=" -xrm 'xterm.vt100.eightBitInput:false'"
    GF_XTERM_RES+=" -xrm 'xterm.vt100.eightBitOutput:true'"
    GF_XTERM_RES+=" -xrm 'xterm.vt100.popOnBell:true'"
    GF_XTERM_RES+=" -xrm 'xterm.vt100.pointerShape:xterm'"
    GF_XTERM_RES+=" -xrm 'xterm.vt100.charClass:42:48,45-47:48,91:48,93:48,126:48'"

    # Hotkeys
    GF_XTERM_HOTKEYS='xterm.vt100.translations: #override\n'

    GF_XTERM_HOTKEYS+='None <Key> BackSpace: string(0x08)\n'
    GF_XTERM_HOTKEYS+='None <Key> Delete: string("\033[3~")\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> BackSpace: string("\033\010")\n'
    GF_XTERM_HOTKEYS+='~Ctrl Shift <Key> BackSpace: string(0x17)\n'
    GF_XTERM_HOTKEYS+='~Ctrl Shift <Key> Delete: string(0x0B)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> Delete: string("\033d")\n'
    # GF_XTERM_HOTKEYS+='None <Key> Home: string(0x01)\n'
    # GF_XTERM_HOTKEYS+='None <Key> End: string(0x05)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> Left: string(0x1b) string(0x62)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> Right: string(0x1b) string(0x66)\n'
    # GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> Home: scroll-back(1000,page)\n'
    # GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> End: scroll-forw(1000,page)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> Prior: scroll-back(1,halfpage)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> Next: scroll-forw(1,halfpage)\n'
    GF_XTERM_HOTKEYS+='~Ctrl Shift <Key> Prior: scroll-back(10,page)\n'
    GF_XTERM_HOTKEYS+='~Ctrl Shift <Key> Next: scroll-forw(10,page)\n'
    GF_XTERM_HOTKEYS+='~Ctrl Shift <Btn4Down>: scroll-back(5,page)\n'
    GF_XTERM_HOTKEYS+='~Ctrl Shift <Btn5Down>: scroll-forw(5,page)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> 0: set-vt-font(d)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> 1: set-vt-font(1)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> 2: set-vt-font(2)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> 3: set-vt-font(3)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> 4: set-vt-font(4)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> 5: set-vt-font(5)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> 6: set-vt-font(6)\n'
    # GF_XTERM_HOTKEYS+='~Ctrl Shift <Btn1Down>: set-vt-font(1)\n'
    # GF_XTERM_HOTKEYS+='~Ctrl Shift <Btn3Down>: set-vt-font(d)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Btn4Down>: larger-vt-font()\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Btn5Down>: smaller-vt-font()\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Btn1Down>: popup-menu(mainMenu)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Btn2Down>: popup-menu(fontMenu)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Btn3Down>: popup-menu(vtMenu)\n'
    GF_XTERM_HOTKEYS+='~Ctrl Shift <Key> Insert: insert-selection(PRIMARY)\n'
    GF_XTERM_HOTKEYS+='Ctrl Shift <Key> V: insert-selection(PRIMARY)\n'
    GF_XTERM_HOTKEYS+='Ctrl ~Shift <Key> Down: iconify()\n'
    GF_XTERM_HOTKEYS+='Meta ~Shift <Key> Down: iconify()\n'

    if [ -n "$GF_MIN_WITHOUT_FOCUS" ]; then
        GF_XTERM_HOTKEYS+='<FocusIn>: set-vt-font(d)\n'
        GF_XTERM_HOTKEYS+='<FocusOut>: set-vt-font(1)\n'
    fi
}

##################################################
# Initialize environment
##################################################

# Full path to binary
GF_BIN="$(gf_full_path "$GF_BIN_FILE")"

# Generic flow root directory
GF_ROOT="$(gf_full_path "$GF_BIN/../..")"

# Current running script name
GF_SCRIPT_NAME=$(basename "$GF_BIN_FILE")

# Start directory
GF_WORK_DIR="$PWD"
GF_INT_DIR=""

# Raise window when done
GF_RAISE_WINDOW=

# Reset grep options
export GREP_OPTIONS=
# stty erase ^? intr ^C
stty intr ^C

# List of used options
GF_USED_OPTIONS=

# Parse graphic command line arguments
for gf_arg in "$@"; do
    case "$gf_arg" in
        "-fatal_exit" )
            export GF_FATAL_EXIT=1
        ;;
        "-no_win" )
            export GF_NO_WIN=1
        ;;
        "-sync" )
            export GF_SYNC=1
        ;;
        "-raise" )
            GF_RAISE_WINDOW="\e[1t\e[5t"
        ;;
        "-smooth" )
            GF_SMOOTH_FONT=MONOSPACE
        ;;
        "-white" )
            GF_BACKGROUND=WHITE
        ;;
        "-focus" )
            GF_MIN_WITHOUT_FOCUS=1
        ;;
        "-clean" )
            GF_CLEAN_MODE=1
            GF_USED_OPTIONS+="C $gf_arg"$'\n'
        ;;
        "-utils"|"-tools" )
            GF_INTERACTIVE_MODE=1
        ;;
        "-h"|"-help" )
            [[ -z "$GF_HELP_MODE" ]] && GF_HELP_MODE=HELP
        ;;
        "-info" )
            [[ -z "$GF_HELP_MODE" ]] && GF_HELP_MODE=INFO
        ;;
    esac
done

# Window modes
GF_BACKGROUND_MODE=
GF_SILENT=

# Check if xterm binary is correct
if ! which xterm &> /dev/null; then
    echo -e "\e[33;43m \e[0m xterm binary not found. Silent mode used"
    GF_SILENT=1
    export GF_NO_XTERM=1
fi

# Open tool in new xterm window if not opened
gf_init_xterm_resources
if [ -z "$GF_NO_XTERM" ]; then
    export GF_NO_XTERM=1

    # Run in new window
    if [ -n "$DISPLAY" -a "$GF_NO_WIN" != "1" ]; then
        if [ -z "$GF_SYNC" ]; then
            xterm $(echo $GF_XTERM_RES | sed -e "s/'//g") -xrm "$GF_XTERM_HOTKEYS" -geometry $GF_XTERM_SIZE -e bash "$GF_BIN" "$@" &> /dev/null & disown
        else
            xterm $(echo $GF_XTERM_RES | sed -e "s/'//g") -xrm "$GF_XTERM_HOTKEYS" -geometry $GF_XTERM_SIZE -e bash "$GF_BIN" "$@"
        fi
        exit 0
    fi
fi

# Print title when xterm window opened
GF_TITLE="${GFH4}\e]0;$GF_TITLE\a
###$(echo "$GF_TITLE" | sed -e 's/./#/g')###
#  $GF_TITLE  #
###$(echo "$GF_TITLE" | sed -e 's/./#/g')###${GFC0}
"

# Set command line prompt
# export PS1="\[${GFM4}\] \[\e[0;94m\] Generic Flow\[${GFC0}\] ./\W$ "
export PS1="\[\n${GFM4}\] \[\e[0;94m\] Generic Flow\[${GFC0}\] \$(echo \"\$PWD\" | sed -e \"s|^.\+/\([^/]\+/[^/]\+\)\$|./\\1|;s|/\([^/]\+\)\$|/\[\e[1m\]\\1\[\e[0m\]|;\")\\\$ "

# Update path environment
export PATH="$(dirname "$GF_BIN"):$PATH"

# Save and replace title
gf_save_title; trap 'gf_restore_title' EXIT
echo -e "$GF_TITLE"

# Tasks script
GF_SCRIPT=
GF_SCRIPT_CONTENT=
GF_SCRIPT_COPY=
GF_SCRIPT_SOURCES=

# Flow reference scripts
GF_REF_FILE=
GF_REF_CONTENT=
GF_REF_CHOICE=
GF_REF_CHOICES=
GF_REF_SAVED=

# Last loaded file
GF_LAST_FILE_STATUS=
GF_LAST_FILE_CONTENT=

# Run name and suffix
GF_RUN_NAME=
GF_RUN_SUFFIX=
GF_RUN_SUFFIX_RESUME=0
GF_RUN_AUTO_INCREMENT=1

# Task options
GF_TASK_OPTIONS=
# GF_CONTROL_TASKS=
# GF_CONTROL_TASKS_CMD_LINE=

# Log messages
GF_MESSAGES=

# Pressed key when waited for close
GF_WAIT_KEY=

# Task count in current session
GF_TASK_COUNT=0

# Parent function name
GF_FUNC_NAME="gflow"

# Internal flow variables
TASK_NAME=
GF_TASK_BASE=
MOTHER_TASK_NAME=
PREV_TASK_NAME=
GF_I_WORK_DIR=
GF_I_RUN_DIR=
GF_RUN_DIR=
GF_RUN_INDEX=
GF_TAG=

# Grid variable
GF_TASK_OPTIONS+="gf_set_task_option>9>*>-sge_options"$'\n''-pe servers ${GF_TASK_CPU} -l mem=${GF_TASK_MEM}G'$'\n'
GF_TASK_OPTIONS+="gf_set_task_option>9>*>-lsf_options"$'\n''-n ${GF_TASK_CPU} -R rusage[mem=${GF_TASK_MEM}000]'$'\n'
# GF_SGE_OPTIONS='-pe servers ${GF_TASK_CPU} -l mem=${GF_TASK_MEM}G'
# GF_LSF_OPTIONS='-n ${GF_TASK_CPU} -R rusage[mem=${GF_TASK_MEM}000]'

##################################################
# Initial checks and status
##################################################

# Exit if already in the Generic Flow session
if [ -n "$GF_INTEGRATED_RUN" ]; then
    gf_fatal "Generic Flow already started here."
fi

# Current run information
gf_info_message "Current host is ${GFH7}$HOSTNAME${GFC0}."
gf_info_message "Current user is ${GFH7}$USER${GFC0}."

##################################################
# Main script
##################################################

# Take care of interruptions
trap 'gf_do_check_session_log; gf_wait_before_close' EXIT
gf_set_termination_traps Loading "$(basename "$GF_BIN")" "$GF_BIN"
gf_hide_cursor

# Process options
if [ -z "$GF_INTERACTIVE_MODE" ]; then
    gf_load_options "$@"
    gf_update_path_replaces
fi
gf_add_message $'\n'

# Show help and filtered info in help mode and exit
if [ -n "$GF_HELP_MODE" ]; then
    # Basic help pages
    if [ -e "$GF_SCRIPT" ]; then
        gf_preload_script "$GF_SCRIPT"
        gf_update_path_replaces
    fi
    if [ -n "$GF_HELP_FILTERS" -o "$GF_HELP_MODE" == "HELP" -a -z "$GF_INTERACTIVE_MODE" ]; then
        [[ "$GF_HELP_MODE" == "INFO" ]] && echo
        gf_show_help "$GF_HELP_FILTERS"
        [[ -n "$GF_INTERACTIVE_MODE" ]] && exit 0
    fi

    # Script pages
    if [ "$GF_HELP_MODE" == "INFO" ]; then
        if [ -e "$GF_SCRIPT" ]; then
            if [ -n "$GF_HELP_FILTERS" ]; then
                gf_show_script_info "$GF_SCRIPT" "$GF_HELP_FILTERS"
            fi
        else
            GF_HELP_MODE=HELP
            gf_error "Option ${GFH7}-info${GFC0} can be used with GF script only."
        fi
    fi

    # Error if content is empty
    if [ -n "$GF_HELP_FILTERS" -a -z "$GF_HELP_FOUND" ]; then
        gf_error "$(perl -e '
            my @filters;
            '"$GF_FILTER_EXPRESSIONS"'
            print "No help pages or script content matching regexp '${GFH7}'".join("'${GFC0}', '${GFH7}'", @filters)."'${GFC0}' found.";
        ')"
    fi

    # Interactive help mode
    if [ -e "$GF_SCRIPT" ]; then
        gf_set_window_title "Interactive help ($GF_SCRIPT_NAME) - Generic Flow v5.1 (May 2023)" "GF help ($GF_SCRIPT_NAME)"
    else
        gf_set_window_title "Interactive help - Generic Flow v5.1 (May 2023)" "GF help"
    fi
    gf_show_cursor
    echo

    # Show interactive help
    trap 'gf_restore_title; trap -- SIGINT; trap -- SIGQUIT; trap -- SIGTERM; trap -- SIGHUP' EXIT
    trap 'echo -e "'${GFC0}'"; exit 0' SIGINT SIGQUIT SIGTERM SIGHUP
    while true; do
        gf_show_interactive_help "$GF_SCRIPT"
    done

# Interactive mode
elif [ -n "$GF_INTERACTIVE_MODE" -o -z "$GF_SCRIPT" ]; then
    trap -- SIGINT
    trap -- SIGQUIT
    trap -- SIGTERM
    trap -- SIGHUP
    trap 'gf_restore_title' EXIT
    gf_show_cursor
    gf_set_window_title "Generic Flow Utilities v5.1 (May 2023)" "GF utilities"

    # Environment initialization
    export PATH="$GF_UTILS:$(gf_full_path "$GF_BIN/.."):${PATH}"
    export GF_BIN
    export GF_ROOT
    export GF_NO_WIN=1
    export GF_NO_XTERM=1
    export GF_INTEGRATED_RUN=
    export HISTFILE=~/.gflow_history

    # Bash resources
    resources="[[ -f ~/.bashrc ]] && source ~/.bashrc &> /dev/null"$'\n'
    resources+="[[ -f '$(gf_full_path "$GF_BIN/../../integration")/bashrc' ]] && source '$(gf_full_path "$GF_BIN/../../integration")/bashrc' 2> /dev/null"$'\n'
    resources+="export PS1='$PS1'"$'\n'
    resources+="alias nedit=\"nedit -import \\\"$(gf_full_path "$GF_BIN/../../integration")/nedit.rc\\\"\""$'\n'
    resources+="source \"$GF_BIN\" &> /dev/null"$'\n'

    # Integrated shell
    bash --init-file <(echo "$resources") -i
    exit 0

# Directory clean mode
elif [ -n "$GF_CLEAN_MODE" ]; then

    # Preload script settings
    if [ -z "$GF_SCRIPT" ]; then
        gf_fatal "Tasks script is empty. Use ${GFH7}-script${GFC0} option."
    elif [ ! -e "$GF_SCRIPT" ]; then
        gf_fatal "Task script ${GFH7}$GF_SCRIPT${GFC0} not found."
    else
        gf_preload_script "$GF_SCRIPT"
    fi

    # Clean working directory
    echo
    gf_info "Interactive ${GFH3}clean${GFC0} mode activated.\n"
    gf_clean_working_directory

# Generate and run scripts
else

    # Check if tasks script exists
    if [ ! -e "$GF_SCRIPT" ]; then
        gf_fatal "Task script ${GFH7}$GF_SCRIPT${GFC0} not found."
    else
        gf_set_termination_traps Generation "$(basename "$GF_SCRIPT")" "$GF_SCRIPT"
        GF_SCRIPT_CONTENT="$(cat "$GF_SCRIPT")"
    fi

    # Function name is current script
    GF_FUNC_NAME=$(basename "$GF_SCRIPT")

    # Task identifiers
    GF_CHOSEN_TASKS=
    GF_TASK_STATUSES=
    GF_TASK_GROUPS=

    # Trap errors during generation
    function error_func {
        GF_ERRORS_OCCURED=1
        if [ -z "$4" ]; then
            echo -ne "${GFM1} E ${GFC0} Incorrect command in line ${GFH7}$3${GFC0} of ${GFC7}$(echo "$5" | sed -e "s|^$PWD/|./|")${GFC0}.\n${GFH5}"
            head -$3 "$5" | tail -1
        else
            echo -ne "${GFM1} E ${GFC0} Incorrect command in line ${GFH7}$2${GFC0} of ${GFC7}$(echo "$4" | sed -e "s|^$PWD/|./|")${GFC0}.\n${GFH5}"
            echo "$GF_LAST_FILE_CONTENT" | head -$2 | tail -1
        fi
        echo -e "${GFC0}"
    }

    # Enable error trap
    set -E
    trap 'GF_LINENO_CURRENT=$((LINENO-GF_LINENO)); if [[ $GF_LINENO_CURRENT -lt 1 ]]; then echo -e "'${GFM1}' E '${GFC0}' Internal error '${GFH7}'$LINENO'${GFC0}'. Please contact the developer."; else error_func $? $GF_LINENO_CURRENT $LINENO "$GF_SOURCE_FILE" "$BASH_SOURCE"; GF_LINENO=$((LINENO-GF_LINENO_CURRENT)); fi' ERR

    # Prepare run directory
    gf_prepare_run_directory

    # Exit on directory creation errors
    [[ -n "$GF_ERRORS_OCCURED" ]] && gf_fatal "Stopped because of run directory preparation errors."

    # Redirect log
    gf_enable_logging "$GF_RUN_LOG"
    trap "echo 'session $GF_RUN_INDEX interrupted $$ $HOSTNAME $USER '\"\$(date +%s)\" >> '$GF_I_RUN_DIR/tasks/run.info'; gf_do_check_session_log; gf_wait_before_close" EXIT

    # Generate flow scripts
    gf_generate_flow_scripts

    # Disable error trap
    set +E
    trap -- ERR

    # Exit on flow script generation errors
    if [ -n "$GF_ERRORS_OCCURED" ]; then
        if [ -n "$GF_SKIP_ERRORS_MODE" ]; then
            gf_error "Continued, but script generation errors found."
        else
            gf_fatal "Stopped because of script generation errors."
        fi
    fi

    # Print previous sessions task statuses
    gf_show_previous_task_statuses

    # Print command to run
    if [ "$GF_GEN_ONLY" == 1 ]; then
        gf_disable_logging

        echo -ne "\e]1;I - $GF_RUN_NAME - $GF_WORK_DIR\a\e]2;Generated - $GF_RUN_NAME - $GF_WORK_DIR\a"
        gf_info "Script generation completed. Command to execute tasks:"
        if [ -n "$(echo "$GF_RUN_SCRIPT" | grep -e ' ')" ]; then
            echo -e "${GFH4}\"$GF_RUN_SCRIPT\"${GFC0}"
        else
            echo -e "${GFH4}$GF_RUN_SCRIPT${GFC0}"
        fi

        # Generation completed
        echo "session $GF_RUN_INDEX ready $$ $HOSTNAME $USER $(date +%s)" >> "$GF_I_RUN_DIR/tasks/run.info"

        # Interactive shell if started in separate window
        gf_show_cursor
        trap -- SIGINT
        trap -- SIGQUIT
        trap -- SIGTERM
        trap -- SIGHUP
        trap "echo 'session $GF_RUN_INDEX finished $$ $HOSTNAME $USER '\"\$(date +%s)\" >> '$GF_I_RUN_DIR/tasks/run.info'; gf_do_check_session_log; gf_wait_before_close" EXIT

        # Open interactive shell
        if [ -z "$GF_NO_WIN" -a -n "$DISPLAY" ]; then
            echo -ne "\e]1;I - $GF_RUN_NAME - $GF_WORK_DIR\a\e]2;Interactive - $GF_RUN_NAME - $GF_WORK_DIR\a"
            cd "$GF_I_RUN_DIR"
            echo
            set +m
            export GF_INTEGRATED_RUN=
            export GF_NO_WIN=1
            bash -i
        fi

    # Skip interrupt and run task script
    else
        gf_disable_logging

        # Restore window title and cursor visibility
        trap 'gf_restore_title; trap -- SIGINT; trap -- SIGQUIT; trap -- SIGTERM; trap -- SIGHUP; gf_show_cursor' EXIT

        # Run flow in background
        if [ -n "$GF_BACKGROUND_MODE" ]; then
            trap -- SIGINT
            trap -- SIGTERM
            set -m; nohup bash <(echo "
                export GF_BACKGROUND_MODE=1
                export GF_INTEGRATED_RUN=1
                export GF_NO_TITLE=1
                export GF_NO_WIN=1
                export GF_NO_LOG=1
                source '$GF_RUN_SCRIPT'
                if [ -z \"$GF_NO_WIN\$GF_NO_WAIT_KEY\" ]; then
                    export GF_NO_XTERM=
                    '$GF_I_RUN_DIR/tasks/show_log.sh' '$GF_RUN_LOG'
                fi
            ") > /dev/null < /dev/null 2>&1 &
            echo -e "${GFM2} I ${GFC0} Flow started in background"
            if [ -n "$DISPLAY" -a -z "$GF_NO_WIN" ]; then sleep 2; fi

        # Run flow in foreground
        else
            gf_restore_title
            trap -- SIGINT
            trap '' SIGHUP

            export GF_NO_LOG=1
            export GF_INTEGRATED_RUN=1
            export GF_NO_TITLE=1

            # Run and check the flow
            source "$GF_RUN_SCRIPT"
            gf_do_check_session_log
        fi
    fi
fi
