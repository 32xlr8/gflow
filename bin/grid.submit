#!/bin/bash

################################################################################
# Generic Flow v5.5.1 (February 2025)
################################################################################
#
# Copyright 2011-2025 Gennady Kirpichev (https://github.com/32xlr8/gflow.git)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
################################################################################
# Filename: bin/grid.submit
# Purpose:  Generic Flow grid distribution tool
################################################################################

# Usage: $0 <CPU> <RAM> <remote command to run> </path/to/config.grid> </path/to/queue.grid>

# File config.grid should contain information about available resources
# It should contain at least one line with following syntax, 
# definind available CPU and RAM resurces to use on HOSTNAME:
#    * HOST HOSTNAME CPU RAM LOAD
#    * 01 ssh-host01 32 512 +0.000

# File queue.grid used to store information on running tasks

# Number of CPUs and required amount of RAM for new task
CPU="$1"; shift
RAM="$1"; shift

# Command to run in queue
COMMAND="$1"; shift

LOGS="$@"
while [ "$1" != "" ]; do LOG="$1"; shift; done

# Check command line options
if [ -z "$LOG" -o -z "$CPU" -o -z "$RAM" -o -z "$COMMAND" ]; then
    >&2 echo "Usage: $0 <CPU> <RAM> <remote command to run> </path/to/config.grid> </path/to/queue.grid>"
    exit 1
fi

# Lock log file
touch "$LOG"
STAT="$(stat -c %y "$LOG")"
sleep 0.${RANDOM:0:1}

# Get the host with minimal load score
while [ "$STAT2" != "$STAT" ]; do

    # Parse log file
    RESULT=$(cat $LOGS | perl -e '

        # Analyze log file
        my %hosts; my %hostnames; my %tasks;
        while (<STDIN>) {
            next if (/^\s*$/);
            next if (/^\s*\#/);

            # Host resources definition
            if (/^\s*\*\s+(\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+([\+\-]?\d+\.?\d*)\s*$/) {
                my $host = $1;
                my $hostname = $2;
                my $cpu = $3;
                my $ram = $4;
                my $load = $5;
                $hosts{$hostname}{host} = $host;
                $hosts{$hostname}{cpu_total} = $cpu;
                $hosts{$hostname}{ram_total} = $ram;
                $hosts{$hostname}{load} = $load;
                $hostnames{$hostname} = $hostname;
                $hostnames{$host} = $hostname;

            # Running or done task    
            } elsif (/^\s*([\+\-])\s+(\d\d\.\d\d\.\d\d)\s+(\d\d\:\d\d\:\d\d)\s+(\S+)\@(\S+)\s+(\d+)\s+(\d+)\s+(\S+)\:(\d+)/) {
                my $operation = $1;
                my $date = $2;
                my $time = $3;
                my $user = $4;
                my $host = $5;
                my $cpu = $6;
                my $ram = $7;
                my $owner_host = $8;
                my $owner_pid = $9;

                my $hostname = $hostnames{$host};
                my $id = "$owner_host $owner_pid";

                $tasks{$hostname}{$id}{date} = $date;
                $tasks{$hostname}{$id}{time} = $time;
                $tasks{$hostname}{$id}{user} = $user;
                $tasks{$hostname}{$id}{host} = $host;
                $tasks{$hostname}{$id}{cpu} += "$operation$cpu";
                $tasks{$hostname}{$id}{ram} += "$operation$ram";
                $tasks{$hostname}{$id}{owner_host} = $owner_host;
                $tasks{$hostname}{$id}{owner_pid} = $owner_pid;

            # Unknown syntax
            } else {
                print STDERR "\e[31;41m \e[0m $_";
            }
        }

        # Calculate host availability
        my %scores;
        foreach my $hostname (keys %hosts) {
            my $cpu = 0.0 + '"$CPU"';
            my $ram = 0.0 + '"$RAM"';
            
            # Check tasks
            foreach my $id (keys %{$tasks{$hostname}}) {
                next if ($tasks{$hostname}{$id}{cpu} < 1);
            
                # CPU usage
                $cpu += $tasks{$hostname}{$id}{cpu} if ($tasks{$hostname}{$id}{cpu} > 0);
                print STDERR "\e[31;41m \e[0m CPU usage is ".$tasks{$hostname}{$id}{cpu}." for $id\n" if ($tasks{$hostname}{$id}{cpu} < 0);
                print STDERR "\e[33;43m \e[0m CPU usage is ".$tasks{$hostname}{$id}{cpu}." for $id\n" if  ($tasks{$hostname}{$id}{cpu} > 0.40 * $hosts{$hostname}{cpu_total});

                # RAM usage
                $ram += $tasks{$hostname}{$id}{ram} if ($tasks{$hostname}{$id}{ram} > 0);
                print STDERR "\e[31;41m \e[0m RAM usage is ".$tasks{$hostname}{$id}{ram}." for $id\n" if ($tasks{$hostname}{$id}{ram} < 0);
                print STDERR "\e[33;43m \e[0m RAM usage is ".$tasks{$hostname}{$id}{ram}." for $id\n" if  ($tasks{$hostname}{$id}{ram} > 0.25 * $hosts{$hostname}{ram_total});
            }
            
            # Usage score
            $scores{$hostname} = $hosts{$hostname}{load};
            $scores{$hostname} += 0.50 * $cpu / $hosts{$hostname}{cpu_total} if ($hosts{$hostname}{cpu_total});
            $scores{$hostname} += 0.50 * $ram / $hosts{$hostname}{ram_total} if ($hosts{$hostname}{ram_total});
        }

        # Sort host by available score
        foreach my $hostname (sort {$scores{$b} <=> $scores{$a}} keys %scores) {
            print STDERR "\e[32;42m \e[0m Host ".$hosts{$hostname}{host}." (".$hosts{$hostname}{cpu_total}." CPU, ".$hosts{$hostname}{ram_total}."G RAM) usage score is ".sprintf("%0.3f", $scores{$hostname})."\n";
            print $hosts{$hostname}{host}." ".sprintf("%0.3f", $scores{$hostname})."\n";
        }
    ' | tail -1)

    # Wait on changes
    STAT2="$STAT"
    STAT="$(stat -c %y "$LOG")"
    if [ "$STAT" == "$STAT2" ]; then
        touch "$LOG"
    else
        >&2 echo $'\e[33;43m \e[0m '"Grid $LOG is busy"$'\n'
        sleep 1.${RANDOM:0:1}
        STAT2="$STAT"
        STAT="$(stat -c %y "$LOG")"
    fi
done

# Check host candidate
if [ -z "$RESULT" ]; then
    >&2 echo "No hosts detected to submit task to"
    exit 2
else
    RESULT_HOST=$(echo $RESULT | cut -d' ' -f1)
    RESULT_SCORE=$(echo $RESULT | cut -d' ' -f2)
    >&2 echo $'\n\e[32;42m \e[0m '"Host $RESULT_HOST chosen for $LOG queue"
fi
    
# Release resources when task completed
trap "echo \"- \$(date '+%d.%m.%y %H:%M:%S') $USER@$RESULT_HOST $CPU $RAM $HOSTNAME:$$\" >> \"$LOG\"" EXIT

# Run task on chosen host
echo "+ $(date '+%d.%m.%y %H:%M:%S') $USER@$RESULT_HOST $CPU $RAM $HOSTNAME:$$ $RESULT_SCORE $PWD" >> "$LOG" && ssh $RESULT_HOST "cd \"$PWD\"; $COMMAND"
